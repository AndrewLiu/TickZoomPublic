; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

include listing.inc

INCLUDELIB OLDNAMES

_bad_alloc_Message DQ FLAT:??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
PUBLIC	?AddOrUpdateChild@FunctionInfo@@QEAAXPEAU1@@Z	; FunctionInfo::AddOrUpdateChild
; Function compile flags: /Ogtpy
; File c:\local\sharpdevelop_3.2.0.5777_source\src\addins\misc\profiler\hook\functioninfo.cpp
;	COMDAT ?AddOrUpdateChild@FunctionInfo@@QEAAXPEAU1@@Z
_TEXT	SEGMENT
this$ = 8
child$ = 16
?AddOrUpdateChild@FunctionInfo@@QEAAXPEAU1@@Z PROC	; FunctionInfo::AddOrUpdateChild, COMDAT

; 30   : 	int slot = child->Id;

	mov	r10d, DWORD PTR [rdx]

; 31   : 	for (;;) {
; 32   : 		slot &= this->LastChildIndex;

	mov	r11d, DWORD PTR [rcx+20]
	mov	r8d, r10d
	and	r8d, r11d

; 33   : 		FunctionInfo *slotContent = this->Children[slot];

	movsxd	rax, r8d
	mov	r9, QWORD PTR [rcx+rax*8+24]

; 34   : 		if (slotContent == nullptr || slotContent->Id == child->Id) {

	test	r9, r9
	je	SHORT $LN11@AddOrUpdat
	npad	6
$LL4@AddOrUpdat:
	cmp	DWORD PTR [r9], r10d
	je	SHORT $LN11@AddOrUpdat

; 36   : 			break;
; 37   : 		}
; 38   : 		slot++;

	inc	r8d
	and	r8d, r11d
	movsxd	rax, r8d
	mov	r9, QWORD PTR [rcx+rax*8+24]
	test	r9, r9
	jne	SHORT $LL4@AddOrUpdat
$LN11@AddOrUpdat:

; 35   : 			this->Children[slot] = child;

	movsxd	rax, r8d
	mov	QWORD PTR [rcx+rax*8+24], rdx

; 39   : 	}
; 40   : }

	ret	0
?AddOrUpdateChild@FunctionInfo@@QEAAXPEAU1@@Z ENDP	; FunctionInfo::AddOrUpdateChild
_TEXT	ENDS
PUBLIC	?Check@FunctionInfo@@QEAAXXZ			; FunctionInfo::Check
; Function compile flags: /Ogtpy
;	COMDAT ?Check@FunctionInfo@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?Check@FunctionInfo@@QEAAXXZ PROC			; FunctionInfo::Check, COMDAT

; 17   : 	#ifdef DEBUG
; 18   : 	int fc = 0;
; 19   : 	for (int i = 0; i <= LastChildIndex; i++) {
; 20   : 		if (Children[i] != nullptr) {
; 21   : 			fc++;
; 22   : 		}
; 23   : 	}
; 24   : 	assert(fc == FillCount);
; 25   : 	#endif
; 26   : }

	ret	0
?Check@FunctionInfo@@QEAAXXZ ENDP			; FunctionInfo::Check
PUBLIC	?FreeFunctionInfo@@YAXPEAUFunctionInfo@@@Z	; FreeFunctionInfo
; Function compile flags: /Ogtpy
;	COMDAT ?FreeFunctionInfo@@YAXPEAUFunctionInfo@@@Z
_TEXT	SEGMENT
f$ = 8
?FreeFunctionInfo@@YAXPEAUFunctionInfo@@@Z PROC		; FreeFunctionInfo, COMDAT

; 110  : 	sharedMemoryHeader->mallocator.free(f, sizeof(FunctionInfo) + (f->LastChildIndex + 1) * sizeof(FunctionInfo*));

	mov	eax, DWORD PTR [rcx+20]
	mov	r8, QWORD PTR ?sharedMemoryHeader@@3PEAUSharedMemoryHeader@@EA ; sharedMemoryHeader
	inc	eax
	movsxd	rdx, eax
	mov	eax, -1301749992			; b268df18H
	add	rdx, 3
	imul	rdx, rax
	shr	rdx, 32					; 00000020H
	and	edx, 31
	prefetchw BYTE PTR [r8+rdx*8+88]
	npad	7
$LL5@FreeFuncti:
	mov	rax, QWORD PTR [r8+rdx*8+88]
	mov	QWORD PTR [rcx], rax
	lock cmpxchg QWORD PTR [r8+rdx*8+88], rcx
	jne	SHORT $LL5@FreeFuncti

; 111  : }

	fatret	0
?FreeFunctionInfo@@YAXPEAUFunctionInfo@@@Z ENDP		; FreeFunctionInfo
_TEXT	ENDS
PUBLIC	?Resize@FunctionInfo@@AEAAPEAU1@H@Z		; FunctionInfo::Resize
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Resize@FunctionInfo@@AEAAPEAU1@H@Z DD imagerel $LN35
	DD	imagerel $LN35+252
	DD	imagerel $unwind$?Resize@FunctionInfo@@AEAAPEAU1@H@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Resize@FunctionInfo@@AEAAPEAU1@H@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ?Resize@FunctionInfo@@AEAAPEAU1@H@Z
_TEXT	SEGMENT
this$ = 48
newTableSize$ = 56
?Resize@FunctionInfo@@AEAAPEAU1@H@Z PROC		; FunctionInfo::Resize, COMDAT

; 58   : {

$LN35:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 59   : //	DebugWriteLine("Resize %d", Id);
; 60   : 	// Allocate space for the copy
; 61   : 	FunctionInfo* newFunction = (FunctionInfo *)sharedMemoryHeader->mallocator.malloc(sizeof(FunctionInfo) + newTableSize * sizeof(void*));

	mov	r10, QWORD PTR ?sharedMemoryHeader@@3PEAUSharedMemoryHeader@@EA ; sharedMemoryHeader
	movsxd	rsi, edx
	mov	rdi, rcx
	lea	r8, QWORD PTR [rsi*8+24]
	mov	r9, r8
	imul	r9, 374152163				; 164d1be3H
	shr	r9, 32					; 00000020H
	and	r9d, 31
$LL10@Resize:
	mov	rbx, QWORD PTR [r10+r9*8+88]
	test	rbx, rbx
	je	SHORT $LN28@Resize
	mov	rcx, QWORD PTR [rbx]
	mov	rax, rbx
	lock cmpxchg QWORD PTR [r10+r9*8+88], rcx
	jne	SHORT $LL10@Resize
	xor	edx, edx
	mov	rcx, rbx
	call	memset
	jmp	SHORT $LN11@Resize
$LN28@Resize:
	mov	rcx, r8
	lock xadd QWORD PTR [r10+72], rcx
	mov	rax, QWORD PTR [r10+80]
	xor	ebx, ebx
	sub	rax, rcx
	cmp	rax, r8
	cmovg	rbx, rcx
$LN11@Resize:

; 62   : 
; 63   : 	// Copy the header
; 64   : 	memcpy(newFunction, this, sizeof(FunctionInfo));

	mov	rax, QWORD PTR [rdi]
	mov	QWORD PTR [rbx], rax
	mov	rax, QWORD PTR [rdi+8]
	mov	QWORD PTR [rbx+8], rax
	mov	rax, QWORD PTR [rdi+16]
	mov	QWORD PTR [rbx+16], rax

; 65   : 	// Initialize the new table
; 66   : 	newFunction->LastChildIndex = newTableSize - 1;

	lea	eax, DWORD PTR [rsi-1]
	mov	DWORD PTR [rbx+20], eax

; 67   : 	// Copy the old table entries
; 68   : 	int oldTableSize = this->LastChildIndex + 1;

	mov	eax, DWORD PTR [rdi+20]
	inc	eax

; 69   : 	for(int i = 0; i < oldTableSize; i++) {

	movsxd	r11, eax
	test	eax, eax
	jle	SHORT $LN33@Resize

; 62   : 
; 63   : 	// Copy the header
; 64   : 	memcpy(newFunction, this, sizeof(FunctionInfo));

	lea	r10, QWORD PTR [rdi+24]
$LL4@Resize:

; 70   : 		FunctionInfo *child = this->Children[i];

	mov	r9, QWORD PTR [r10]

; 71   : 		if (child != nullptr) {

	test	r9, r9
	je	SHORT $LN3@Resize

; 72   : 			newFunction->AddOrUpdateChild(child);

	mov	r8d, DWORD PTR [r9]
	mov	ecx, r8d
	and	ecx, DWORD PTR [rbx+20]
	movsxd	rax, ecx
	mov	rdx, QWORD PTR [rbx+rax*8+24]
	test	rdx, rdx
	je	SHORT $LN34@Resize
	npad	2
$LL22@Resize:
	cmp	DWORD PTR [rdx], r8d
	je	SHORT $LN34@Resize
	inc	ecx
	and	ecx, DWORD PTR [rbx+20]
	movsxd	rax, ecx
	mov	rdx, QWORD PTR [rbx+rax*8+24]
	test	rdx, rdx
	jne	SHORT $LL22@Resize
$LN34@Resize:
	movsxd	rcx, ecx
	mov	QWORD PTR [rbx+rcx*8+24], r9
$LN3@Resize:
	add	r10, 8
	sub	r11, 1
	jne	SHORT $LL4@Resize
$LN33@Resize:

; 73   : 		}
; 74   : 	}
; 75   : 	// we cannot delete the original yet - we need to wait until all pointers to it have been updated,
; 76   : 	// because updating a pointer is safely possible only while the original still exists!
; 77   : 	// Done - FunctionInfo was resized
; 78   : 	return newFunction;
; 79   : }

	mov	rsi, QWORD PTR [rsp+56]
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?Resize@FunctionInfo@@AEAAPEAU1@H@Z ENDP		; FunctionInfo::Resize
_TEXT	ENDS
PUBLIC	?CreateFunctionInfo@@YAPEAUFunctionInfo@@HH@Z	; CreateFunctionInfo
; Function compile flags: /Ogtpy
;	COMDAT ?CreateFunctionInfo@@YAPEAUFunctionInfo@@HH@Z
_TEXT	SEGMENT
id$ = 8
indexInParent$ = 16
?CreateFunctionInfo@@YAPEAUFunctionInfo@@HH@Z PROC	; CreateFunctionInfo, COMDAT

; 43   : {

	mov	r11d, ecx

; 44   : 	// Allocate the child in memory
; 45   : 	FunctionInfo* newFunction = (FunctionInfo *)sharedMemoryHeader->mallocator.malloc(sizeof(FunctionInfo) + defaultTableSize * sizeof(void*));

	mov	rcx, QWORD PTR ?sharedMemoryHeader@@3PEAUSharedMemoryHeader@@EA ; sharedMemoryHeader
	movsxd	r10, edx
	npad	3
$LL6@CreateFunc:
	mov	r9, QWORD PTR [rcx+120]
	test	r9, r9
	je	SHORT $LN16@CreateFunc
	mov	r8, QWORD PTR [r9]
	mov	rax, r9
	lock cmpxchg QWORD PTR [rcx+120], r8
	jne	SHORT $LL6@CreateFunc
	xor	eax, eax
	mov	QWORD PTR [r9], rax
	mov	QWORD PTR [r9+8], rax
	mov	QWORD PTR [r9+16], rax
	mov	QWORD PTR [r9+24], rax
	mov	QWORD PTR [r9+32], rax
	mov	QWORD PTR [r9+40], rax
	mov	QWORD PTR [r9+48], rax
	jmp	SHORT $LN7@CreateFunc
$LN16@CreateFunc:
	mov	edx, 56					; 00000038H
	lock xadd QWORD PTR [rcx+72], rdx
	mov	rcx, QWORD PTR [rcx+80]
	xor	r9d, r9d
	sub	rcx, rdx
	cmp	rcx, 56					; 00000038H
	cmovg	r9, rdx
$LN7@CreateFunc:

; 46   : 	// the allocater takes care of zeroing the memory
; 47   : 	
; 48   : 	// Set field values
; 49   : 	newFunction->Id = id;
; 50   : 	newFunction->TimeSpent = (ULONGLONG)indexInParent << 56;

	mov	rcx, r10
	mov	DWORD PTR [r9], r11d

; 51   : 	// Initialize the table
; 52   : 	newFunction->LastChildIndex = defaultTableSize - 1;

	mov	DWORD PTR [r9+20], 3
	shl	rcx, 56					; 00000038H

; 53   : 	// Return pointer to the created child
; 54   : 	return newFunction;

	mov	rax, r9
	mov	QWORD PTR [r9+8], rcx

; 55   : }

	ret	0
?CreateFunctionInfo@@YAPEAUFunctionInfo@@HH@Z ENDP	; CreateFunctionInfo
PUBLIC	?GetOrAddChild@FunctionInfo@@QEAAPEAU1@HAEAPEAU1@@Z ; FunctionInfo::GetOrAddChild
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetOrAddChild@FunctionInfo@@QEAAPEAU1@HAEAPEAU1@@Z DD imagerel $LN27
	DD	imagerel $LN27+237
	DD	imagerel $unwind$?GetOrAddChild@FunctionInfo@@QEAAPEAU1@HAEAPEAU1@@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetOrAddChild@FunctionInfo@@QEAAPEAU1@HAEAPEAU1@@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ?GetOrAddChild@FunctionInfo@@QEAAPEAU1@HAEAPEAU1@@Z
_TEXT	SEGMENT
this$ = 48
functionID$ = 56
newParent$ = 64
?GetOrAddChild@FunctionInfo@@QEAAPEAU1@HAEAPEAU1@@Z PROC ; FunctionInfo::GetOrAddChild, COMDAT

; 82   : {

$LN27:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	esi, edx

; 83   : 	int lastChildIndex = this->LastChildIndex;

	mov	edx, DWORD PTR [rcx+20]
	mov	rbp, r8

; 84   : 	int slot = functionID;
; 85   : 	for (;;) {
; 86   : 		slot &= lastChildIndex;

	mov	ebx, edx
	mov	rdi, rcx
	and	ebx, esi

; 87   : 		FunctionInfo *slotContent = this->Children[slot];

	movsxd	rax, ebx
	mov	rax, QWORD PTR [rcx+rax*8+24]

; 88   : 		if (slotContent == nullptr) {

	test	rax, rax
	je	SHORT $LN21@GetOrAddCh
$LL7@GetOrAddCh:

; 101  : 		} else if (slotContent->Id == functionID) {

	cmp	DWORD PTR [rax], esi
	je	$LN6@GetOrAddCh

; 102  : 			return slotContent;
; 103  : 		}
; 104  : 		slot++;

	inc	ebx
	and	ebx, edx
	movsxd	rax, ebx
	mov	rax, QWORD PTR [rcx+rax*8+24]
	test	rax, rax
	jne	SHORT $LL7@GetOrAddCh
$LN21@GetOrAddCh:

; 89   : 			this->FillCount++;

	inc	DWORD PTR [rcx+16]
	mov	r8d, DWORD PTR [rcx+16]

; 90   : 			if (this->FillCount * 4 >= lastChildIndex * 3) {

	lea	eax, DWORD PTR [rdx+rdx*2]
	lea	ecx, DWORD PTR [r8*4]
	cmp	ecx, eax
	jl	SHORT $LN4@GetOrAddCh

; 91   : 				// resize table
; 92   : 				newParent = this->Resize(2 * (lastChildIndex + 1));

	lea	edx, DWORD PTR [rdx+rdx+2]
	mov	rcx, rdi
	call	?Resize@FunctionInfo@@AEAAPEAU1@H@Z	; FunctionInfo::Resize

; 93   : 				slotContent = CreateFunctionInfo(functionID, newParent->FillCount);

	mov	ecx, esi
	mov	edx, DWORD PTR [rax+16]
	mov	QWORD PTR [rbp], rax
	call	?CreateFunctionInfo@@YAPEAUFunctionInfo@@HH@Z ; CreateFunctionInfo

; 94   : 				newParent->AddOrUpdateChild(slotContent);

	mov	r9, QWORD PTR [rbp]
	mov	ebx, DWORD PTR [r9+20]
	mov	r10d, DWORD PTR [rax]
	mov	r11, rax
	mov	edx, ebx
	and	edx, r10d
	movsxd	rcx, edx
	mov	r8, QWORD PTR [r9+rcx*8+24]
	test	r8, r8
	je	SHORT $LN26@GetOrAddCh
	npad	7
$LL13@GetOrAddCh:
	cmp	DWORD PTR [r8], r10d
	je	SHORT $LN26@GetOrAddCh
	inc	edx
	and	edx, ebx
	movsxd	rax, edx
	mov	r8, QWORD PTR [r9+rax*8+24]
	test	r8, r8
	jne	SHORT $LL13@GetOrAddCh
$LN26@GetOrAddCh:
	movsxd	rax, edx
	mov	QWORD PTR [r9+rax*8+24], r11

; 95   : 				newParent->Check();
; 96   : 			} else {

	jmp	SHORT $LN3@GetOrAddCh
$LN4@GetOrAddCh:

; 97   : 				slotContent = CreateFunctionInfo(functionID, this->FillCount);

	mov	edx, r8d
	mov	ecx, esi
	call	?CreateFunctionInfo@@YAPEAUFunctionInfo@@HH@Z ; CreateFunctionInfo
	mov	r11, rax

; 98   : 				this->Children[slot] = slotContent;

	movsxd	rax, ebx
	mov	QWORD PTR [rdi+rax*8+24], r11
$LN3@GetOrAddCh:

; 99   : 			}
; 100  : 			return slotContent;

	mov	rax, r11
$LN6@GetOrAddCh:

; 105  : 	}
; 106  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?GetOrAddChild@FunctionInfo@@QEAAPEAU1@HAEAPEAU1@@Z ENDP ; FunctionInfo::GetOrAddChild
END
