; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

include listing.inc

INCLUDELIB OLDNAMES

_bad_alloc_Message DQ FLAT:??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
PUBLIC	?NextOffset@CCircularBuffer@@AEAAHH@Z		; CCircularBuffer::NextOffset
; Function compile flags: /Ogtpy
; File c:\local\sharpdevelop_3.2.0.5777_source\src\addins\misc\profiler\hook\circularbuffer.cpp
;	COMDAT ?NextOffset@CCircularBuffer@@AEAAHH@Z
_TEXT	SEGMENT
this$ = 8
offset$ = 16
?NextOffset@CCircularBuffer@@AEAAHH@Z PROC		; CCircularBuffer::NextOffset, COMDAT

; 162  : 	offset += 1;
; 163  : 	if (offset == this->dataLength)

	xor	eax, eax
	inc	edx
	cmp	edx, DWORD PTR [rcx+16]
	cmove	edx, eax
	mov	eax, edx

; 164  : 		return 0;
; 165  : 	else
; 166  : 		return offset;
; 167  : }

	ret	0
?NextOffset@CCircularBuffer@@AEAAHH@Z ENDP		; CCircularBuffer::NextOffset
PUBLIC	?WriteInternal@CCircularBuffer@@AEAAHPEAEHH@Z	; CCircularBuffer::WriteInternal
;	COMDAT pdata
; File c:\local\sharpdevelop_3.2.0.5777_source\src\addins\misc\profiler\hook\eventwaithandle.cpp
pdata	SEGMENT
$pdata$?WriteInternal@CCircularBuffer@@AEAAHPEAEHH@Z DD imagerel $LN25
	DD	imagerel $LN25+221
	DD	imagerel $unwind$?WriteInternal@CCircularBuffer@@AEAAHPEAEHH@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?WriteInternal@CCircularBuffer@@AEAAHPEAEHH@Z DD 0c1e01H
	DD	0b741eH
	DD	0a641eH
	DD	09541eH
	DD	08341eH
	DD	0e01a321eH
	DD	0c016d018H
; Function compile flags: /Ogtpy
; File c:\local\sharpdevelop_3.2.0.5777_source\src\addins\misc\profiler\hook\circularbuffer.cpp
xdata	ENDS
;	COMDAT ?WriteInternal@CCircularBuffer@@AEAAHPEAEHH@Z
_TEXT	SEGMENT
this$ = 64
data$ = 72
offset$ = 80
count$ = 88
?WriteInternal@CCircularBuffer@@AEAAHPEAEHH@Z PROC	; CCircularBuffer::WriteInternal, COMDAT

; 127  : {

$LN25:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r12
	push	r13
	push	r14
	sub	rsp, 32					; 00000020H

; 128  : 	// read startOffset and endOffset from shared memory
; 129  : 	int startOffset = this->header->StartOffset;

	mov	rax, QWORD PTR [rcx]
	mov	rbx, rcx
	mov	ebp, r9d
	mov	ecx, DWORD PTR [rax+8]

; 130  : 	int endOffset = this->header->EndOffset;

	mov	rax, QWORD PTR [rbx]
	movsxd	r12, r8d
	movsxd	rsi, DWORD PTR [rax+12]
	mov	r13, rdx
	xor	r14d, r14d
	lea	edi, DWORD PTR [rsi+1]
	npad	3
$LL8@WriteInter:

; 131  : 	// wait until there's room
; 132  : 	while (NextOffset(endOffset) == startOffset) {

	cmp	edi, DWORD PTR [rbx+16]
	mov	eax, edi
	cmove	eax, r14d
	cmp	eax, ecx
	jne	SHORT $LN7@WriteInter

; 133  : 		if (this->nonFullEvent->Wait() == WAIT_TIMEOUT)

	mov	rcx, QWORD PTR [rbx+32]
	or	edx, -1					; ffffffffH
	mov	rcx, QWORD PTR [rcx+8]
	call	QWORD PTR __imp_WaitForSingleObject
	cmp	eax, 258				; 00000102H
	je	SHORT $LN24@WriteInter

; 135  : 		// the reader should have changed the start offset
; 136  : 		startOffset = this->header->StartOffset;

	mov	rax, QWORD PTR [rbx]
	mov	ecx, DWORD PTR [rax+8]

; 137  : 	}

	jmp	SHORT $LL8@WriteInter
$LN24@WriteInter:

; 134  : 			return -1;

	or	eax, -1
	jmp	SHORT $LN9@WriteInter
$LN7@WriteInter:

; 138  : 	int writeEndOffset;
; 139  : 	if (startOffset <= endOffset) {

	cmp	ecx, esi
	jg	SHORT $LN5@WriteInter

; 140  : 		// free space wraps over buffer end
; 141  : 		if (startOffset == 0)
; 142  : 			writeEndOffset = this->dataLength - 1; // one byte must always be left free

	mov	edi, DWORD PTR [rbx+16]
	test	ecx, ecx
	jne	SHORT $LN2@WriteInter
	dec	edi

; 143  : 		else

	jmp	SHORT $LN2@WriteInter
$LN5@WriteInter:

; 144  : 			writeEndOffset = this->dataLength;
; 145  : 	} else {
; 146  : 		writeEndOffset = startOffset - 1; // one byte must be left free to distinguish between empty and full buffer

	lea	edi, DWORD PTR [rcx-1]
$LN2@WriteInter:

; 147  : 	}
; 148  : 	int writeCount = min(count, writeEndOffset - endOffset);

	sub	edi, esi

; 149  : 	
; 150  : 	memcpy(this->data + endOffset, data + offset, writeCount);

	mov	rcx, rsi
	lea	rdx, QWORD PTR [r13+r12]
	cmp	ebp, edi
	cmovl	edi, ebp
	add	rcx, QWORD PTR [rbx+8]
	movsxd	r8, edi
	call	memcpy

; 151  : 	endOffset += writeCount; // advance endOffset
; 152  : 	if (endOffset == this->dataLength) // wrap around startOffset if required
; 153  : 		endOffset = 0;
; 154  : 
; 155  : 	this->header->EndOffset = endOffset; // write back endOffset to shared memory

	mov	rcx, QWORD PTR [rbx]
	add	esi, edi
	cmp	esi, DWORD PTR [rbx+16]
	cmove	esi, r14d
	mov	DWORD PTR [rcx+12], esi

; 156  : 	this->nonEmptyEvent->Set(); // we wrote something, so the buffer is not empty anymore

	mov	rcx, QWORD PTR [rbx+24]
	mov	rcx, QWORD PTR [rcx+8]
	call	QWORD PTR __imp_SetEvent

; 157  : 	return writeCount;

	mov	eax, edi
$LN9@WriteInter:

; 158  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r14
	pop	r13
	pop	r12
	ret	0
?WriteInternal@CCircularBuffer@@AEAAHPEAEHH@Z ENDP	; CCircularBuffer::WriteInternal
_TEXT	ENDS
PUBLIC	?Write@CCircularBuffer@@QEAAHPEAEHH@Z		; CCircularBuffer::Write
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Write@CCircularBuffer@@QEAAHPEAEHH@Z DD imagerel $LN11
	DD	imagerel $LN11+112
	DD	imagerel $unwind$?Write@CCircularBuffer@@QEAAHPEAEHH@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Write@CCircularBuffer@@QEAAHPEAEHH@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ?Write@CCircularBuffer@@QEAAHPEAEHH@Z
_TEXT	SEGMENT
this$ = 48
data$ = 56
offset$ = 64
count$ = 72
?Write@CCircularBuffer@@QEAAHPEAEHH@Z PROC		; CCircularBuffer::Write, COMDAT

; 88   : {

$LN11:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	xor	edi, edi
	mov	ebx, r9d
	mov	rsi, rdx
	mov	rbp, rcx

; 89   : 	if (data == nullptr)

	test	rdx, rdx
	jne	SHORT $LN5@Write

; 90   : 		return -1;

	or	eax, -1
	jmp	SHORT $LN6@Write
$LN5@Write:

; 91   : 	if (count < 0)

	test	ebx, ebx
	jns	SHORT $LN10@Write

; 92   : 		return -2;

	mov	eax, -2
	jmp	SHORT $LN6@Write
$LN10@Write:

; 93   : 	if (offset < 0)
; 94   : 		return -3;
; 95   : 	
; 96   : 	while (count > 0) {

	jle	SHORT $LN1@Write
	npad	10
$LL2@Write:

; 97   : 		int r = WriteInternal(data, offset, count);

	mov	r9d, ebx
	mov	r8d, edi
	mov	rdx, rsi
	mov	rcx, rbp
	call	?WriteInternal@CCircularBuffer@@AEAAHPEAEHH@Z ; CCircularBuffer::WriteInternal

; 98   : 		offset += r;
; 99   : 		count -= r;

	sub	ebx, eax
	add	edi, eax
	test	ebx, ebx
	jg	SHORT $LL2@Write
$LN1@Write:

; 100  : 	}
; 101  : 	return count;

	mov	eax, ebx
$LN6@Write:

; 102  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?Write@CCircularBuffer@@QEAAHPEAEHH@Z ENDP		; CCircularBuffer::Write
_TEXT	ENDS
PUBLIC	??0CCircularBuffer@@QEAA@PEAX@Z			; CCircularBuffer::CCircularBuffer
;	COMDAT pdata
; File c:\local\sharpdevelop_3.2.0.5777_source\src\addins\misc\profiler\hook\eventwaithandle.cpp
pdata	SEGMENT
$pdata$??0CCircularBuffer@@QEAA@PEAX@Z DD imagerel $LN31
	DD	imagerel $LN31+297
	DD	imagerel $unwind$??0CCircularBuffer@@QEAA@PEAX@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0CCircularBuffer@@QEAA@PEAX@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
; File c:\local\sharpdevelop_3.2.0.5777_source\src\addins\misc\profiler\hook\circularbuffer.cpp
xdata	ENDS
;	COMDAT ??0CCircularBuffer@@QEAA@PEAX@Z
_TEXT	SEGMENT
this$ = 48
start$ = 56
??0CCircularBuffer@@QEAA@PEAX@Z PROC			; CCircularBuffer::CCircularBuffer, COMDAT

; 13   : {

$LN31:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 14   : 	this->header = (CircularBufferHeader*)start;

	mov	QWORD PTR [rcx], rdx

; 15   : 	if (this->header->Magic != '~CB1') {
; 16   : 		DebugWriteLine(L"Corrupted buffer header");
; 17   : 	}
; 18   : 	this->data = (byte*)(this->header + 1);

	lea	rax, QWORD PTR [rdx+24]
	mov	rdi, rcx
	mov	QWORD PTR [rcx+8], rax

; 19   : 	this->dataLength = this->header->TotalLength - sizeof(CircularBufferHeader);

	mov	eax, DWORD PTR [rdx+4]
	sub	eax, 24
	mov	DWORD PTR [rcx+16], eax

; 20   : 	this->nonFullEvent = OpenEventWaitHandle(GetEventName(this->header->NonFullEventName));

	mov	ebx, DWORD PTR [rdx+20]
	mov	ecx, 128				; 00000080H
	call	??_U@YAPEAX_K@Z				; operator new[]
	lea	r8, OFFSET FLAT:??_C@_0BI@BBOPOAJD@Local?2Profiler?4Event?4?$CFd?$AA@
	mov	r9d, ebx
	mov	rcx, rax
	mov	edx, 128				; 00000080H
	mov	rsi, rax
	call	QWORD PTR __imp_sprintf_s
	mov	ecx, 16
	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax
	test	rax, rax
	je	SHORT $LN11@CCircularB
	mov	r8, rsi
	xor	edx, edx
	mov	ecx, 1048578				; 00100002H
	mov	QWORD PTR [rax], rsi
	call	QWORD PTR __imp_OpenEventA
	mov	QWORD PTR [rbx+8], rax
	jmp	SHORT $LN12@CCircularB
$LN11@CCircularB:
	xor	ebx, ebx
$LN12@CCircularB:
	cmp	QWORD PTR [rbx+8], 0
	jne	SHORT $LN8@CCircularB
	mov	rcx, rbx
	call	??3@YAXPEAX@Z				; operator delete
	xor	ebx, ebx
$LN8@CCircularB:

; 21   : 	this->nonEmptyEvent = OpenEventWaitHandle(GetEventName(this->header->NonEmptyEventName));

	mov	rax, QWORD PTR [rdi]
	mov	QWORD PTR [rdi+32], rbx
	mov	ecx, 128				; 00000080H
	mov	ebx, DWORD PTR [rax+16]
	call	??_U@YAPEAX_K@Z				; operator new[]
	lea	r8, OFFSET FLAT:??_C@_0BI@BBOPOAJD@Local?2Profiler?4Event?4?$CFd?$AA@
	mov	rcx, rax
	mov	r9d, ebx
	mov	edx, 128				; 00000080H
	mov	rsi, rax
	call	QWORD PTR __imp_sprintf_s
	mov	ecx, 16
	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax
	test	rax, rax
	je	SHORT $LN23@CCircularB
	mov	r8, rsi
	xor	edx, edx
	mov	ecx, 1048578				; 00100002H
	mov	QWORD PTR [rax], rsi
	call	QWORD PTR __imp_OpenEventA
	mov	QWORD PTR [rbx+8], rax
	jmp	SHORT $LN24@CCircularB
$LN23@CCircularB:
	xor	ebx, ebx
$LN24@CCircularB:
	cmp	QWORD PTR [rbx+8], 0
	jne	SHORT $LN20@CCircularB
	mov	rcx, rbx
	call	??3@YAXPEAX@Z				; operator delete
	mov	QWORD PTR [rdi+24], 0

; 22   : 
; 23   : 	if (this->nonFullEvent != nullptr)
; 24   : 		DebugWriteLine(L"nonFullEvent found!\n");
; 25   : 	if (this->nonEmptyEvent != nullptr)
; 26   : 		DebugWriteLine(L"nonEmptyEvent found!\n");
; 27   : 
; 28   : 	DebugWriteLine(L"circular buffer header: %x %x %x %x\n", this->header->StartOffset, this->header->EndOffset, this->header->NonEmptyEventName, this->header->NonFullEventName);
; 29   : }

	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0

; 21   : 	this->nonEmptyEvent = OpenEventWaitHandle(GetEventName(this->header->NonEmptyEventName));

$LN20@CCircularB:

; 22   : 
; 23   : 	if (this->nonFullEvent != nullptr)
; 24   : 		DebugWriteLine(L"nonFullEvent found!\n");
; 25   : 	if (this->nonEmptyEvent != nullptr)
; 26   : 		DebugWriteLine(L"nonEmptyEvent found!\n");
; 27   : 
; 28   : 	DebugWriteLine(L"circular buffer header: %x %x %x %x\n", this->header->StartOffset, this->header->EndOffset, this->header->NonEmptyEventName, this->header->NonFullEventName);
; 29   : }

	mov	rsi, QWORD PTR [rsp+56]
	mov	QWORD PTR [rdi+24], rbx
	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0CCircularBuffer@@QEAA@PEAX@Z ENDP			; CCircularBuffer::CCircularBuffer
PUBLIC	?WriteInt@CCircularBuffer@@QEAAHH@Z		; CCircularBuffer::WriteInt
;	COMDAT pdata
pdata	SEGMENT
$pdata$?WriteInt@CCircularBuffer@@QEAAHH@Z DD imagerel $LN14
	DD	imagerel $LN14+77
	DD	imagerel $unwind$?WriteInt@CCircularBuffer@@QEAAHH@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?WriteInt@CCircularBuffer@@QEAAHH@Z DD 061301H
	DD	086413H
	DD	063413H
	DD	0700f3213H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ?WriteInt@CCircularBuffer@@QEAAHH@Z
_TEXT	SEGMENT
this$ = 48
data$ = 56
?WriteInt@CCircularBuffer@@QEAAHH@Z PROC		; CCircularBuffer::WriteInt, COMDAT

; 115  : {

$LN14:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], rsi
	mov	DWORD PTR [rsp+16], edx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, rcx

; 116  : 	return Write((byte*)&data, 0, 4);

	mov	ebx, 4
	xor	edi, edi
	npad	3
$LL4@WriteInt:
	lea	rdx, QWORD PTR data$[rsp]
	mov	r9d, ebx
	mov	r8d, edi
	mov	rcx, rsi
	call	?WriteInternal@CCircularBuffer@@AEAAHPEAEHH@Z ; CCircularBuffer::WriteInternal
	sub	ebx, eax
	add	edi, eax
	test	ebx, ebx
	jg	SHORT $LL4@WriteInt

; 117  : }

	mov	rsi, QWORD PTR [rsp+64]
	mov	eax, ebx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?WriteInt@CCircularBuffer@@QEAAHH@Z ENDP		; CCircularBuffer::WriteInt
PUBLIC	?WriteString@CCircularBuffer@@QEAAHPEA_W@Z	; CCircularBuffer::WriteString
;	COMDAT pdata
pdata	SEGMENT
$pdata$?WriteString@CCircularBuffer@@QEAAHPEA_W@Z DD imagerel $LN29
	DD	imagerel $LN29+168
	DD	imagerel $unwind$?WriteString@CCircularBuffer@@QEAAHPEA_W@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?WriteString@CCircularBuffer@@QEAAHPEA_W@Z DD 0a1801H
	DD	0b6418H
	DD	0a5418H
	DD	083418H
	DD	0d0143218H
	DD	07010c012H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ?WriteString@CCircularBuffer@@QEAAHPEA_W@Z
_TEXT	SEGMENT
this$ = 64
$T183872 = 72
string$ = 72
?WriteString@CCircularBuffer@@QEAAHPEA_W@Z PROC		; CCircularBuffer::WriteString, COMDAT

; 120  : {

$LN29:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	push	r12
	push	r13
	sub	rsp, 32					; 00000020H
	mov	rsi, rcx

; 121  : 	int len = (int)(wcslen(string) * sizeof(WCHAR));

	or	rcx, -1
	xor	eax, eax
	mov	rdi, rdx
	mov	r12, rdx

; 122  : 	WriteInt(len);

	mov	ebp, 4
	repne scasw
	not	rcx
	lea	rdi, QWORD PTR [rcx-1]
	add	edi, edi
	xor	ebx, ebx
	mov	r13d, ebx
	mov	DWORD PTR $T183872[rsp], edi
$LL6@WriteStrin:
	lea	rdx, QWORD PTR $T183872[rsp]
	mov	r9d, ebp
	mov	r8d, r13d
	mov	rcx, rsi
	call	?WriteInternal@CCircularBuffer@@AEAAHPEAEHH@Z ; CCircularBuffer::WriteInternal
	sub	ebp, eax
	add	r13d, eax
	test	ebp, ebp
	jg	SHORT $LL6@WriteStrin

; 123  : 	return Write((byte *)string, 0, len);

	test	r12, r12
	jne	SHORT $LN16@WriteStrin
	or	eax, -1
	jmp	SHORT $LN17@WriteStrin
$LN16@WriteStrin:
	test	edi, edi
	jns	SHORT $LN28@WriteStrin
	mov	eax, -2
	jmp	SHORT $LN17@WriteStrin
$LN28@WriteStrin:
	jle	SHORT $LN12@WriteStrin
$LL13@WriteStrin:
	mov	r9d, edi
	mov	r8d, ebx
	mov	rdx, r12
	mov	rcx, rsi
	call	?WriteInternal@CCircularBuffer@@AEAAHPEAEHH@Z ; CCircularBuffer::WriteInternal
	sub	edi, eax
	add	ebx, eax
	test	edi, edi
	jg	SHORT $LL13@WriteStrin
$LN12@WriteStrin:
	mov	eax, edi
$LN17@WriteStrin:

; 124  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r13
	pop	r12
	pop	rdi
	ret	0
?WriteString@CCircularBuffer@@QEAAHPEA_W@Z ENDP		; CCircularBuffer::WriteString
END
