; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0P@GHFPNOJB@bad?5allocation?$AA@		; `string'
PUBLIC	?allocMappingFunc@FunctionInfoAllocationSize@@SA_K_K@Z ; FunctionInfoAllocationSize::allocMappingFunc
PUBLIC	?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?PossibleAllocationSizes@FunctionInfoAllocationSize@@2QB_KB ; FunctionInfoAllocationSize::PossibleAllocationSizes
PUBLIC	??_C@_0BD@LFJLHDM@freeListAllocator?$DM?$AA@	; `string'
PUBLIC	??_C@_0BD@FKKALCJH@?$DO?5Self?5Test?5Failed?$AA@ ; `string'
PUBLIC	??_C@_0N@HKEMPAOP@fatal?5error?$CB?$AA@		; `string'
PUBLIC	??_R0?AUFunctionInfoAllocationSize@@@8		; FunctionInfoAllocationSize `RTTI Type Descriptor'
EXTRN	__imp_MessageBoxA:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEBD@Z:PROC
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ:PROC
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@PEBD@Z:PROC
EXTRN	__imp_?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEBAPEBDXZ:PROC
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ:PROC
EXTRN	?__type_info_root_node@@3U__type_info_node@@A:BYTE ; __type_info_root_node
EXTRN	__imp_?name@type_info@@QEBAPEBDPEAU__type_info_node@@@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
;	COMDAT ??_R0?AUFunctionInfoAllocationSize@@@8
_DATA	SEGMENT
??_R0?AUFunctionInfoAllocationSize@@@8 DQ FLAT:??_7type_info@@6B@ ; FunctionInfoAllocationSize `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AUFunctionInfoAllocationSize@@', 00H
_DATA	ENDS
;	COMDAT ??_C@_0N@HKEMPAOP@fatal?5error?$CB?$AA@
CONST	SEGMENT
??_C@_0N@HKEMPAOP@fatal?5error?$CB?$AA@ DB 'fatal error!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FKKALCJH@?$DO?5Self?5Test?5Failed?$AA@
CONST	SEGMENT
??_C@_0BD@FKKALCJH@?$DO?5Self?5Test?5Failed?$AA@ DB '> Self Test Failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LFJLHDM@freeListAllocator?$DM?$AA@
CONST	SEGMENT
??_C@_0BD@LFJLHDM@freeListAllocator?$DM?$AA@ DB 'freeListAllocator<', 00H ; `string'
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB
CONST	SEGMENT
?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB DB 01H ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
CONST	ENDS
;	COMDAT ??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
CONST	SEGMENT
??_C@_0P@GHFPNOJB@bad?5allocation?$AA@ DB 'bad allocation', 00H ; `string'
?PossibleAllocationSizes@FunctionInfoAllocationSize@@2QB_KB DQ 0000000000000020H ; FunctionInfoAllocationSize::PossibleAllocationSizes
	DQ	0000000000000028H
	DQ	0000000000000038H
	DQ	0000000000000058H
	DQ	0000000000000098H
	DQ	0000000000000118H
	DQ	0000000000000218H
	DQ	0000000000000418H
	DQ	0000000000000818H
	DQ	0000000000001018H
	DQ	0000000000002018H
	DQ	0000000000004018H
	DQ	0000000000008018H
	DQ	0000000000010018H
	DQ	0000000000020018H
	DQ	0000000000040018H
	DQ	0000000000080018H
	DQ	0000000000100018H
	DQ	0000000000200018H
	DQ	0000000000400018H
	DQ	0000000000800018H
	DQ	0000000001000018H
	DQ	0000000002000018H
	DQ	0000000004000018H
	DQ	0000000008000018H
	DQ	0000000010000018H
_bad_alloc_Message DQ FLAT:??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
PUBLIC	?free@fastAllocator@@QEAAXPEAX_K@Z		; fastAllocator::free
; Function compile flags: /Ogtpy
; File c:\local\sharpdevelop_3.2.0.5777_source\src\addins\misc\profiler\hook\allocator.cpp
;	COMDAT ?free@fastAllocator@@QEAAXPEAX_K@Z
_TEXT	SEGMENT
this$ = 8
memory$ = 16
bytes$ = 24
?free@fastAllocator@@QEAAXPEAX_K@Z PROC			; fastAllocator::free, COMDAT

; 70   : 	assert(memory != nullptr);
; 71   : 	assert(memory >= startPos && memory < endPos);
; 72   : 	#if DEBUG
; 73   : 	assert(((size_t*)memory)[-1] == bytes);
; 74   : 	#endif
; 75   : }

	ret	0
?free@fastAllocator@@QEAAXPEAX_K@Z ENDP			; fastAllocator::free
_TEXT	ENDS
PUBLIC	?malloc@fastAllocator@@QEAAPEAX_K@Z		; fastAllocator::malloc
; Function compile flags: /Ogtpy
;	COMDAT ?malloc@fastAllocator@@QEAAPEAX_K@Z
_TEXT	SEGMENT
this$ = 8
bytes$ = 16
?malloc@fastAllocator@@QEAAPEAX_K@Z PROC		; fastAllocator::malloc, COMDAT

; 39   : 	assert(pos != nullptr); // ensure allocator is initialized before malloc is called
; 40   : 	
; 41   : 	// must be compatible with C# malloc! (used in Data Collection)
; 42   : 	
; 43   : 	#if DEBUG
; 44   : 	// space for debugging info
; 45   : 	const size_t debuggingInfoSize = 8; //sizeof(size_t); - always use 8 so we keep proper alignment for LONGLONGs
; 46   : 	bytes += debuggingInfoSize; 
; 47   : 	#endif
; 48   : 	
; 49   : 	#ifdef _M_AMD64
; 50   : 	void *t = (void*)_InterlockedExchangeAdd64((__int64 volatile*)&pos, (__int64)bytes);

	mov	r8, rdx
	lock xadd QWORD PTR [rcx+8], r8

; 51   : 	#else
; 52   : 	void *t = (void*)_InterlockedExchangeAdd((LONG volatile*)&pos, (LONG)bytes);
; 53   : 	#endif
; 54   : 	
; 55   : 	if ((byte*)endPos - (byte*)t > (ptrdiff_t)bytes) {

	mov	rcx, QWORD PTR [rcx+16]
	xor	eax, eax
	sub	rcx, r8
	cmp	rcx, rdx
	cmovg	rax, r8

; 56   : 		#if DEBUG
; 57   : 		t = (byte*)t + debuggingInfoSize; // skip over debugging info
; 58   : 		((size_t*)t)[-1] = bytes - debuggingInfoSize;
; 59   : 		#endif
; 60   : 		assert(isAligned(t));
; 61   : 		return t;
; 62   : 	} else {
; 63   : 		return nullptr;
; 64   : 	}
; 65   : }

	ret	0
?malloc@fastAllocator@@QEAAPEAX_K@Z ENDP		; fastAllocator::malloc
_TEXT	ENDS
PUBLIC	?initialize@fastAllocator@@QEAAXPEAX0@Z		; fastAllocator::initialize
; Function compile flags: /Ogtpy
;	COMDAT ?initialize@fastAllocator@@QEAAXPEAX0@Z
_TEXT	SEGMENT
this$ = 8
pos$ = 16
endPos$ = 24
?initialize@fastAllocator@@QEAAXPEAX0@Z PROC		; fastAllocator::initialize, COMDAT

; 26   : 	assert(isAligned(pos));
; 27   : 	assert(pos != nullptr);
; 28   : 	assert(endPos > pos);
; 29   : 	
; 30   : 	assert(startPos == nullptr);
; 31   : 	
; 32   : 	this->startPos = pos;

	mov	QWORD PTR [rcx], rdx

; 33   : 	this->pos = pos;
; 34   : 	this->endPos = endPos;

	mov	QWORD PTR [rcx+16], r8
	mov	QWORD PTR [rcx+8], rdx

; 35   : }

	ret	0
?initialize@fastAllocator@@QEAAXPEAX0@Z ENDP		; fastAllocator::initialize
_TEXT	ENDS
PUBLIC	??0fastAllocator@@QEAA@XZ			; fastAllocator::fastAllocator
; Function compile flags: /Ogtpy
;	COMDAT ??0fastAllocator@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0fastAllocator@@QEAA@XZ PROC				; fastAllocator::fastAllocator, COMDAT

; 21   : {

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 22   : }

	mov	rax, rcx
	ret	0
??0fastAllocator@@QEAA@XZ ENDP				; fastAllocator::fastAllocator
; Function compile flags: /Ogtpy
; File c:\local\sharpdevelop_3.2.0.5777_source\src\addins\misc\profiler\hook\allocator.h
_TEXT	ENDS
;	COMDAT ?allocMappingFunc@FunctionInfoAllocationSize@@SA_K_K@Z
_TEXT	SEGMENT
bytes$ = 8
?allocMappingFunc@FunctionInfoAllocationSize@@SA_K_K@Z PROC ; FunctionInfoAllocationSize::allocMappingFunc, COMDAT

; 49   : 		return (UINT_PTR)(((bytes * 374152163ULL) >> 32) & 31);

	imul	rcx, 374152163				; 164d1be3H
	shr	rcx, 32					; 00000020H
	and	ecx, 31
	mov	rax, rcx

; 50   : 	}

	ret	0
?allocMappingFunc@FunctionInfoAllocationSize@@SA_K_K@Z ENDP ; FunctionInfoAllocationSize::allocMappingFunc
PUBLIC	?free@?$freeListAllocator@UFunctionInfoAllocationSize@@@@QEAAXPEAX_K@Z ; freeListAllocator<FunctionInfoAllocationSize>::free
; Function compile flags: /Ogtpy
; File c:\local\sharpdevelop_3.2.0.5777_source\src\addins\misc\profiler\hook\allocator.cpp
;	COMDAT ?free@?$freeListAllocator@UFunctionInfoAllocationSize@@@@QEAAXPEAX_K@Z
_TEXT	SEGMENT
this$ = 8
memory$ = 16
bytes$ = 24
?free@?$freeListAllocator@UFunctionInfoAllocationSize@@@@QEAAXPEAX_K@Z PROC ; freeListAllocator<FunctionInfoAllocationSize>::free, COMDAT

; 137  : 	// the base allocator cannot free, just allow it to check whether 'bytes' is the correct size
; 138  : 	allocator.free(memory, bytes);
; 139  : 	
; 140  : 	assert(bytes >= sizeof(void*));
; 141  : 	assert(isPossibleAllocationSize(bytes));
; 142  : 	
; 143  : //	DebugWriteLine("Freeing memory of size %Id", bytes);
; 144  : 	void* volatile* freeListSlot = &freeList[T::allocMappingFunc(bytes)];

	imul	r8, 374152163				; 164d1be3H
	shr	r8, 32					; 00000020H
	and	r8d, 31

; 149  : 	} while (InterlockedCompareExchangePointer(freeListSlot, memory, t) != t);

	prefetchw BYTE PTR [rcx+r8*8+24]
	npad	11
$LL3@free:

; 145  : 	void* t;
; 146  : 	do {
; 147  : 		t = *freeListSlot;

	mov	rax, QWORD PTR [rcx+r8*8+24]

; 148  : 		*(void**)memory = t;

	mov	QWORD PTR [rdx], rax

; 149  : 	} while (InterlockedCompareExchangePointer(freeListSlot, memory, t) != t);

	lock cmpxchg QWORD PTR [rcx+r8*8+24], rdx
	jne	SHORT $LL3@free

; 150  : }

	fatret	0
?free@?$freeListAllocator@UFunctionInfoAllocationSize@@@@QEAAXPEAX_K@Z ENDP ; freeListAllocator<FunctionInfoAllocationSize>::free
_TEXT	ENDS
PUBLIC	?malloc@?$freeListAllocator@UFunctionInfoAllocationSize@@@@QEAAPEAX_K@Z ; freeListAllocator<FunctionInfoAllocationSize>::malloc
EXTRN	memset:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$?malloc@?$freeListAllocator@UFunctionInfoAllocationSize@@@@QEAAPEAX_K@Z DD imagerel $LN16
	DD	imagerel $LN16+107
	DD	imagerel $unwind$?malloc@?$freeListAllocator@UFunctionInfoAllocationSize@@@@QEAAPEAX_K@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?malloc@?$freeListAllocator@UFunctionInfoAllocationSize@@@@QEAAPEAX_K@Z DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ?malloc@?$freeListAllocator@UFunctionInfoAllocationSize@@@@QEAAPEAX_K@Z
_TEXT	SEGMENT
this$ = 48
bytes$ = 56
?malloc@?$freeListAllocator@UFunctionInfoAllocationSize@@@@QEAAPEAX_K@Z PROC ; freeListAllocator<FunctionInfoAllocationSize>::malloc, COMDAT

; 119  : {

$LN16:
	push	rbx
	sub	rsp, 32					; 00000020H

; 120  : 	assert(bytes >= sizeof(void*));
; 121  : 	assert(isPossibleAllocationSize(bytes));
; 122  : 	void* volatile* freeListSlot = &freeList[T::allocMappingFunc(bytes)];

	mov	r8, rdx
	mov	r10, rdx
	mov	r9, rcx
	imul	r8, 374152163				; 164d1be3H
	shr	r8, 32					; 00000020H
	and	r8d, 31
	npad	2
$LL4@malloc:

; 123  : 	void* t;
; 124  : 	void* next;
; 125  : 	do {
; 126  : 		t = *freeListSlot; // volatile read has acquire semantics

	mov	rbx, QWORD PTR [r9+r8*8+24]

; 127  : 		if (t == nullptr)

	test	rbx, rbx
	je	SHORT $LN14@malloc

; 129  : //		DebugWriteLine("Reusing memory of size %Id", bytes);
; 130  : 		next = *(void**)t;

	mov	rcx, QWORD PTR [rbx]

; 131  : 	} while (InterlockedCompareExchangePointer(freeListSlot, next, t) != t);

	mov	rax, rbx
	lock cmpxchg QWORD PTR [r9+r8*8+24], rcx
	jne	SHORT $LL4@malloc

; 132  : 	memset(t, 0, bytes);

	mov	r8, rdx
	mov	rcx, rbx
	xor	edx, edx
	call	memset

; 133  : 	return t;

	mov	rax, rbx

; 134  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN14@malloc:

; 128  : 			return allocator.malloc(bytes);

	lock xadd QWORD PTR [r9+8], rdx
	mov	rcx, QWORD PTR [r9+16]
	xor	eax, eax
	sub	rcx, rdx
	cmp	rcx, r10
	cmovg	rax, rdx

; 134  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?malloc@?$freeListAllocator@UFunctionInfoAllocationSize@@@@QEAAPEAX_K@Z ENDP ; freeListAllocator<FunctionInfoAllocationSize>::malloc
_TEXT	ENDS
PUBLIC	?initialize@?$freeListAllocator@UFunctionInfoAllocationSize@@@@QEAAXPEAX0@Z ; freeListAllocator<FunctionInfoAllocationSize>::initialize
; Function compile flags: /Ogtpy
;	COMDAT ?initialize@?$freeListAllocator@UFunctionInfoAllocationSize@@@@QEAAXPEAX0@Z
_TEXT	SEGMENT
this$ = 8
pos$ = 16
endPos$ = 24
?initialize@?$freeListAllocator@UFunctionInfoAllocationSize@@@@QEAAXPEAX0@Z PROC ; freeListAllocator<FunctionInfoAllocationSize>::initialize, COMDAT

; 80   : 	allocator.initialize(pos, endPos);

	mov	QWORD PTR [rcx], rdx
	mov	QWORD PTR [rcx+16], r8
	mov	QWORD PTR [rcx+8], rdx

; 81   : }

	ret	0
?initialize@?$freeListAllocator@UFunctionInfoAllocationSize@@@@QEAAXPEAX0@Z ENDP ; freeListAllocator<FunctionInfoAllocationSize>::initialize
_TEXT	ENDS
PUBLIC	??0?$freeListAllocator@UFunctionInfoAllocationSize@@@@QEAA@XZ ; freeListAllocator<FunctionInfoAllocationSize>::freeListAllocator<FunctionInfoAllocationSize>
;	COMDAT pdata
; File c:\program files\microsoft visual studio 9.0\vc\include\xstring
pdata	SEGMENT
$pdata$??0?$freeListAllocator@UFunctionInfoAllocationSize@@@@QEAA@XZ DD imagerel $LN31
	DD	imagerel $LN31+325
	DD	imagerel $unwind$??0?$freeListAllocator@UFunctionInfoAllocationSize@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$freeListAllocator@UFunctionInfoAllocationSize@@@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0?$freeListAllocator@UFunctionInfoAllocationSize@@@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0?$freeListAllocator@UFunctionInfoAllocationSize@@@@QEAA@XZ@4HA+25
	DD	imagerel $unwind$?dtor$0@?0???0?$freeListAllocator@UFunctionInfoAllocationSize@@@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$freeListAllocator@UFunctionInfoAllocationSize@@@@QEAA@XZ DD imagerel ??0?$freeListAllocator@UFunctionInfoAllocationSize@@@@QEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??0?$freeListAllocator@UFunctionInfoAllocationSize@@@@QEAA@XZ+180
	DD	00H
	DD	imagerel ??0?$freeListAllocator@UFunctionInfoAllocationSize@@@@QEAA@XZ+268
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$freeListAllocator@UFunctionInfoAllocationSize@@@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$freeListAllocator@UFunctionInfoAllocationSize@@@@QEAA@XZ DD 081e11H
	DD	0e641eH
	DD	0d5419H
	DD	0c3414H
	DD	070029206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0?$freeListAllocator@UFunctionInfoAllocationSize@@@@QEAA@XZ
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0?$freeListAllocator@UFunctionInfoAllocationSize@@@@QEAA@XZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??0?$freeListAllocator@UFunctionInfoAllocationSize@@@@QEAA@XZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??0?$freeListAllocator@UFunctionInfoAllocationSize@@@@QEAA@XZ
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$freeListAllocator@UFunctionInfoAllocationSize@@@@QEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0?$freeListAllocator@UFunctionInfoAllocationSize@@@@QEAA@XZ@4HA
; Function compile flags: /Ogtpy
; File c:\local\sharpdevelop_3.2.0.5777_source\src\addins\misc\profiler\hook\allocator.cpp
xdata	ENDS
;	COMDAT ??0?$freeListAllocator@UFunctionInfoAllocationSize@@@@QEAA@XZ
_TEXT	SEGMENT
$T151873 = 32
msg$83193 = 40
this$ = 96
??0?$freeListAllocator@UFunctionInfoAllocationSize@@@@QEAA@XZ PROC ; freeListAllocator<FunctionInfoAllocationSize>::freeListAllocator<FunctionInfoAllocationSize>, COMDAT

; 84   : {

$LN31:
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	QWORD PTR $T151873[rsp], -2
	mov	QWORD PTR [rsp+96], rbx
	mov	QWORD PTR [rsp+104], rbp
	mov	QWORD PTR [rsp+112], rsi
	xor	esi, esi
	mov	QWORD PTR ?mallocator@@3U?$freeListAllocator@UFunctionInfoAllocationSize@@@@A, rsi
	mov	QWORD PTR ?mallocator@@3U?$freeListAllocator@UFunctionInfoAllocationSize@@@@A+8, rsi
	mov	QWORD PTR ?mallocator@@3U?$freeListAllocator@UFunctionInfoAllocationSize@@@@A+16, rsi
	lea	rbx, OFFSET FLAT:?mallocator@@3U?$freeListAllocator@UFunctionInfoAllocationSize@@@@A+24
	mov	rax, rbx
	mov	edi, 32					; 00000020H
	mov	rcx, rdi
	npad	9
$LL10@freeListAl:

; 86   : 		freeList[i] = nullptr;

	mov	QWORD PTR [rax], rsi

; 85   : 	for (int i = 0; i < freeListSize; i++) {

	add	rax, 8
	sub	rcx, 1
	jne	SHORT $LL10@freeListAl

; 87   : 	}
; 88   : 	// check if the allocMappingFunc works for our allocation size
; 89   : 	const int numberOfAllocationSizes = sizeof(T::PossibleAllocationSizes) / sizeof(size_t);
; 90   : 	for (int i = 0; i < numberOfAllocationSizes; i++) {

	lea	rdx, OFFSET FLAT:?PossibleAllocationSizes@FunctionInfoAllocationSize@@2QB_KB ; FunctionInfoAllocationSize::PossibleAllocationSizes
	lea	rbp, OFFSET FLAT:?mallocator@@3U?$freeListAllocator@UFunctionInfoAllocationSize@@@@A ; mallocator
	lea	r8, OFFSET FLAT:?PossibleAllocationSizes@FunctionInfoAllocationSize@@2QB_KB+208
$LL7@freeListAl:

; 91   : 		void* volatile & slot = freeList[T::allocMappingFunc( T::PossibleAllocationSizes[i] )];

	mov	rcx, QWORD PTR [rdx]
	imul	rcx, 374152163				; 164d1be3H
	shr	rcx, 32					; 00000020H
	and	ecx, 31

; 92   : 		if (slot != nullptr) {

	mov	rax, QWORD PTR [rbp+rcx*8+24]
	test	rax, rax
	jne	SHORT $LN27@freeListAl

; 98   : 		}
; 99   : 		slot = (void*)1;

	mov	QWORD PTR [rbp+rcx*8+24], 1

; 87   : 	}
; 88   : 	// check if the allocMappingFunc works for our allocation size
; 89   : 	const int numberOfAllocationSizes = sizeof(T::PossibleAllocationSizes) / sizeof(size_t);
; 90   : 	for (int i = 0; i < numberOfAllocationSizes; i++) {

	add	rdx, 8
	cmp	rdx, r8
	jl	SHORT $LL7@freeListAl

; 92   : 		if (slot != nullptr) {

	jmp	SHORT $LL3@freeListAl
$LN27@freeListAl:

; 93   : 			std::string msg = "freeListAllocator<";

	lea	rdx, OFFSET FLAT:??_C@_0BD@LFJLHDM@freeListAllocator?$DM?$AA@
	lea	rcx, QWORD PTR msg$83193[rsp]
	call	QWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEBD@Z
	npad	1

; 94   : 			msg += typeid(T).name();

	lea	rdx, OFFSET FLAT:?__type_info_root_node@@3U__type_info_node@@A ; __type_info_root_node
	lea	rcx, OFFSET FLAT:??_R0?AUFunctionInfoAllocationSize@@@8
	call	QWORD PTR __imp_?name@type_info@@QEBAPEBDPEAU__type_info_node@@@Z
	mov	rdx, rax
	lea	rcx, QWORD PTR msg$83193[rsp]
	call	QWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@PEBD@Z

; 95   : 			msg += "> Self Test Failed";

	lea	rdx, OFFSET FLAT:??_C@_0BD@FKKALCJH@?$DO?5Self?5Test?5Failed?$AA@
	lea	rcx, QWORD PTR msg$83193[rsp]
	call	QWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@PEBD@Z

; 96   : 			MessageBox(nullptr, msg.c_str(), TEXT("fatal error!"), MB_OK);

	lea	rdx, QWORD PTR msg$83193[rsp+8]
	cmp	QWORD PTR msg$83193[rsp+32], 16
	cmovae	rdx, QWORD PTR msg$83193[rsp+8]
	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0N@HKEMPAOP@fatal?5error?$CB?$AA@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	npad	1

; 97   : 			break;

	lea	rcx, QWORD PTR msg$83193[rsp]
	call	QWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	npad	9
$LL3@freeListAl:

; 103  : 		freeList[i] = nullptr;

	mov	QWORD PTR [rbx], rsi

; 100  : 	}
; 101  : 	
; 102  : 	for (int i = 0; i < freeListSize; i++) {

	add	rbx, 8
	sub	rdi, 1
	jne	SHORT $LL3@freeListAl

; 104  : 	}
; 105  : }

	mov	rax, rbp
	mov	rbx, QWORD PTR [rsp+96]
	mov	rbp, QWORD PTR [rsp+104]
	mov	rsi, QWORD PTR [rsp+112]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
??0?$freeListAllocator@UFunctionInfoAllocationSize@@@@QEAA@XZ ENDP ; freeListAllocator<FunctionInfoAllocationSize>::freeListAllocator<FunctionInfoAllocationSize>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T151873 = 32
msg$83193 = 40
this$ = 96
?dtor$0@?0???0?$freeListAllocator@UFunctionInfoAllocationSize@@@@QEAA@XZ@4HA PROC ; `freeListAllocator<FunctionInfoAllocationSize>::freeListAllocator<FunctionInfoAllocationSize>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR msg$83193[rbp]
	call	QWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$freeListAllocator@UFunctionInfoAllocationSize@@@@QEAA@XZ@4HA ENDP ; `freeListAllocator<FunctionInfoAllocationSize>::freeListAllocator<FunctionInfoAllocationSize>'::`1'::dtor$0
END
