; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Local\SharpDevelop_3.2.0.5777_Source\src\AddIns\Misc\Profiler\Hook\ProfilerMetaData.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??$?0_W@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><wchar_t>
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@_W@std@@@std@@IAE@V?$allocator@_W@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<wchar_t> >::_Container_base_aux_alloc_real<std::allocator<wchar_t> >
PUBLIC	??$?0_W@?$allocator@PA_W@std@@QAE@ABV?$allocator@_W@1@@Z ; std::allocator<wchar_t *>::allocator<wchar_t *><wchar_t>
PUBLIC	??0?$_Deque_map@_WV?$allocator@_W@std@@@std@@IAE@V?$allocator@_W@1@@Z ; std::_Deque_map<wchar_t,std::allocator<wchar_t> >::_Deque_map<wchar_t,std::allocator<wchar_t> >
PUBLIC	??0?$_Deque_val@_WV?$allocator@_W@std@@@std@@IAE@V?$allocator@_W@1@@Z ; std::_Deque_val<wchar_t,std::allocator<wchar_t> >::_Deque_val<wchar_t,std::allocator<wchar_t> >
PUBLIC	??0?$deque@_WV?$allocator@_W@std@@@std@@QAE@XZ	; std::deque<wchar_t,std::allocator<wchar_t> >::deque<wchar_t,std::allocator<wchar_t> >
PUBLIC	??0?$stack@_WV?$deque@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::stack<wchar_t,std::deque<wchar_t,std::allocator<wchar_t> > >::stack<wchar_t,std::deque<wchar_t,std::allocator<wchar_t> > >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@_W@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<wchar_t> >::~_Container_base_aux_alloc_real<std::allocator<wchar_t> >
PUBLIC	??1?$_Deque_map@_WV?$allocator@_W@std@@@std@@QAE@XZ ; std::_Deque_map<wchar_t,std::allocator<wchar_t> >::~_Deque_map<wchar_t,std::allocator<wchar_t> >
PUBLIC	??1?$_Deque_val@_WV?$allocator@_W@std@@@std@@QAE@XZ ; std::_Deque_val<wchar_t,std::allocator<wchar_t> >::~_Deque_val<wchar_t,std::allocator<wchar_t> >
PUBLIC	??$_Destroy@PA_W@std@@YAXPAPA_W@Z		; std::_Destroy<wchar_t *>
PUBLIC	?destroy@?$allocator@PA_W@std@@QAEXPAPA_W@Z	; std::allocator<wchar_t *>::destroy
PUBLIC	?_Tidy@?$deque@_WV?$allocator@_W@std@@@std@@IAEXXZ ; std::deque<wchar_t,std::allocator<wchar_t> >::_Tidy
PUBLIC	??1?$deque@_WV?$allocator@_W@std@@@std@@QAE@XZ	; std::deque<wchar_t,std::allocator<wchar_t> >::~deque<wchar_t,std::allocator<wchar_t> >
PUBLIC	??1?$stack@_WV?$deque@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::stack<wchar_t,std::deque<wchar_t,std::allocator<wchar_t> > >::~stack<wchar_t,std::deque<wchar_t,std::allocator<wchar_t> > >
PUBLIC	??0?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@XZ ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
PUBLIC	??$?0V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@IAE@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Container_base_aux_alloc_real<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
PUBLIC	??0?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
PUBLIC	??$?0V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *>::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *><std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
PUBLIC	??0?$_Deque_map@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAE@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z ; std::_Deque_map<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Deque_map<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
PUBLIC	??0?$_Deque_val@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAE@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z ; std::_Deque_val<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Deque_val<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
PUBLIC	??0?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ ; std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
PUBLIC	??0?$stack@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@@std@@QAE@XZ ; std::stack<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::stack<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >
PUBLIC	?empty@?$stack@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@@std@@QBE_NXZ ; std::stack<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::empty
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@HPBV32@ABV32@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,int,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,int,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const &,std::_Iterator_base_aux>
PUBLIC	??0?$_Ranit@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HPBV12@ABV12@@std@@QAE@XZ ; std::_Ranit<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,int,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const &>::_Ranit<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,int,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const &>
PUBLIC	??0?$_Deque_const_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@$00@std@@QAE@IPBV_Container_base_aux@1@@Z ; std::_Deque_const_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,1>::_Deque_const_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,1>
PUBLIC	??0?$_Deque_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@$00@std@@QAE@IPBV_Container_base_aux@1@@Z ; std::_Deque_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,1>::_Deque_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,1>
PUBLIC	?end@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE?AV?$_Deque_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@$00@2@XZ ; std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::end
PUBLIC	??D?$_Deque_const_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@$00@std@@QBEABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@XZ ; std::_Deque_const_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,1>::operator*
PUBLIC	??D?$_Deque_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@$00@std@@QBEAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@XZ ; std::_Deque_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,1>::operator*
PUBLIC	??Y?$_Deque_const_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@$00@std@@QAEAAV01@H@Z ; std::_Deque_const_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,1>::operator+=
PUBLIC	??Y?$_Deque_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@$00@std@@QAEAAV01@H@Z ; std::_Deque_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,1>::operator+=
PUBLIC	??Z?$_Deque_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@$00@std@@QAEAAV01@H@Z ; std::_Deque_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,1>::operator-=
PUBLIC	??G?$_Deque_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@$00@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,1>::operator-
PUBLIC	?back@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ; std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::back
PUBLIC	?top@?$stack@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@@std@@QAEAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ; std::stack<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::top
PUBLIC	??$_Allocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@IPAV10@@Z ; std::_Allocate<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
PUBLIC	?allocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::allocate
PUBLIC	??$_Construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@@Z ; std::_Construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
PUBLIC	?construct@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@ABV32@@Z ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::construct
PUBLIC	??$_Allocate@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@IPAPAV10@@Z ; std::_Allocate<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *>
PUBLIC	?allocate@?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *>::allocate
PUBLIC	?max_size@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QBEIXZ ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::max_size
PUBLIC	?max_size@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ ; std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::max_size
PUBLIC	?_Xlen@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@KAXXZ ; std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Xlen
PUBLIC	??$_Uninit_copy@PAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAPAV12@V?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAPAV10@00AAV?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *> >
PUBLIC	??$unchecked_uninitialized_copy@PAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAPAV12@V?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@stdext@@YAPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAPAV12@00AAV?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@Z ; stdext::unchecked_uninitialized_copy<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *> >
PUBLIC	??$_Iter_cat@PAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ; std::_Iter_cat<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * *>
PUBLIC	??$_Checked_base@PAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAPAPAV10@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * *>
PUBLIC	??$_Checked_base@PAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAPAPAV10@@Z ; std::_Checked_base<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * *>
PUBLIC	??$_Fill_n@PAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IPAV12@@std@@YAXPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@IABQAV10@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * *,unsigned int,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *>
PUBLIC	??$_Fill_n@PAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IPAV12@@std@@YAXPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@IABQAV10@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * *,unsigned int,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *>
PUBLIC	??$unchecked_fill_n@PAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IPAV12@@stdext@@YAXPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IABQAV12@@Z ; stdext::unchecked_fill_n<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * *,unsigned int,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *>
PUBLIC	??$_Uninit_fill_n@PAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IPAV12@V?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAXPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@IABQAV10@AAV?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * *,unsigned int,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *> >
PUBLIC	??$unchecked_uninitialized_fill_n@PAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IPAV12@V?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@stdext@@YAXPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IABQAV12@AAV?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@Z ; stdext::unchecked_uninitialized_fill_n<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * *,unsigned int,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *> >
PUBLIC	??$_Ptr_cat@PAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z ; std::_Ptr_cat<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * *>
PUBLIC	??$_Destroy_range@V?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@YAXPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AAV?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@YAXPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AAV?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *> >
PUBLIC	?_Growmap@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z ; std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Growmap
PUBLIC	?push_back@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z ; std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::push_back
PUBLIC	?push@?$stack@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@@std@@QAEXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z ; std::stack<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::push
PUBLIC	?pop@?$stack@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@@std@@QAEXXZ ; std::stack<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::pop
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~_Container_base_aux_alloc_real<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
PUBLIC	??1?$_Deque_map@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ ; std::_Deque_map<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~_Deque_map<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
PUBLIC	??1?$_Deque_val@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ ; std::_Deque_val<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~_Deque_val<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
PUBLIC	?deallocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::deallocate
PUBLIC	?deallocate@?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *>::deallocate
PUBLIC	??$_Destroy@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAXPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ; std::_Destroy<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *>
PUBLIC	?destroy@?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *>::destroy
PUBLIC	??_G?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEPAXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`scalar deleting destructor'
PUBLIC	??$_Destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ; std::_Destroy<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
PUBLIC	?destroy@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::destroy
PUBLIC	?empty@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBE_NXZ ; std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::empty
PUBLIC	?pop_back@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEXXZ ; std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::pop_back
PUBLIC	?_Tidy@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXXZ ; std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Tidy
PUBLIC	??1?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ ; std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
PUBLIC	??1?$stack@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@@std@@QAE@XZ ; std::stack<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::~stack<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >
PUBLIC	??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@D@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
PUBLIC	?CorSigUncompressData@@YAJPBEKPAK1@Z		; CorSigUncompressData
PUBLIC	?CorSigUncompressData@@YAKPBEPAK@Z		; CorSigUncompressData
PUBLIC	?CorSigUncompressToken@@YAKPBEPAI@Z		; CorSigUncompressToken
PUBLIC	??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
PUBLIC	?deallocate@?$allocator@PA_W@std@@QAEXPAPA_WI@Z	; std::allocator<wchar_t *>::deallocate
PUBLIC	??$_Allocate@PA_W@std@@YAPAPA_WIPAPA_W@Z	; std::_Allocate<wchar_t *>
PUBLIC	?allocate@?$allocator@PA_W@std@@QAEPAPA_WI@Z	; std::allocator<wchar_t *>::allocate
PUBLIC	?max_size@?$deque@_WV?$allocator@_W@std@@@std@@QBEIXZ ; std::deque<wchar_t,std::allocator<wchar_t> >::max_size
PUBLIC	?_Xlen@?$deque@_WV?$allocator@_W@std@@@std@@KAXXZ ; std::deque<wchar_t,std::allocator<wchar_t> >::_Xlen
PUBLIC	??$_Uninit_copy@PAPA_WPAPA_WV?$allocator@PA_W@std@@@std@@YAPAPA_WPAPA_W00AAV?$allocator@PA_W@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<wchar_t * *,wchar_t * *,std::allocator<wchar_t *> >
PUBLIC	??$unchecked_uninitialized_copy@PAPA_WPAPA_WV?$allocator@PA_W@std@@@stdext@@YAPAPA_WPAPA_W00AAV?$allocator@PA_W@std@@@Z ; stdext::unchecked_uninitialized_copy<wchar_t * *,wchar_t * *,std::allocator<wchar_t *> >
PUBLIC	??$_Iter_cat@PAPA_W@std@@YA?AUrandom_access_iterator_tag@0@ABQAPA_W@Z ; std::_Iter_cat<wchar_t * *>
PUBLIC	??$_Checked_base@PAPA_W@std@@YAPAPA_WAAPAPA_WU_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<wchar_t * *>
PUBLIC	??$_Checked_base@PAPA_W@std@@YAPAPA_WAAPAPA_W@Z	; std::_Checked_base<wchar_t * *>
PUBLIC	??$_Fill_n@PAPA_WIPA_W@std@@YAXPAPA_WIABQA_WU_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<wchar_t * *,unsigned int,wchar_t *>
PUBLIC	??$_Fill_n@PAPA_WIPA_W@std@@YAXPAPA_WIABQA_WUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<wchar_t * *,unsigned int,wchar_t *>
PUBLIC	??$unchecked_fill_n@PAPA_WIPA_W@stdext@@YAXPAPA_WIABQA_W@Z ; stdext::unchecked_fill_n<wchar_t * *,unsigned int,wchar_t *>
PUBLIC	??$_Uninit_fill_n@PAPA_WIPA_WV?$allocator@PA_W@std@@@std@@YAXPAPA_WIABQA_WAAV?$allocator@PA_W@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<wchar_t * *,unsigned int,wchar_t *,std::allocator<wchar_t *> >
PUBLIC	??$unchecked_uninitialized_fill_n@PAPA_WIPA_WV?$allocator@PA_W@std@@@stdext@@YAXPAPA_WIABQA_WAAV?$allocator@PA_W@std@@@Z ; stdext::unchecked_uninitialized_fill_n<wchar_t * *,unsigned int,wchar_t *,std::allocator<wchar_t *> >
PUBLIC	??$_Ptr_cat@PAPA_WPAPA_W@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPA_W0@Z ; std::_Ptr_cat<wchar_t * *,wchar_t * *>
PUBLIC	??$_Destroy_range@V?$allocator@PA_W@std@@@std@@YAXPAPA_W0AAV?$allocator@PA_W@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<wchar_t *> >
PUBLIC	??$_Destroy_range@V?$allocator@PA_W@std@@@std@@YAXPAPA_W0AAV?$allocator@PA_W@0@@Z ; std::_Destroy_range<std::allocator<wchar_t *> >
PUBLIC	?_Growmap@?$deque@_WV?$allocator@_W@std@@@std@@IAEXI@Z ; std::deque<wchar_t,std::allocator<wchar_t> >::_Growmap
PUBLIC	?push_back@?$deque@_WV?$allocator@_W@std@@@std@@QAEXAB_W@Z ; std::deque<wchar_t,std::allocator<wchar_t> >::push_back
PUBLIC	?push@?$stack@_WV?$deque@_WV?$allocator@_W@std@@@std@@@std@@QAEXAB_W@Z ; std::stack<wchar_t,std::deque<wchar_t,std::allocator<wchar_t> > >::push
PUBLIC	?empty@?$stack@_WV?$deque@_WV?$allocator@_W@std@@@std@@@std@@QBE_NXZ ; std::stack<wchar_t,std::deque<wchar_t,std::allocator<wchar_t> > >::empty
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@_WHPB_WAB_WV_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base_aux>
PUBLIC	??0?$_Ranit@_WHPB_WAB_W@std@@QAE@XZ		; std::_Ranit<wchar_t,int,wchar_t const *,wchar_t const &>::_Ranit<wchar_t,int,wchar_t const *,wchar_t const &>
PUBLIC	??0?$_Deque_const_iterator@_WV?$allocator@_W@std@@$00@std@@QAE@IPBV_Container_base_aux@1@@Z ; std::_Deque_const_iterator<wchar_t,std::allocator<wchar_t>,1>::_Deque_const_iterator<wchar_t,std::allocator<wchar_t>,1>
PUBLIC	??0?$_Deque_iterator@_WV?$allocator@_W@std@@$00@std@@QAE@IPBV_Container_base_aux@1@@Z ; std::_Deque_iterator<wchar_t,std::allocator<wchar_t>,1>::_Deque_iterator<wchar_t,std::allocator<wchar_t>,1>
PUBLIC	?end@?$deque@_WV?$allocator@_W@std@@@std@@QAE?AV?$_Deque_iterator@_WV?$allocator@_W@std@@$00@2@XZ ; std::deque<wchar_t,std::allocator<wchar_t> >::end
PUBLIC	??D?$_Deque_const_iterator@_WV?$allocator@_W@std@@$00@std@@QBEAB_WXZ ; std::_Deque_const_iterator<wchar_t,std::allocator<wchar_t>,1>::operator*
PUBLIC	??D?$_Deque_iterator@_WV?$allocator@_W@std@@$00@std@@QBEAA_WXZ ; std::_Deque_iterator<wchar_t,std::allocator<wchar_t>,1>::operator*
PUBLIC	??Y?$_Deque_const_iterator@_WV?$allocator@_W@std@@$00@std@@QAEAAV01@H@Z ; std::_Deque_const_iterator<wchar_t,std::allocator<wchar_t>,1>::operator+=
PUBLIC	??Y?$_Deque_iterator@_WV?$allocator@_W@std@@$00@std@@QAEAAV01@H@Z ; std::_Deque_iterator<wchar_t,std::allocator<wchar_t>,1>::operator+=
PUBLIC	??Z?$_Deque_iterator@_WV?$allocator@_W@std@@$00@std@@QAEAAV01@H@Z ; std::_Deque_iterator<wchar_t,std::allocator<wchar_t>,1>::operator-=
PUBLIC	??G?$_Deque_iterator@_WV?$allocator@_W@std@@$00@std@@QBE?AV01@H@Z ; std::_Deque_iterator<wchar_t,std::allocator<wchar_t>,1>::operator-
PUBLIC	?back@?$deque@_WV?$allocator@_W@std@@@std@@QAEAA_WXZ ; std::deque<wchar_t,std::allocator<wchar_t> >::back
PUBLIC	?top@?$stack@_WV?$deque@_WV?$allocator@_W@std@@@std@@@std@@QAEAA_WXZ ; std::stack<wchar_t,std::deque<wchar_t,std::allocator<wchar_t> > >::top
PUBLIC	?empty@?$deque@_WV?$allocator@_W@std@@@std@@QBE_NXZ ; std::deque<wchar_t,std::allocator<wchar_t> >::empty
PUBLIC	?pop_back@?$deque@_WV?$allocator@_W@std@@@std@@QAEXXZ ; std::deque<wchar_t,std::allocator<wchar_t> >::pop_back
PUBLIC	?pop@?$stack@_WV?$deque@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ ; std::stack<wchar_t,std::deque<wchar_t,std::allocator<wchar_t> > >::pop
PUBLIC	?_Register@facet@locale@std@@QAEXXZ		; std::locale::facet::_Register
PUBLIC	??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<wchar_t> >
PUBLIC	??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
PUBLIC	??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
PUBLIC	??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
PUBLIC	??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
PUBLIC	??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
PUBLIC	??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@_W@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
PUBLIC	??_C@_11LOCGONAA@?$AA?$AA@			; `string'
PUBLIC	??_C@_13KJIIAINM@?$AA?$CL?$AA?$AA@		; `string'
PUBLIC	??_C@_19HFFGOOIH@?$AAv?$AAo?$AAi?$AAd?$AA?$AA@	; `string'
PUBLIC	??_C@_13HOIJIPNN@?$AA?5?$AA?$AA@		; `string'
PUBLIC	??_C@_13JOFGPIOO@?$AA?4?$AA?$AA@		; `string'
PUBLIC	??_C@_17CMKEDJDI@?$AAo?$AAu?$AAt?$AA?$AA@	; `string'
PUBLIC	??_C@_17DCNMIAEN@?$AAr?$AAe?$AAf?$AA?$AA@	; `string'
PUBLIC	??_C@_19EIPOAEOH@?$AAb?$AAo?$AAo?$AAl?$AA?$AA@	; `string'
PUBLIC	??_C@_19CHDFCHBM@?$AAc?$AAh?$AAa?$AAr?$AA?$AA@	; `string'
PUBLIC	??_C@_1O@PLMJMAHL@?$AAI?$AAn?$AAt?$AAP?$AAt?$AAr?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BA@HEMJOHJL@?$AAU?$AAI?$AAn?$AAt?$AAP?$AAt?$AAr?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@CNLIHMIE@?$AAs?$AAb?$AAy?$AAt?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_19OGDDIBJJ@?$AAb?$AAy?$AAt?$AAe?$AA?$AA@	; `string'
PUBLIC	??_C@_1M@LOLCAHAG@?$AAs?$AAh?$AAo?$AAr?$AAt?$AA?$AA@ ; `string'
PUBLIC	??_C@_1O@HKBAGFIG@?$AAu?$AAs?$AAh?$AAo?$AAr?$AAt?$AA?$AA@ ; `string'
PUBLIC	??_C@_17IDNKMCOH@?$AAi?$AAn?$AAt?$AA?$AA@	; `string'
PUBLIC	??_C@_19BFBCDLCE@?$AAu?$AAi?$AAn?$AAt?$AA?$AA@	; `string'
PUBLIC	??_C@_19EKGKGAPA@?$AAl?$AAo?$AAn?$AAg?$AA?$AA@	; `string'
PUBLIC	??_C@_1M@GONMDIAN@?$AAu?$AAl?$AAo?$AAn?$AAg?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@KGKAENKF@?$AAf?$AAl?$AAo?$AAa?$AAt?$AA?$AA@ ; `string'
PUBLIC	??_C@_1O@BAJDFEHJ@?$AAd?$AAo?$AAu?$AAb?$AAl?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1O@DGBBOFII@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?$AA@ ; `string'
PUBLIC	??_C@_1O@EJHDPCJ@?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$AA@ ; `string'
PUBLIC	??_C@_13HGPDMIBE@?$AA?$DP?$AA?$AA@		; `string'
PUBLIC	??_C@_19CAKNEAEL@?$AAc?$AAm?$AAo?$AAd?$AA?$AA@	; `string'
PUBLIC	??_C@_1M@HBLOHCOL@?$AAf?$AAn?$AAp?$AAt?$AAr?$AA?$AA@ ; `string'
PUBLIC	??_C@_13BBDEGPLJ@?$AA?$CK?$AA?$AA@		; `string'
PUBLIC	??_C@_13GEEGGHPK@?$AA?$DM?$AA?$AA@		; `string'
PUBLIC	??_C@_13DEFPDAGF@?$AA?0?$AA?$AA@		; `string'
PUBLIC	??_C@_13MOEPKPHB@?$AA?$DO?$AA?$AA@		; `string'
PUBLIC	??_C@_13MGDFOILI@?$AA?$CB?$AA?$AA@		; `string'
PUBLIC	??_C@_02JMMFPCED@?$CC?$CC?$AA@			; `string'
PUBLIC	??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_C@_08EPJLHIJG@bad?5cast?$AA@			; `string'
PUBLIC	??_R0?AVbad_cast@std@@@8			; std::bad_cast `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
PUBLIC	__CTA2?AVbad_cast@std@@
PUBLIC	__TI2?AVbad_cast@std@@
PUBLIC	?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<wchar_t> >::_Psave
EXTRN	??1bad_cast@std@@UAE@XZ:PROC			; std::bad_cast::~bad_cast
EXTRN	??0bad_cast@std@@QAE@ABV01@@Z:PROC		; std::bad_cast::bad_cast
EXTRN	__imp_??0?$basic_ostringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z:PROC
EXTRN	__imp_??_D?$basic_ostringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ:PROC
EXTRN	__imp_??0?$allocator@_W@std@@QAE@XZ:PROC
EXTRN	__imp_??0?$allocator@_W@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z:PROC
EXTRN	__imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z:PROC
EXTRN	__imp_??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z:PROC
EXTRN	__imp_?str@?$basic_ostringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z:PROC
EXTRN	__imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_?str@?$basic_ostringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ:PROC
EXTRN	__imp_??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@H@Z:PROC
EXTRN	__imp_?length@?$char_traits@_W@std@@SAIPB_W@Z:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEHPB_WH@Z:PROC
EXTRN	__imp_?allocate@?$allocator@_W@std@@QAEPA_WI@Z:PROC
EXTRN	__imp_?construct@?$allocator@_W@std@@QAEXPA_WAB_W@Z:PROC
EXTRN	__imp_?max_size@?$allocator@_W@std@@QBEIXZ:PROC
EXTRN	__imp__memmove_s:PROC
EXTRN	__imp_?destroy@?$allocator@_W@std@@QAEXPA_W@Z:PROC
EXTRN	__imp_??1locale@std@@QAE@XZ:PROC
EXTRN	__imp_?widen@?$ctype@_W@std@@QBE_WD@Z:PROC
EXTRN	__imp_?getloc@ios_base@std@@QBE?AVlocale@2@XZ:PROC
EXTRN	__imp_??0_Lockit@std@@QAE@H@Z:PROC
EXTRN	__imp_??1_Lockit@std@@QAE@XZ:PROC
EXTRN	__imp_??0bad_cast@std@@QAE@PBD@Z:PROC
EXTRN	__imp_??Bid@locale@std@@QAEIXZ:PROC
EXTRN	__imp_?_Incref@facet@locale@std@@QAEXXZ:PROC
EXTRN	?facet_Register@facet@locale@std@@CAXPAV123@@Z:PROC ; std::locale::facet::facet_Register
EXTRN	__imp_?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z:PROC
EXTRN	__imp_?id@?$ctype@_W@std@@2V0locale@2@A:DWORD
EXTRN	__imp_?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:PROC
EXTRN	__imp_??1bad_cast@std@@UAE@XZ:PROC
EXTRN	__imp_??0bad_cast@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z:PROC
EXTRN	__imp_?eof@?$char_traits@_W@std@@SAGXZ:PROC
EXTRN	__imp_?flags@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QAEHH@Z:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z:PROC
EXTRN	__imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z:PROC
EXTRN	__imp_?fill@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WXZ:PROC
EXTRN	__imp_?rdstate@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?good@ios_base@std@@QBE_NXZ:PROC
EXTRN	__imp_?tie@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_ostream@_WU?$char_traits@_W@std@@@2@XZ:PROC
EXTRN	__imp_?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ:PROC
EXTRN	__imp_?_Lock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ:PROC
EXTRN	__imp_?uncaught_exception@std@@YA_NXZ:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ:PROC
EXTRN	__imp_?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ:PROC
EXTRN	__imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ:PROC
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::ctype<wchar_t> >::_Psave
;	COMDAT __TI2?AVbad_cast@std@@
xdata$x	SEGMENT
__TI2?AVbad_cast@std@@ DD 00H
	DD	FLAT:??1bad_cast@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_cast@std@@
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_cast@std@@
xdata$x	SEGMENT
__CTA2?AVbad_cast@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_cast@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_cast@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@std@@@8
_DATA	SEGMENT
??_R0?AVbad_cast@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_cast `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_cast@std@@', 00H
_DATA	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT
??_C@_08EPJLHIJG@bad?5cast?$AA@ DB 'bad cast', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@ DB 'deque<T> too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02JMMFPCED@?$CC?$CC?$AA@
CONST	SEGMENT
??_C@_02JMMFPCED@?$CC?$CC?$AA@ DB '""', 00H		; `string'
_mscorlibkey DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	04H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
_systemdrawingkey DB 00H
	DB	024H
	DB	00H
	DB	00H
	DB	04H
	DB	080H
	DB	00H
	DB	00H
	DB	094H
	DB	00H
	DB	00H
	DB	00H
	DB	06H
	DB	02H
	DB	00H
	DB	00H
	DB	00H
	DB	024H
	DB	00H
	DB	00H
	DB	052H
	DB	053H
	DB	041H
	DB	031H
	DB	00H
	DB	04H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	01H
	DB	00H
	DB	07H
	DB	0d1H
	DB	0faH
	DB	057H
	DB	0c4H
	DB	0aeH
	DB	0d9H
	DB	0f0H
	DB	0a3H
	DB	02eH
	DB	084H
	DB	0aaH
	DB	0fH
	DB	0aeH
	DB	0fdH
	DB	0dH
	DB	0e9H
	DB	0e8H
	DB	0fdH
	DB	06aH
	DB	0ecH
	DB	08fH
	DB	087H
	DB	0fbH
	DB	03H
	DB	076H
	DB	06cH
	DB	083H
	DB	04cH
	DB	099H
	DB	092H
	DB	01eH
	DB	0b2H
	DB	03bH
	DB	0e7H
	DB	09aH
	DB	0d9H
	DB	0d5H
	DB	0dcH
	DB	0c1H
	DB	0ddH
	DB	09aH
	DB	0d2H
	DB	036H
	DB	013H
	DB	021H
	DB	02H
	DB	090H
	DB	0bH
	DB	072H
	DB	03cH
	DB	0f9H
	DB	080H
	DB	095H
	DB	07fH
	DB	0c4H
	DB	0e1H
	DB	077H
	DB	010H
	DB	08fH
	DB	0c6H
	DB	07H
	DB	077H
	DB	04fH
	DB	029H
	DB	0e8H
	DB	032H
	DB	0eH
	DB	092H
	DB	0eaH
	DB	05H
	DB	0ecH
	DB	0e4H
	DB	0e8H
	DB	021H
	DB	0c0H
	DB	0a5H
	DB	0efH
	DB	0e8H
	DB	0f1H
	DB	064H
	DB	05cH
	DB	04cH
	DB	0cH
	DB	093H
	DB	0c1H
	DB	0abH
	DB	099H
	DB	028H
	DB	05dH
	DB	062H
	DB	02cH
	DB	0aaH
	DB	065H
	DB	02cH
	DB	01dH
	DB	0faH
	DB	0d6H
	DB	03dH
	DB	074H
	DB	05dH
	DB	06fH
	DB	02dH
	DB	0e5H
	DB	0f1H
	DB	07eH
	DB	05eH
	DB	0afH
	DB	0fH
	DB	0c4H
	DB	096H
	DB	03dH
	DB	026H
	DB	01cH
	DB	08aH
	DB	012H
	DB	043H
	DB	065H
	DB	018H
	DB	020H
	DB	06dH
	DB	0c0H
	DB	093H
	DB	034H
	DB	04dH
	DB	05aH
	DB	0d2H
	DB	093H
_wpfassemblieskey DB 00H
	DB	024H
	DB	00H
	DB	00H
	DB	04H
	DB	080H
	DB	00H
	DB	00H
	DB	094H
	DB	00H
	DB	00H
	DB	00H
	DB	06H
	DB	02H
	DB	00H
	DB	00H
	DB	00H
	DB	024H
	DB	00H
	DB	00H
	DB	052H
	DB	053H
	DB	041H
	DB	031H
	DB	00H
	DB	04H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	01H
	DB	00H
	DB	0b5H
	DB	0fcH
	DB	090H
	DB	0e7H
	DB	02H
	DB	07fH
	DB	067H
	DB	087H
	DB	01eH
	DB	077H
	DB	03aH
	DB	08fH
	DB	0deH
	DB	089H
	DB	038H
	DB	0c8H
	DB	01dH
	DB	0d4H
	DB	02H
	DB	0baH
	DB	065H
	DB	0b9H
	DB	020H
	DB	01dH
	DB	060H
	DB	059H
	DB	03eH
	DB	096H
	DB	0c4H
	DB	092H
	DB	065H
	DB	01eH
	DB	088H
	DB	09cH
	DB	0c1H
	DB	03fH
	DB	014H
	DB	015H
	DB	0ebH
	DB	0b5H
	DB	03fH
	DB	0acH
	DB	011H
	DB	031H
	DB	0aeH
	DB	0bH
	DB	0d3H
	DB	033H
	DB	0c5H
	DB	0eeH
	DB	060H
	DB	021H
	DB	067H
	DB	02dH
	DB	097H
	DB	018H
	DB	0eaH
	DB	031H
	DB	0a8H
	DB	0aeH
	DB	0bdH
	DB	0dH
	DB	0a0H
	DB	07H
	DB	02fH
	DB	025H
	DB	0d8H
	DB	07dH
	DB	0baH
	DB	06fH
	DB	0c9H
	DB	0fH
	DB	0fdH
	DB	059H
	DB	08eH
	DB	0d4H
	DB	0daH
	DB	035H
	DB	0e4H
	DB	04cH
	DB	039H
	DB	08cH
	DB	045H
	DB	043H
	DB	07H
	DB	0e8H
	DB	0e3H
	DB	03bH
	DB	084H
	DB	026H
	DB	014H
	DB	03dH
	DB	0aeH
	DB	0c9H
	DB	0f5H
	DB	096H
	DB	083H
	DB	06fH
	DB	097H
	DB	0c8H
	DB	0f7H
	DB	047H
	DB	050H
	DB	0e5H
	DB	097H
	DB	05cH
	DB	064H
	DB	0e2H
	DB	018H
	DB	09fH
	DB	045H
	DB	0deH
	DB	0f4H
	DB	06bH
	DB	02aH
	DB	02bH
	DB	012H
	DB	047H
	DB	0adH
	DB	0c3H
	DB	065H
	DB	02bH
	DB	0f5H
	DB	0c3H
	DB	08H
	DB	05H
	DB	05dH
	DB	0a9H
;	COMDAT ??_C@_13MGDFOILI@?$AA?$CB?$AA?$AA@
CONST	SEGMENT
??_C@_13MGDFOILI@?$AA?$CB?$AA?$AA@ DB '!', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_13MOEPKPHB@?$AA?$DO?$AA?$AA@
CONST	SEGMENT
??_C@_13MOEPKPHB@?$AA?$DO?$AA?$AA@ DB '>', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_13DEFPDAGF@?$AA?0?$AA?$AA@
CONST	SEGMENT
??_C@_13DEFPDAGF@?$AA?0?$AA?$AA@ DB ',', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_13GEEGGHPK@?$AA?$DM?$AA?$AA@
CONST	SEGMENT
??_C@_13GEEGGHPK@?$AA?$DM?$AA?$AA@ DB '<', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_13BBDEGPLJ@?$AA?$CK?$AA?$AA@
CONST	SEGMENT
??_C@_13BBDEGPLJ@?$AA?$CK?$AA?$AA@ DB '*', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@HBLOHCOL@?$AAf?$AAn?$AAp?$AAt?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1M@HBLOHCOL@?$AAf?$AAn?$AAp?$AAt?$AAr?$AA?$AA@ DB 'f', 00H, 'n', 00H
	DB	'p', 00H, 't', 00H, 'r', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_19CAKNEAEL@?$AAc?$AAm?$AAo?$AAd?$AA?$AA@
CONST	SEGMENT
??_C@_19CAKNEAEL@?$AAc?$AAm?$AAo?$AAd?$AA?$AA@ DB 'c', 00H, 'm', 00H, 'o', 00H
	DB	'd', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_13HGPDMIBE@?$AA?$DP?$AA?$AA@
CONST	SEGMENT
??_C@_13HGPDMIBE@?$AA?$DP?$AA?$AA@ DB '?', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@EJHDPCJ@?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_1O@EJHDPCJ@?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$AA@ DB 'o', 00H, 'b', 00H
	DB	'j', 00H, 'e', 00H, 'c', 00H, 't', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@DGBBOFII@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?$AA@
CONST	SEGMENT
??_C@_1O@DGBBOFII@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?$AA@ DB 's', 00H, 't'
	DB	00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@BAJDFEHJ@?$AAd?$AAo?$AAu?$AAb?$AAl?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1O@BAJDFEHJ@?$AAd?$AAo?$AAu?$AAb?$AAl?$AAe?$AA?$AA@ DB 'd', 00H, 'o'
	DB	00H, 'u', 00H, 'b', 00H, 'l', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@KGKAENKF@?$AAf?$AAl?$AAo?$AAa?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_1M@KGKAENKF@?$AAf?$AAl?$AAo?$AAa?$AAt?$AA?$AA@ DB 'f', 00H, 'l', 00H
	DB	'o', 00H, 'a', 00H, 't', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@GONMDIAN@?$AAu?$AAl?$AAo?$AAn?$AAg?$AA?$AA@
CONST	SEGMENT
??_C@_1M@GONMDIAN@?$AAu?$AAl?$AAo?$AAn?$AAg?$AA?$AA@ DB 'u', 00H, 'l', 00H
	DB	'o', 00H, 'n', 00H, 'g', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_19EKGKGAPA@?$AAl?$AAo?$AAn?$AAg?$AA?$AA@
CONST	SEGMENT
??_C@_19EKGKGAPA@?$AAl?$AAo?$AAn?$AAg?$AA?$AA@ DB 'l', 00H, 'o', 00H, 'n', 00H
	DB	'g', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19BFBCDLCE@?$AAu?$AAi?$AAn?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_19BFBCDLCE@?$AAu?$AAi?$AAn?$AAt?$AA?$AA@ DB 'u', 00H, 'i', 00H, 'n', 00H
	DB	't', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_17IDNKMCOH@?$AAi?$AAn?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_17IDNKMCOH@?$AAi?$AAn?$AAt?$AA?$AA@ DB 'i', 00H, 'n', 00H, 't', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@HKBAGFIG@?$AAu?$AAs?$AAh?$AAo?$AAr?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_1O@HKBAGFIG@?$AAu?$AAs?$AAh?$AAo?$AAr?$AAt?$AA?$AA@ DB 'u', 00H, 's'
	DB	00H, 'h', 00H, 'o', 00H, 'r', 00H, 't', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@LOLCAHAG@?$AAs?$AAh?$AAo?$AAr?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_1M@LOLCAHAG@?$AAs?$AAh?$AAo?$AAr?$AAt?$AA?$AA@ DB 's', 00H, 'h', 00H
	DB	'o', 00H, 'r', 00H, 't', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_19OGDDIBJJ@?$AAb?$AAy?$AAt?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_19OGDDIBJJ@?$AAb?$AAy?$AAt?$AAe?$AA?$AA@ DB 'b', 00H, 'y', 00H, 't', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@CNLIHMIE@?$AAs?$AAb?$AAy?$AAt?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1M@CNLIHMIE@?$AAs?$AAb?$AAy?$AAt?$AAe?$AA?$AA@ DB 's', 00H, 'b', 00H
	DB	'y', 00H, 't', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BA@HEMJOHJL@?$AAU?$AAI?$AAn?$AAt?$AAP?$AAt?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1BA@HEMJOHJL@?$AAU?$AAI?$AAn?$AAt?$AAP?$AAt?$AAr?$AA?$AA@ DB 'U', 00H
	DB	'I', 00H, 'n', 00H, 't', 00H, 'P', 00H, 't', 00H, 'r', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@PLMJMAHL@?$AAI?$AAn?$AAt?$AAP?$AAt?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1O@PLMJMAHL@?$AAI?$AAn?$AAt?$AAP?$AAt?$AAr?$AA?$AA@ DB 'I', 00H, 'n'
	DB	00H, 't', 00H, 'P', 00H, 't', 00H, 'r', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_19CHDFCHBM@?$AAc?$AAh?$AAa?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_19CHDFCHBM@?$AAc?$AAh?$AAa?$AAr?$AA?$AA@ DB 'c', 00H, 'h', 00H, 'a', 00H
	DB	'r', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19EIPOAEOH@?$AAb?$AAo?$AAo?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_19EIPOAEOH@?$AAb?$AAo?$AAo?$AAl?$AA?$AA@ DB 'b', 00H, 'o', 00H, 'o', 00H
	DB	'l', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_17DCNMIAEN@?$AAr?$AAe?$AAf?$AA?$AA@
CONST	SEGMENT
??_C@_17DCNMIAEN@?$AAr?$AAe?$AAf?$AA?$AA@ DB 'r', 00H, 'e', 00H, 'f', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_17CMKEDJDI@?$AAo?$AAu?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_17CMKEDJDI@?$AAo?$AAu?$AAt?$AA?$AA@ DB 'o', 00H, 'u', 00H, 't', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_13JOFGPIOO@?$AA?4?$AA?$AA@
CONST	SEGMENT
??_C@_13JOFGPIOO@?$AA?4?$AA?$AA@ DB '.', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_13HOIJIPNN@?$AA?5?$AA?$AA@
CONST	SEGMENT
??_C@_13HOIJIPNN@?$AA?5?$AA?$AA@ DB ' ', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_19HFFGOOIH@?$AAv?$AAo?$AAi?$AAd?$AA?$AA@
CONST	SEGMENT
??_C@_19HFFGOOIH@?$AAv?$AAo?$AAi?$AAd?$AA?$AA@ DB 'v', 00H, 'o', 00H, 'i', 00H
	DB	'd', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_13KJIIAINM@?$AA?$CL?$AA?$AA@
CONST	SEGMENT
??_C@_13KJIIAINM@?$AA?$CL?$AA?$AA@ DB '+', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_11LOCGONAA@?$AA?$AA@
CONST	SEGMENT
??_C@_11LOCGONAA@?$AA?$AA@ DB 00H, 00H			; `string'
__bad_alloc_Message DD FLAT:??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill_n@PAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IPAV12@@std@@YAXPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@IABQAV10@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Fill_n@PAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IPAV12@@std@@YAXPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@IABQAV10@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * *,unsigned int,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *>, COMDAT
; __Count$ = eax
; __Val$ = edx

; 3196 : 	{	// copy _Val _Count times through [_First, ...)

	mov	ecx, DWORD PTR __First$[esp-4]

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	test	eax, eax
	jbe	SHORT $LN1@Fill_n
	push	esi
	npad	7
$LL3@Fill_n:

; 3198 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL3@Fill_n
	pop	esi
$LN1@Fill_n:

; 3199 : 	}

	ret	0
??$_Fill_n@PAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IPAV12@@std@@YAXPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@IABQAV10@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * *,unsigned int,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PAPA_WIPA_W@std@@YAXPAPA_WIABQA_WU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Fill_n@PAPA_WIPA_W@std@@YAXPAPA_WIABQA_WU_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<wchar_t * *,unsigned int,wchar_t *>, COMDAT
; __Count$ = eax
; __Val$ = edx

; 3196 : 	{	// copy _Val _Count times through [_First, ...)

	mov	ecx, DWORD PTR __First$[esp-4]

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	test	eax, eax
	jbe	SHORT $LN1@Fill_n@2
	push	esi
	npad	7
$LL3@Fill_n@2:

; 3198 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL3@Fill_n@2
	pop	esi
$LN1@Fill_n@2:

; 3199 : 	}

	ret	0
??$_Fill_n@PAPA_WIPA_W@std@@YAXPAPA_WIABQA_WU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<wchar_t * *,unsigned int,wchar_t *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@PAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
_TEXT	SEGMENT
??$_Iter_cat@PAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z PROC ; std::_Iter_cat<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * *>, COMDAT
; ___$ReturnUdt$ = eax

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);
; 955  : 	}

	ret	0
??$_Iter_cat@PAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ENDP ; std::_Iter_cat<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@PAPA_W@std@@YA?AUrandom_access_iterator_tag@0@ABQAPA_W@Z
_TEXT	SEGMENT
??$_Iter_cat@PAPA_W@std@@YA?AUrandom_access_iterator_tag@0@ABQAPA_W@Z PROC ; std::_Iter_cat<wchar_t * *>, COMDAT
; ___$ReturnUdt$ = eax

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);
; 955  : 	}

	ret	0
??$_Iter_cat@PAPA_W@std@@YA?AUrandom_access_iterator_tag@0@ABQAPA_W@Z ENDP ; std::_Iter_cat<wchar_t * *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAPAPAV10@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@PAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAPAPAV10@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * *>, COMDAT
; __It$ = eax

; 1147 : 		return _It;

	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	ret	0
??$_Checked_base@PAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAPAPAV10@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAPA_W@std@@YAPAPA_WAAPAPA_WU_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@PAPA_W@std@@YAPAPA_WAAPAPA_WU_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<wchar_t * *>, COMDAT
; __It$ = eax

; 1147 : 		return _It;

	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	ret	0
??$_Checked_base@PAPA_W@std@@YAPAPA_WAAPAPA_WU_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<wchar_t * *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@YAXPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AAV?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@V?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@YAXPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AAV?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@YAXPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AAV?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAPAV12@V?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAPAV10@00AAV?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Result$ = 12						; size = 4
??$_Uninit_copy@PAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAPAV12@V?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAPAV10@00AAV?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *> >, COMDAT
; __First$ = ecx
; __Count$ = eax

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);
; 149  : 	_FwdIt _Result = _Dest + _Count;
; 150  : 	if (_Count > 0)
; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	edx, DWORD PTR __Dest$[esp-4]
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	edx
	call	DWORD PTR __imp__memmove_s

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[esp+12]
	add	esp, 16					; 00000010H

; 153  : 	}

	ret	0
??$_Uninit_copy@PAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAPAV12@V?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAPAV10@00AAV?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@PAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z PROC ; std::_Ptr_cat<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z ENDP ; std::_Ptr_cat<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAPAPAV10@@Z
_TEXT	SEGMENT
??$_Checked_base@PAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAPAPAV10@@Z PROC ; std::_Checked_base<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * *>, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	eax, DWORD PTR [eax]

; 1166 : 	}

	ret	0
??$_Checked_base@PAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAPAPAV10@@Z ENDP ; std::_Checked_base<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PA_W@std@@@std@@YAXPAPA_W0AAV?$allocator@PA_W@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@V?$allocator@PA_W@std@@@std@@YAXPAPA_W0AAV?$allocator@PA_W@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<wchar_t *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PA_W@std@@@std@@YAXPAPA_W0AAV?$allocator@PA_W@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<wchar_t *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAPA_WPAPA_WV?$allocator@PA_W@std@@@std@@YAPAPA_WPAPA_W00AAV?$allocator@PA_W@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Result$ = 12						; size = 4
??$_Uninit_copy@PAPA_WPAPA_WV?$allocator@PA_W@std@@@std@@YAPAPA_WPAPA_W00AAV?$allocator@PA_W@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<wchar_t * *,wchar_t * *,std::allocator<wchar_t *> >, COMDAT
; __First$ = ecx
; __Count$ = eax

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);
; 149  : 	_FwdIt _Result = _Dest + _Count;
; 150  : 	if (_Count > 0)
; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	edx, DWORD PTR __Dest$[esp-4]
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	edx
	call	DWORD PTR __imp__memmove_s

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[esp+12]
	add	esp, 16					; 00000010H

; 153  : 	}

	ret	0
??$_Uninit_copy@PAPA_WPAPA_WV?$allocator@PA_W@std@@@std@@YAPAPA_WPAPA_W00AAV?$allocator@PA_W@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<wchar_t * *,wchar_t * *,std::allocator<wchar_t *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAPA_WPAPA_W@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPA_W0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@PAPA_WPAPA_W@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPA_W0@Z PROC ; std::_Ptr_cat<wchar_t * *,wchar_t * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPA_WPAPA_W@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPA_W0@Z ENDP ; std::_Ptr_cat<wchar_t * *,wchar_t * *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAPA_W@std@@YAPAPA_WAAPAPA_W@Z
_TEXT	SEGMENT
??$_Checked_base@PAPA_W@std@@YAPAPA_WAAPAPA_W@Z PROC	; std::_Checked_base<wchar_t * *>, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	eax, DWORD PTR [eax]

; 1166 : 	}

	ret	0
??$_Checked_base@PAPA_W@std@@YAPAPA_WAAPAPA_W@Z ENDP	; std::_Checked_base<wchar_t * *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_G?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEPAXI@Z
_TEXT	SEGMENT
??_G?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEPAXI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`scalar deleting destructor', COMDAT
; _this$ = esi
	mov	ecx, esi
	call	DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
	mov	eax, esi
	ret	0
??_G?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEPAXI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z
_TEXT	SEGMENT
??$?0V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?0_W@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
_TEXT	SEGMENT
??$?0_W@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@_W@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><wchar_t>, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0_W@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><wchar_t>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?0V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z
_TEXT	SEGMENT
??$?0V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z PROC ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *>::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *><std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@ABV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z ENDP ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *>::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *><std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?0_W@?$allocator@PA_W@std@@QAE@ABV?$allocator@_W@1@@Z
_TEXT	SEGMENT
??$?0_W@?$allocator@PA_W@std@@QAE@ABV?$allocator@_W@1@@Z PROC ; std::allocator<wchar_t *>::allocator<wchar_t *><wchar_t>, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0_W@?$allocator@PA_W@std@@QAE@ABV?$allocator@_W@1@@Z ENDP ; std::allocator<wchar_t *>::allocator<wchar_t *><wchar_t>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAXPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
_TEXT	SEGMENT
??$_Destroy@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAXPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z PROC ; std::_Destroy<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAXPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ENDP ; std::_Destroy<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
_TEXT	SEGMENT
??$_Destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z PROC ; std::_Destroy<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >, COMDAT
; __Ptr$ = ecx

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);

	jmp	DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
??$_Destroy@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ENDP ; std::_Destroy<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@YAXPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AAV?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@V?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@YAXPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AAV?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@YAXPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0AAV?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAPAV12@V?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@stdext@@YAPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAPAV12@00AAV?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@Z
_TEXT	SEGMENT
??$unchecked_uninitialized_copy@PAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAPAV12@V?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@stdext@@YAPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAPAV12@00AAV?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@Z PROC ; stdext::unchecked_uninitialized_copy<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *> >, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN16@unchecked_
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN16@unchecked_:
	mov	eax, esi
	pop	esi

; 823  : 	}

	ret	0
??$unchecked_uninitialized_copy@PAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAPAV12@V?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@stdext@@YAPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAPAV12@00AAV?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy@PA_W@std@@YAXPAPA_W@Z
_TEXT	SEGMENT
??$_Destroy@PA_W@std@@YAXPAPA_W@Z PROC			; std::_Destroy<wchar_t *>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@PA_W@std@@YAXPAPA_W@Z ENDP			; std::_Destroy<wchar_t *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PA_W@std@@@std@@YAXPAPA_W0AAV?$allocator@PA_W@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@V?$allocator@PA_W@std@@@std@@YAXPAPA_W0AAV?$allocator@PA_W@0@@Z PROC ; std::_Destroy_range<std::allocator<wchar_t *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PA_W@std@@@std@@YAXPAPA_W0AAV?$allocator@PA_W@0@@Z ENDP ; std::_Destroy_range<std::allocator<wchar_t *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAPA_WPAPA_WV?$allocator@PA_W@std@@@stdext@@YAPAPA_WPAPA_W00AAV?$allocator@PA_W@std@@@Z
_TEXT	SEGMENT
??$unchecked_uninitialized_copy@PAPA_WPAPA_WV?$allocator@PA_W@std@@@stdext@@YAPAPA_WPAPA_W00AAV?$allocator@PA_W@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<wchar_t * *,wchar_t * *,std::allocator<wchar_t *> >, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN16@unchecked_@2
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN16@unchecked_@2:
	mov	eax, esi
	pop	esi

; 823  : 	}

	ret	0
??$unchecked_uninitialized_copy@PAPA_WPAPA_WV?$allocator@PA_W@std@@@stdext@@YAPAPA_WPAPA_W00AAV?$allocator@PA_W@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<wchar_t * *,wchar_t * *,std::allocator<wchar_t *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QBEIXZ PROC ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::max_size, COMDAT

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 153391689				; 09249249H

; 167  : 		}

	ret	0
?max_size@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >, COMDAT
; _this$ = eax

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	0
??0?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ?max_size@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ PROC ; std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::max_size, COMDAT

; 729  : 		return (this->_Alval.max_size());

	mov	eax, 153391689				; 09249249H

; 730  : 		}

	ret	0
?max_size@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBEIXZ ENDP ; std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$deque@_WV?$allocator@_W@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$deque@_WV?$allocator@_W@std@@@std@@QBEIXZ PROC ; std::deque<wchar_t,std::allocator<wchar_t> >::max_size, COMDAT

; 729  : 		return (this->_Alval.max_size());

	mov	eax, 2147483647				; 7fffffffH

; 730  : 		}

	ret	0
?max_size@?$deque@_WV?$allocator@_W@std@@@std@@QBEIXZ ENDP ; std::deque<wchar_t,std::allocator<wchar_t> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\ostream
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = eax

; 82   : 			if (_Myostr.rdbuf() != 0)

	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax+40]
	test	eax, eax
	je	SHORT $LN1@Sentry_bas

; 83   : 				_Myostr.rdbuf()->_Unlock();

	mov	ecx, eax
	jmp	DWORD PTR __imp_?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ
$LN1@Sentry_bas:

; 84   : 			}

	ret	0
??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = esi
; __Ostr$ = eax

; 75   : 			{	// lock the stream buffer, if there

	mov	DWORD PTR [esi], eax

; 76   : 			if (_Myostr.rdbuf() != 0)

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax+40]
	test	eax, eax
	je	SHORT $LN8@Sentry_bas@2

; 77   : 				_Myostr.rdbuf()->_Lock();

	mov	ecx, eax
	call	DWORD PTR __imp_?_Lock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ
$LN8@Sentry_bas@2:

; 78   : 			}

	mov	eax, esi
	ret	0
??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z
_TEXT	SEGMENT
?destroy@?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z PROC ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *>::destroy, COMDAT

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	0
?destroy@?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z ENDP ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *>::destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z
_TEXT	SEGMENT
?deallocate@?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z PROC ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *>::deallocate, COMDAT
; __Ptr$ = eax

; 140  : 		::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	0
?deallocate@?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z ENDP ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *>::deallocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z
_TEXT	SEGMENT
?destroy@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z PROC ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::destroy, COMDAT
; __Ptr$ = ecx

; 160  : 		_Destroy(_Ptr);

	jmp	DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
?destroy@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z ENDP ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z
_TEXT	SEGMENT
?deallocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z PROC ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::deallocate, COMDAT
; __Ptr$ = eax

; 140  : 		::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	0
?deallocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z ENDP ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::deallocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@XZ PROC ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >, COMDAT
; _this$ = eax

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PA_W@std@@QAEXPAPA_W@Z
_TEXT	SEGMENT
?destroy@?$allocator@PA_W@std@@QAEXPAPA_W@Z PROC	; std::allocator<wchar_t *>::destroy, COMDAT

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	0
?destroy@?$allocator@PA_W@std@@QAEXPAPA_W@Z ENDP	; std::allocator<wchar_t *>::destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PA_W@std@@QAEXPAPA_WI@Z
_TEXT	SEGMENT
?deallocate@?$allocator@PA_W@std@@QAEXPAPA_WI@Z PROC	; std::allocator<wchar_t *>::deallocate, COMDAT
; __Ptr$ = eax

; 140  : 		::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	0
?deallocate@?$allocator@PA_W@std@@QAEXPAPA_WI@Z ENDP	; std::allocator<wchar_t *>::deallocate
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\ostream
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool, COMDAT
; _this$ = eax

; 116  : 			return (_Ok);

	mov	al, BYTE PTR [eax+4]

; 117  : 			}

	ret	0
??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
_TEXT	ENDS
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\ios
xdata$x	SEGMENT
__unwindtable$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\ostream
xdata$x	ENDS
;	COMDAT ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry, COMDAT

; 102  : 			{	// destroy the object

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, DWORD PTR _this$[esp+12]
	mov	DWORD PTR __$EHRec$[esp+24], 0

; 103  : 
; 104  :  #if _HAS_EXCEPTIONS
; 105  : 			if (!_XSTD uncaught_exception())

	call	DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
	test	al, al
	jne	SHORT $LN1@sentry

; 106  : 				this->_Myostr._Osfx();

	mov	ecx, DWORD PTR [esi]
	call	DWORD PTR __imp_?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
$LN1@sentry:

; 107  : 			}

	mov	DWORD PTR __$EHRec$[esp+24], -1
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax+40]
	test	eax, eax
	je	SHORT $LN5@sentry
	mov	ecx, eax
	call	DWORD PTR __imp_?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ
$LN5@sentry:
	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
__ehhandler$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xiosbase
xdata$x	SEGMENT
__unwindtable$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z$0
__ehfuncinfo$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\ostream
xdata$x	ENDS
;	COMDAT ??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry, COMDAT
; __Ostr$ = esi

; 95   : 			{	// construct locking and testing stream

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	edi
	mov	edi, DWORD PTR _this$[esp+12]
	mov	DWORD PTR [edi], esi
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [ecx+esi+40]
	test	ecx, ecx
	je	SHORT $LN5@sentry@2
	call	DWORD PTR __imp_?_Lock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ
$LN5@sentry@2:
	mov	DWORD PTR __$EHRec$[esp+24], 0

; 96   : 			if (_Ostr.good() && _Ostr.tie() != 0)

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+4]
	add	eax, esi
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN1@sentry@2
	mov	eax, DWORD PTR [eax+44]
	test	eax, eax
	je	SHORT $LN1@sentry@2

; 97   : 				_Ostr.tie()->flush();

	mov	ecx, eax
	call	DWORD PTR __imp_?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ
$LN1@sentry@2:

; 98   : 			_Ok = _Ostr.good();	// store test only after flushing tie

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+esi+8], 0

; 99   : 			}

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	sete	al
	mov	BYTE PTR [edi+4], al
	mov	eax, edi
	mov	DWORD PTR fs:0, ecx
	pop	edi
	add	esp, 12					; 0000000cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\deque
;	COMDAT ?empty@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBE_NXZ PROC ; std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::empty, COMDAT
; _this$ = ecx

; 734  : 		return (_Mysize == 0);

	xor	eax, eax
	cmp	DWORD PTR [ecx+28], eax
	sete	al

; 735  : 		}

	ret	0
?empty@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QBE_NXZ ENDP ; std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::empty
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?empty@?$deque@_WV?$allocator@_W@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$deque@_WV?$allocator@_W@std@@@std@@QBE_NXZ PROC ; std::deque<wchar_t,std::allocator<wchar_t> >::empty, COMDAT
; _this$ = ecx

; 734  : 		return (_Mysize == 0);

	xor	eax, eax
	cmp	DWORD PTR [ecx+28], eax
	sete	al

; 735  : 		}

	ret	0
?empty@?$deque@_WV?$allocator@_W@std@@@std@@QBE_NXZ ENDP ; std::deque<wchar_t,std::allocator<wchar_t> >::empty
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\stack
_TEXT	ENDS
;	COMDAT ?empty@?$stack@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$stack@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@@std@@QBE_NXZ PROC ; std::stack<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::empty, COMDAT
; _this$ = ecx

; 38   : 		return (c.empty());

	xor	eax, eax
	cmp	DWORD PTR [ecx+28], eax
	sete	al

; 39   : 		}

	ret	0
?empty@?$stack@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@@std@@QBE_NXZ ENDP ; std::stack<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::empty
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?empty@?$stack@_WV?$deque@_WV?$allocator@_W@std@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$stack@_WV?$deque@_WV?$allocator@_W@std@@@std@@@std@@QBE_NXZ PROC ; std::stack<wchar_t,std::deque<wchar_t,std::allocator<wchar_t> > >::empty, COMDAT
; _this$ = ecx

; 38   : 		return (c.empty());

	xor	eax, eax
	cmp	DWORD PTR [ecx+28], eax
	sete	al

; 39   : 		}

	ret	0
?empty@?$stack@_WV?$deque@_WV?$allocator@_W@std@@@std@@@std@@QBE_NXZ ENDP ; std::stack<wchar_t,std::deque<wchar_t,std::allocator<wchar_t> > >::empty
_TEXT	ENDS
PUBLIC	?IsNetInternal@SignatureReader@@QAE_NI@Z	; SignatureReader::IsNetInternal
; Function compile flags: /Ogtpy
; File c:\local\sharpdevelop_3.2.0.5777_source\src\addins\misc\profiler\hook\profilermetadata.cpp
;	COMDAT ?IsNetInternal@SignatureReader@@QAE_NI@Z
_TEXT	SEGMENT
_asmMetaData$ = -2072					; size = 4
_publicKey$ = -2068					; size = 4
_pKLength$ = -2064					; size = 4
_assembly$132927 = -2060				; size = 4
_funcToken$ = -2056					; size = 4
_assemblyNameLength$132931 = -2052			; size = 4
_assemblyName$132930 = -2048				; size = 2048
_fid$ = 8						; size = 4
?IsNetInternal@SignatureReader@@QAE_NI@Z PROC		; SignatureReader::IsNetInternal, COMDAT
; _this$ = eax

; 565  : 	mdToken funcToken;
; 566  : 	HRESULT hr = S_OK;
; 567  : 	IMetaDataAssemblyImport *asmMetaData;
; 568  : 	const void *publicKey;
; 569  : 	ULONG pKLength;
; 570  : 
; 571  : 	hr = profilerInfo->GetTokenAndMetaDataFromFunction(fid, IID_IMetaDataAssemblyImport, (LPUNKNOWN *) &asmMetaData, &funcToken);

	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax]
	sub	esp, 2072				; 00000818H
	push	esi
	push	edi
	lea	edx, DWORD PTR _funcToken$[esp+2080]
	push	edx
	lea	edx, DWORD PTR _asmMetaData$[esp+2084]
	push	edx
	mov	edx, DWORD PTR _fid$[esp+2084]
	push	OFFSET _IID_IMetaDataAssemblyImport
	push	edx
	push	eax
	mov	eax, DWORD PTR [ecx+76]
	call	eax

; 572  : 	if (SUCCEEDED(hr)) {

	test	eax, eax
	jl	$LN1@IsNetInter

; 573  : 		mdAssembly assembly;
; 574  : 		hr = asmMetaData->GetAssemblyFromScope(&assembly);

	mov	eax, DWORD PTR _asmMetaData$[esp+2080]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR _assembly$132927[esp+2080]
	push	edx
	push	eax
	mov	eax, DWORD PTR [ecx+48]
	call	eax

; 575  : 		if (SUCCEEDED(hr)) {

	test	eax, eax
	jl	$LN1@IsNetInter

; 576  : 			WCHAR assemblyName[NAME_BUFFER_SIZE];
; 577  : 			ULONG assemblyNameLength;
; 578  : 
; 579  : 			hr = asmMetaData->GetAssemblyProps(assembly, &publicKey, &pKLength, nullptr, assemblyName, NAME_BUFFER_SIZE, &assemblyNameLength, nullptr, nullptr);

	mov	eax, DWORD PTR _asmMetaData$[esp+2080]
	mov	ecx, DWORD PTR [eax]
	push	0
	push	0
	lea	edx, DWORD PTR _assemblyNameLength$132931[esp+2088]
	push	edx
	push	1024					; 00000400H
	lea	edx, DWORD PTR _assemblyName$132930[esp+2096]
	push	edx
	push	0
	lea	edx, DWORD PTR _pKLength$[esp+2104]
	push	edx
	lea	edx, DWORD PTR _publicKey$[esp+2108]
	push	edx
	mov	edx, DWORD PTR _assembly$132927[esp+2112]
	push	edx
	push	eax
	mov	eax, DWORD PTR [ecx+12]
	call	eax

; 580  : 			const byte *b = (const byte *)publicKey;
; 581  : 			
; 582  : 			if (pKLength == sizeof(mscorlibkey) && memcmp(mscorlibkey, b, sizeof(mscorlibkey)) == 0)

	mov	eax, DWORD PTR _pKLength$[esp+2080]
	cmp	eax, 16					; 00000010H
	jne	SHORT $LN3@IsNetInter
	mov	ecx, eax
	mov	eax, DWORD PTR _publicKey$[esp+2080]
	mov	edx, OFFSET _mscorlibkey
	sub	edx, eax
$LL9@IsNetInter:
	mov	esi, DWORD PTR [edx+eax]
	cmp	esi, DWORD PTR [eax]
	jne	$LN1@IsNetInter
	sub	ecx, 4
	add	eax, 4
	cmp	ecx, 4
	jae	SHORT $LL9@IsNetInter
	pop	edi

; 583  : 				return true;

	mov	al, 1
	pop	esi

; 592  : }

	add	esp, 2072				; 00000818H
	ret	4
$LN3@IsNetInter:

; 584  : 			if (pKLength == sizeof(systemdrawingkey) && memcmp(systemdrawingkey, b, sizeof(systemdrawingkey)) == 0)

	cmp	eax, 160				; 000000a0H
	jne	SHORT $LN1@IsNetInter
	mov	edx, eax
	mov	eax, DWORD PTR _publicKey$[esp+2080]
	mov	esi, OFFSET _systemdrawingkey
	mov	ecx, eax
	sub	esi, eax
	npad	7
$LL13@IsNetInter:
	mov	edi, DWORD PTR [esi+ecx]
	cmp	edi, DWORD PTR [ecx]
	jne	SHORT $LN32@IsNetInter
	sub	edx, 4
	add	ecx, 4
	cmp	edx, 4
	jae	SHORT $LL13@IsNetInter
	pop	edi

; 585  : 				return true;

	mov	al, 1
	pop	esi

; 592  : }

	add	esp, 2072				; 00000818H
	ret	4
$LN32@IsNetInter:

; 586  : 			if (pKLength == sizeof(wpfassemblieskey) && memcmp(wpfassemblieskey, b, sizeof(wpfassemblieskey)) == 0)

	mov	edx, OFFSET _wpfassemblieskey
	mov	ecx, 160				; 000000a0H
	sub	edx, eax
	npad	5
$LL17@IsNetInter:
	mov	esi, DWORD PTR [edx+eax]
	cmp	esi, DWORD PTR [eax]
	jne	SHORT $LN1@IsNetInter
	sub	ecx, 4
	add	eax, 4
	cmp	ecx, 4
	jae	SHORT $LL17@IsNetInter
	pop	edi

; 587  : 				return true;

	mov	al, 1
	pop	esi

; 592  : }

	add	esp, 2072				; 00000818H
	ret	4
$LN1@IsNetInter:
	pop	edi

; 588  : 		}
; 589  : 	}
; 590  : 	
; 591  : 	return false;

	xor	al, al
	pop	esi

; 592  : }

	add	esp, 2072				; 00000818H
	ret	4
?IsNetInternal@SignatureReader@@QAE_NI@Z ENDP		; SignatureReader::IsNetInternal
_TEXT	ENDS
PUBLIC	?ReadByte@SignatureReader@@AAE_NPAE@Z		; SignatureReader::ReadByte
; Function compile flags: /Ogtpy
;	COMDAT ?ReadByte@SignatureReader@@AAE_NPAE@Z
_TEXT	SEGMENT
?ReadByte@SignatureReader@@AAE_NPAE@Z PROC		; SignatureReader::ReadByte, COMDAT
; _this$ = eax
; _out$ = edx

; 486  : 	if (this->data < this->endPosition) {

	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR [eax+20]
	jae	SHORT $LN1@ReadByte

; 487  : 		*out = *this->data;

	mov	cl, BYTE PTR [ecx]
	mov	BYTE PTR [edx], cl

; 488  : 		this->data++;

	inc	DWORD PTR [eax+12]

; 489  : 		return true;

	mov	al, 1

; 493  : }

	ret	0
$LN1@ReadByte:

; 490  : 	}
; 491  : 
; 492  : 	return false;

	xor	al, al

; 493  : }

	ret	0
?ReadByte@SignatureReader@@AAE_NPAE@Z ENDP		; SignatureReader::ReadByte
; Function compile flags: /Ogtpy
; File c:\program files\microsoft sdks\windows\v7.0\include\cor.h
_TEXT	ENDS
;	COMDAT ?CorSigUncompressData@@YAJPBEKPAK1@Z
_TEXT	SEGMENT
_pDataOut$ = 8						; size = 4
?CorSigUncompressData@@YAJPBEKPAK1@Z PROC		; CorSigUncompressData, COMDAT
; _pData$ = edx
; _pDataLen$ = edi

; 2293 :     HRESULT hr = S_OK;        
; 2294 :     BYTE const  *pBytes = reinterpret_cast<BYTE const*>(pData); 
; 2295 : 
; 2296 :     // Smallest.    
; 2297 :     if ((*pBytes & 0x80) == 0x00)       // 0??? ????    

	mov	cl, BYTE PTR [edx]
	push	ebp
	mov	ebp, DWORD PTR _pDataOut$[esp]
	push	esi
	xor	esi, esi
	test	cl, cl
	js	SHORT $LN12@CorSigUnco

; 2298 :     {   
; 2299 :         if (len < 1)
; 2300 :         {
; 2301 :             *pDataOut = NULL;
; 2302 :             *pDataLen = 0;
; 2303 :             hr = META_E_BAD_SIGNATURE;
; 2304 :         }
; 2305 :         else
; 2306 :         {
; 2307 :             *pDataOut = *pBytes;    

	movzx	eax, cl
	mov	DWORD PTR [ebp], eax

; 2345 :     }
; 2346 :     
; 2347 :     return hr;  

	mov	eax, esi
	pop	esi
	mov	DWORD PTR [edi], 1
	pop	ebp

; 2348 : 
; 2349 : }

	ret	0
$LN12@CorSigUnco:

; 2308 :             *pDataLen = 1; 
; 2309 :         }
; 2310 :     }    
; 2311 :     // Medium.  
; 2312 :     else if ((*pBytes & 0xC0) == 0x80)  // 10?? ????    

	mov	al, cl
	and	al, 192					; 000000c0H
	cmp	al, 128					; 00000080H
	jne	SHORT $LN8@CorSigUnco

; 2313 :     {   
; 2314 :         if (len < 2)
; 2315 :         {
; 2316 :             *pDataOut = NULL;
; 2317 :             *pDataLen = 0;
; 2318 :             hr = META_E_BAD_SIGNATURE;
; 2319 :         }
; 2320 :         else
; 2321 :         {
; 2322 :             *pDataOut = (ULONG)(((*pBytes & 0x3f) << 8 | *(pBytes+1)));    

	movzx	edx, BYTE PTR [edx+1]
	movzx	ecx, cl
	and	ecx, 63					; 0000003fH
	shl	ecx, 8
	or	ecx, edx

; 2345 :     }
; 2346 :     
; 2347 :     return hr;  

	mov	eax, esi
	pop	esi
	mov	DWORD PTR [ebp], ecx
	mov	DWORD PTR [edi], 2
	pop	ebp

; 2348 : 
; 2349 : }

	ret	0
$LN8@CorSigUnco:

; 2323 :             *pDataLen = 2; 
; 2324 :         }
; 2325 :     }   
; 2326 :     else if ((*pBytes & 0xE0) == 0xC0)      // 110? ????    

	mov	al, cl
	and	al, 224					; 000000e0H
	cmp	al, 192					; 000000c0H
	jne	SHORT $LN4@CorSigUnco

; 2327 :     {   
; 2328 :         if (len < 4)
; 2329 :         {
; 2330 :             *pDataOut = NULL;
; 2331 :             *pDataLen = 0;
; 2332 :             hr = META_E_BAD_SIGNATURE;
; 2333 :         }
; 2334 :         else
; 2335 :         {
; 2336 :             *pDataOut = (ULONG)(((*pBytes & 0x1f) << 24 | *(pBytes+1) << 16 | *(pBytes+2) << 8 | *(pBytes+3)));  

	movzx	eax, BYTE PTR [edx+1]
	movzx	ecx, cl
	and	ecx, 31					; 0000001fH
	shl	ecx, 8
	or	ecx, eax
	movzx	eax, BYTE PTR [edx+2]
	movzx	edx, BYTE PTR [edx+3]
	shl	ecx, 8
	or	ecx, eax
	shl	ecx, 8
	or	ecx, edx

; 2345 :     }
; 2346 :     
; 2347 :     return hr;  

	mov	eax, esi
	pop	esi
	mov	DWORD PTR [ebp], ecx
	mov	DWORD PTR [edi], 4
	pop	ebp

; 2348 : 
; 2349 : }

	ret	0
$LN4@CorSigUnco:

; 2337 :             *pDataLen = 4; 
; 2338 :         }
; 2339 :     }   
; 2340 :     else // We don't recognize this encoding
; 2341 :     {
; 2342 :         *pDataOut = NULL;

	mov	DWORD PTR [ebp], esi

; 2343 :         *pDataLen = 0;

	mov	DWORD PTR [edi], esi
	pop	esi

; 2344 :         hr = META_E_BAD_SIGNATURE;

	mov	eax, -2146233966			; 80131192H
	pop	ebp

; 2348 : 
; 2349 : }

	ret	0
?CorSigUncompressData@@YAJPBEKPAK1@Z ENDP		; CorSigUncompressData
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xlocale
_TEXT	ENDS
;	COMDAT ?_Register@facet@locale@std@@QAEXXZ
_TEXT	SEGMENT
?_Register@facet@locale@std@@QAEXXZ PROC		; std::locale::facet::_Register, COMDAT
; _this$ = eax

; 135  : #if defined(_M_CEE)
; 136  : 			facet_Register_m(this);
; 137  : #else
; 138  : 			facet_Register(this);

	push	eax
	call	?facet_Register@facet@locale@std@@CAXPAV123@@Z ; std::locale::facet::facet_Register
	pop	ecx

; 139  : #endif
; 140  : 			}

	ret	0
?_Register@facet@locale@std@@QAEXXZ ENDP		; std::locale::facet::_Register
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill_n@PAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IPAV12@@std@@YAXPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@IABQAV10@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Fill_n@PAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IPAV12@@std@@YAXPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@IABQAV10@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * *,unsigned int,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *>, COMDAT
; __Count$ = eax
; __Val$ = edx

; 3251 : 		// if _OutIt is checked, this will ensure we have enough space
; 3252 : 		_OutIt _Last = _First + _Count; (_Last);
; 3253 : 		_Fill_n(_CHECKED_BASE(_First), _Count, _Val,
; 3254 : 			_Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN7@Fill_n@3
	push	esi
	npad	7
$LL9@Fill_n@3:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL9@Fill_n@3
	pop	esi
$LN7@Fill_n@3:

; 3255 : 	}

	ret	0
??$_Fill_n@PAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IPAV12@@std@@YAXPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@IABQAV10@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * *,unsigned int,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PAPA_WIPA_W@std@@YAXPAPA_WIABQA_WUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Fill_n@PAPA_WIPA_W@std@@YAXPAPA_WIABQA_WUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<wchar_t * *,unsigned int,wchar_t *>, COMDAT
; __Count$ = eax
; __Val$ = edx

; 3251 : 		// if _OutIt is checked, this will ensure we have enough space
; 3252 : 		_OutIt _Last = _First + _Count; (_Last);
; 3253 : 		_Fill_n(_CHECKED_BASE(_First), _Count, _Val,
; 3254 : 			_Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN7@Fill_n@4
	push	esi
	npad	7
$LL9@Fill_n@4:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL9@Fill_n@4
	pop	esi
$LN7@Fill_n@4:

; 3255 : 	}

	ret	0
??$_Fill_n@PAPA_WIPA_W@std@@YAXPAPA_WIABQA_WUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<wchar_t * *,unsigned int,wchar_t *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_fill_n@PAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IPAV12@@stdext@@YAXPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IABQAV12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
??$unchecked_fill_n@PAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IPAV12@@stdext@@YAXPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IABQAV12@@Z PROC ; stdext::unchecked_fill_n<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * *,unsigned int,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *>, COMDAT
; __Count$ = eax
; __Val$ = edx

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN11@unchecked_@3
	push	esi
	npad	7
$LL13@unchecked_@3:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL13@unchecked_@3
	pop	esi
$LN11@unchecked_@3:

; 3722 : 	}

	ret	0
??$unchecked_fill_n@PAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IPAV12@@stdext@@YAXPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IABQAV12@@Z ENDP ; stdext::unchecked_fill_n<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * *,unsigned int,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_fill_n@PAPA_WIPA_W@stdext@@YAXPAPA_WIABQA_W@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
??$unchecked_fill_n@PAPA_WIPA_W@stdext@@YAXPAPA_WIABQA_W@Z PROC ; stdext::unchecked_fill_n<wchar_t * *,unsigned int,wchar_t *>, COMDAT
; __Count$ = eax
; __Val$ = edx

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN11@unchecked_@4
	push	esi
	npad	7
$LL13@unchecked_@4:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL13@unchecked_@4
	pop	esi
$LN11@unchecked_@4:

; 3722 : 	}

	ret	0
??$unchecked_fill_n@PAPA_WIPA_W@stdext@@YAXPAPA_WIABQA_W@Z ENDP ; stdext::unchecked_fill_n<wchar_t * *,unsigned int,wchar_t *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IPAV12@V?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAXPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@IABQAV10@AAV?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Uninit_fill_n@PAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IPAV12@V?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAXPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@IABQAV10@AAV?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * *,unsigned int,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *> >, COMDAT
; __Count$ = eax
; __Val$ = edx

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN13@Uninit_fil
	push	esi
	npad	7
$LL15@Uninit_fil:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL15@Uninit_fil
	pop	esi
$LN13@Uninit_fil:

; 420  : 	}

	ret	0
??$_Uninit_fill_n@PAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IPAV12@V?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAXPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@IABQAV10@AAV?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * *,unsigned int,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAPA_WIPA_WV?$allocator@PA_W@std@@@std@@YAXPAPA_WIABQA_WAAV?$allocator@PA_W@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Uninit_fill_n@PAPA_WIPA_WV?$allocator@PA_W@std@@@std@@YAXPAPA_WIABQA_WAAV?$allocator@PA_W@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<wchar_t * *,unsigned int,wchar_t *,std::allocator<wchar_t *> >, COMDAT
; __Count$ = eax
; __Val$ = edx

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN13@Uninit_fil@2
	push	esi
	npad	7
$LL15@Uninit_fil@2:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL15@Uninit_fil@2
	pop	esi
$LN13@Uninit_fil@2:

; 420  : 	}

	ret	0
??$_Uninit_fill_n@PAPA_WIPA_WV?$allocator@PA_W@std@@@std@@YAXPAPA_WIABQA_WAAV?$allocator@PA_W@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<wchar_t * *,unsigned int,wchar_t *,std::allocator<wchar_t *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@IPAPAV10@@Z
_TEXT	SEGMENT
$T150417 = -16						; size = 4
$T150409 = -12						; size = 12
??$_Allocate@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@IPAPAV10@@Z PROC ; std::_Allocate<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *>, COMDAT
; __Count$ = ecx

; 37   : 	if (_Count <= 0)
; 38   : 		_Count = 0;
; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	sub	esp, 16					; 00000010H
	cmp	eax, 4
	jae	SHORT $LN1@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T150417[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T150409[esp+20]
	mov	DWORD PTR $T150417[esp+20], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T150409[esp+20]
	push	ecx
	mov	DWORD PTR $T150409[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@Allocate:
$LN1@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 16					; 00000010H
	ret	0
$LN12@Allocate:
??$_Allocate@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@IPAPAV10@@Z ENDP ; std::_Allocate<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Allocate@PA_W@std@@YAPAPA_WIPAPA_W@Z
_TEXT	SEGMENT
$T150431 = -16						; size = 4
$T150423 = -12						; size = 12
??$_Allocate@PA_W@std@@YAPAPA_WIPAPA_W@Z PROC		; std::_Allocate<wchar_t *>, COMDAT
; __Count$ = ecx

; 37   : 	if (_Count <= 0)
; 38   : 		_Count = 0;
; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	sub	esp, 16					; 00000010H
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T150431[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T150423[esp+20]
	mov	DWORD PTR $T150431[esp+20], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T150423[esp+20]
	push	ecx
	mov	DWORD PTR $T150423[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@Allocate@2:
$LN1@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 16					; 00000010H
	ret	0
$LN12@Allocate@2:
??$_Allocate@PA_W@std@@YAPAPA_WIPAPA_W@Z ENDP		; std::_Allocate<wchar_t *>
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\new
xdata$x	SEGMENT
__unwindtable$??$_Construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@@Z$0
__ehfuncinfo$??$_Construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Val$ = 8						; size = 4
??$_Construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@@Z PROC ; std::_Construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >, COMDAT
; __Ptr$ = ecx

; 50   : 	{	// construct object at _Ptr with value _Val

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??$_Construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@@Z
	push	eax
	mov	DWORD PTR fs:0, esp

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	DWORD PTR __$EHRec$[esp+20], 0
	test	ecx, ecx
	je	SHORT $LN3@Construct
	mov	eax, DWORD PTR __Val$[esp+8]
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
$LN3@Construct:

; 53   : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+12]
	mov	DWORD PTR fs:0, ecx
	add	esp, 12					; 0000000cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@@Z$0:
	jmp	??3@YAXPAX0@Z				; operator delete
__ehhandler$??$_Construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Construct@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@@Z ENDP ; std::_Construct<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@IPAV10@@Z
_TEXT	SEGMENT
$T150462 = -16						; size = 4
$T150454 = -12						; size = 12
??$_Allocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@IPAV10@@Z PROC ; std::_Allocate<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >, COMDAT
; __Count$ = ecx

; 37   : 	if (_Count <= 0)
; 38   : 		_Count = 0;
; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	sub	esp, 16					; 00000010H
	cmp	eax, 28					; 0000001cH
	jae	SHORT $LN1@Allocate@3

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T150462[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T150454[esp+20]
	mov	DWORD PTR $T150462[esp+20], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T150454[esp+20]
	push	ecx
	mov	DWORD PTR $T150454[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@Allocate@3:
$LN1@Allocate@3:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	add	edx, edx
	add	edx, edx
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 16					; 00000010H
	ret	0
$LN12@Allocate@3:
??$_Allocate@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@IPAV10@@Z ENDP ; std::_Allocate<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_fill_n@PAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IPAV12@V?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@stdext@@YAXPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IABQAV12@AAV?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
??$unchecked_uninitialized_fill_n@PAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IPAV12@V?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@stdext@@YAXPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IABQAV12@AAV?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@Z PROC ; stdext::unchecked_uninitialized_fill_n<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * *,unsigned int,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *> >, COMDAT
; __Count$ = eax
; __Val$ = edx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN17@unchecked_@5
	push	esi
	npad	7
$LL19@unchecked_@5:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL19@unchecked_@5
	pop	esi
$LN17@unchecked_@5:

; 943  : 	}

	ret	0
??$unchecked_uninitialized_fill_n@PAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IPAV12@V?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@stdext@@YAXPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IABQAV12@AAV?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * *,unsigned int,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_fill_n@PAPA_WIPA_WV?$allocator@PA_W@std@@@stdext@@YAXPAPA_WIABQA_WAAV?$allocator@PA_W@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
??$unchecked_uninitialized_fill_n@PAPA_WIPA_WV?$allocator@PA_W@std@@@stdext@@YAXPAPA_WIABQA_WAAV?$allocator@PA_W@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<wchar_t * *,unsigned int,wchar_t *,std::allocator<wchar_t *> >, COMDAT
; __Count$ = eax
; __Val$ = edx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN17@unchecked_@6
	push	esi
	npad	7
$LL19@unchecked_@6:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL19@unchecked_@6
	pop	esi
$LN17@unchecked_@6:

; 943  : 	}

	ret	0
??$unchecked_uninitialized_fill_n@PAPA_WIPA_WV?$allocator@PA_W@std@@@stdext@@YAXPAPA_WIABQA_WAAV?$allocator@PA_W@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<wchar_t * *,unsigned int,wchar_t *,std::allocator<wchar_t *> >
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\ios
xdata$x	SEGMENT
__unwindtable$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@_W@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@_W@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@_W@Z$3
__catchsym$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@_W@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@_W@Z$0
__tryblocktable$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@_W@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@_W@Z$4
__ehfuncinfo$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@_W@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@_W@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@_W@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\ostream
xdata$x	ENDS
;	COMDAT ??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@_W@Z
_TEXT	SEGMENT
__Ok$ = -28						; size = 8
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Ch$ = 12						; size = 2
??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@_W@Z PROC ; std::operator<<<wchar_t,std::char_traits<wchar_t> >, COMDAT

; 873  : 	{	// insert a character

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@_W@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	mov	esi, DWORD PTR __Ostr$[ebp]
	push	edi

; 874  : 	typedef basic_ostream<_Elem, _Traits> _Myos;
; 875  : 	ios_base::iostate _State = ios_base::goodbit;
; 876  : 	const typename _Myos::sentry _Ok(_Ostr);

	lea	eax, DWORD PTR __Ok$[ebp]
	mov	DWORD PTR __$EHRec$[ebp], esp
	xor	edi, edi
	push	eax
	xor	ebx, ebx
	mov	DWORD PTR __State$[ebp], edi
	call	??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
	mov	DWORD PTR __$EHRec$[ebp+12], ebx

; 877  : 
; 878  : 	if (_Ok)

	cmp	BYTE PTR __Ok$[ebp+4], 0
	je	$LN20@operator

; 879  : 		{	// state okay, insert
; 880  : 		streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+esi+24]
	cmp	eax, 1
	lea	ecx, DWORD PTR [edx+esi]
	jle	SHORT $LN16@operator
	lea	ebx, DWORD PTR [eax-1]
$LN16@operator:

; 881  : 
; 882  : 		_TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 883  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

	mov	eax, DWORD PTR [ecx+16]
	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	SHORT $LN69@operator
$LL9@operator:

; 884  : 			for (; _State == ios_base::goodbit && 0 < _Pad;
; 885  : 				--_Pad)	// pad on left

	test	edi, edi
	jne	$LN2@operator
	test	ebx, ebx
	jle	SHORT $LN69@operator

; 886  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 887  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	movzx	edx, WORD PTR [ecx+esi+48]
	lea	eax, DWORD PTR [ecx+esi]
	mov	eax, DWORD PTR [eax+40]
	push	edx
	mov	ecx, eax
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z
	movzx	eax, ax
	mov	edx, 65535				; 0000ffffH
	cmp	dx, ax
	jne	SHORT $LN8@operator

; 888  : 					_State |= ios_base::badbit;

	mov	edi, 4
	mov	DWORD PTR __State$[ebp], edi
$LN8@operator:

; 884  : 			for (; _State == ios_base::goodbit && 0 < _Pad;
; 885  : 				--_Pad)	// pad on left

	dec	ebx
	jmp	SHORT $LL9@operator
$LN69@operator:

; 889  : 
; 890  : 		if (_State == ios_base::goodbit
; 891  : 			&& _Traits::eq_int_type(_Traits::eof(),
; 892  : 				_Ostr.rdbuf()->sputc(_Ch)))

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Ch$[ebp]
	mov	ecx, DWORD PTR [ecx+esi+40]
	push	edx
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z
	movzx	eax, ax
	mov	ecx, 65535				; 0000ffffH
	cmp	cx, ax
	jne	SHORT $LL70@operator

; 893  : 			_State |= ios_base::badbit;

	mov	edi, 4
	mov	DWORD PTR __State$[ebp], edi
	npad	5
$LL70@operator:

; 894  : 
; 895  : 		for (; _State == ios_base::goodbit && 0 < _Pad;
; 896  : 			--_Pad)	// pad on right

	test	edi, edi
	jne	SHORT $LN2@operator
	test	ebx, ebx
	jle	SHORT $LN2@operator

; 897  : 			if (_Traits::eq_int_type(_Traits::eof(),
; 898  : 				_Ostr.rdbuf()->sputc(_Ostr.fill())))

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+4]
	movzx	edx, WORD PTR [eax+esi+48]
	add	eax, esi
	mov	eax, DWORD PTR [eax+40]
	push	edx
	mov	ecx, eax
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z
	movzx	eax, ax
	mov	ecx, 65535				; 0000ffffH
	cmp	cx, ax
	jne	SHORT $LN3@operator

; 899  : 				_State |= ios_base::badbit;

	mov	edi, 4
	mov	DWORD PTR __State$[ebp], edi
$LN3@operator:

; 894  : 
; 895  : 		for (; _State == ios_base::goodbit && 0 < _Pad;
; 896  : 			--_Pad)	// pad on right

	dec	ebx
	jmp	SHORT $LL70@operator
__catch$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@_W@Z$0:

; 900  : 		_CATCH_IO_(_Ostr)

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+4]
	push	1
	push	4
	add	ecx, eax
	call	DWORD PTR __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN21@operator
	ret	0
$LN21@operator:
	mov	esi, DWORD PTR __Ostr$[ebp]
	mov	edi, DWORD PTR __State$[ebp]
	jmp	SHORT $LN20@operator
$LN2@operator:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN20@operator:

; 901  : 		}
; 902  : 
; 903  : 	_Ostr.width(0);

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	add	eax, esi
	mov	DWORD PTR [eax+24], 0

; 904  : 	_Ostr.setstate(_State);

	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	push	0
	push	edi
	add	ecx, esi
	call	DWORD PTR __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z

; 905  : 	return (_Ostr);

	mov	DWORD PTR __$EHRec$[ebp+12], 3
	call	DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
	test	al, al
	jne	SHORT $LN54@operator
	mov	ecx, DWORD PTR __Ok$[ebp]
	call	DWORD PTR __imp_?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
$LN54@operator:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR __Ok$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ecx+eax+40]
	test	ecx, ecx
	je	SHORT $LN72@operator
	call	DWORD PTR __imp_?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ
$LN72@operator:

; 906  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@_W@Z$2:
	lea	eax, DWORD PTR __Ok$[ebp]
	push	eax
	call	??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
	ret	0
__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@_W@Z$3:
	lea	eax, DWORD PTR __Ok$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
__ehhandler$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@_W@Z:
	mov	eax, OFFSET __ehfuncinfo$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@_W@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@_W@Z ENDP ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\ios
xdata$x	SEGMENT
__unwindtable$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z$3
__catchsym$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z$0
__tryblocktable$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z$4
__ehfuncinfo$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\ostream
xdata$x	ENDS
;	COMDAT ??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z
_TEXT	SEGMENT
__Ok$ = -28						; size = 8
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z PROC ; std::operator<<<wchar_t,std::char_traits<wchar_t> >, COMDAT

; 827  : 	{	// insert NTCS

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H

; 828  : 	typedef basic_ostream<_Elem, _Traits> _Myos;
; 829  : 	ios_base::iostate _State = ios_base::goodbit;
; 830  : 	streamsize _Count = (streamsize)_Traits::length(_Val);	// may overflow

	mov	eax, DWORD PTR __Val$[ebp]
	push	ebx
	push	esi
	mov	esi, DWORD PTR __Ostr$[ebp]
	push	edi
	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __State$[ebp], ebx
	lea	edx, DWORD PTR [eax+2]
	npad	1
$LL72@operator@2:
	mov	cx, WORD PTR [eax]
	add	eax, 2
	cmp	cx, bx
	jne	SHORT $LL72@operator@2
	sub	eax, edx
	sar	eax, 1
	mov	edi, eax

; 831  : 	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
; 832  : 		? 0 : _Ostr.width() - _Count;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+esi+24]
	cmp	eax, ebx
	jle	SHORT $LN17@operator@2
	cmp	eax, edi
	jle	SHORT $LN17@operator@2
	sub	eax, edi
	mov	ebx, eax
$LN17@operator@2:

; 833  : 	const typename _Myos::sentry _Ok(_Ostr);

	lea	edx, DWORD PTR __Ok$[ebp]
	push	edx
	call	??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 834  : 
; 835  : 	if (!_Ok)

	cmp	BYTE PTR __Ok$[ebp+4], 0
	jne	SHORT $LN14@operator@2

; 836  : 		_State |= ios_base::badbit;

	mov	DWORD PTR __State$[ebp], 4

; 837  : 	else

	jmp	$LN22@operator@2
$LN14@operator@2:

; 838  : 		{	// state okay, insert
; 839  : 		_TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 840  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+esi+16]
	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	SHORT $LN70@operator@2
	npad	1
$LL10@operator@2:

; 841  : 			for (; 0 < _Pad; --_Pad)	// pad on left

	test	ebx, ebx
	jle	SHORT $LN8@operator@2

; 842  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 843  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+4]
	movzx	edx, WORD PTR [eax+esi+48]
	add	eax, esi
	mov	eax, DWORD PTR [eax+40]
	push	edx
	mov	ecx, eax
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z
	movzx	eax, ax
	mov	ecx, 65535				; 0000ffffH
	cmp	cx, ax
	jne	$LN9@operator@2

; 844  : 					{	// insertion failed, quit
; 845  : 					_State |= ios_base::badbit;

	or	DWORD PTR __State$[ebp], 4
$LN8@operator@2:

; 846  : 					break;
; 847  : 					}
; 848  : 
; 849  : 		if (_State == ios_base::goodbit
; 850  : 			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)

	cmp	DWORD PTR __State$[ebp], 0
	jne	SHORT $LN2@operator@2
$LN70@operator@2:
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax+esi+40]
	push	edi
	push	edx
	call	DWORD PTR __imp_?sputn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEHPB_WH@Z
	cmp	eax, edi
	je	SHORT $LL71@operator@2

; 851  : 			_State |= ios_base::badbit;

	mov	DWORD PTR __State$[ebp], 4
$LN2@operator@2:

; 860  : 					}
; 861  : 		_Ostr.width(0);

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+4]
	add	eax, esi
	xor	ecx, ecx
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR __$EHRec$[ebp+12], ecx
$LN22@operator@2:

; 863  : 		}
; 864  : 
; 865  : 	_Ostr.setstate(_State);

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR __State$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	push	0
	push	eax
	add	ecx, esi
	call	DWORD PTR __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z

; 866  : 	return (_Ostr);

	mov	DWORD PTR __$EHRec$[ebp+12], 3
	call	DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
	test	al, al
	jne	SHORT $LN56@operator@2
	mov	ecx, DWORD PTR __Ok$[ebp]
	call	DWORD PTR __imp_?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
$LN56@operator@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR __Ok$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ecx+eax+40]
	test	ecx, ecx
	je	SHORT $LN74@operator@2
	call	DWORD PTR __imp_?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ
$LN74@operator@2:

; 867  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@operator@2:

; 841  : 			for (; 0 < _Pad; --_Pad)	// pad on left

	dec	ebx
	jmp	$LL10@operator@2
$LL71@operator@2:

; 852  : 
; 853  : 		if (_State == ios_base::goodbit)
; 854  : 			for (; 0 < _Pad; --_Pad)	// pad on right

	test	ebx, ebx
	jle	SHORT $LN2@operator@2

; 855  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 856  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	movzx	edx, WORD PTR [ecx+esi+48]
	lea	eax, DWORD PTR [ecx+esi]
	mov	eax, DWORD PTR [eax+40]
	push	edx
	mov	ecx, eax
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z
	movzx	eax, ax
	mov	edx, 65535				; 0000ffffH
	cmp	dx, ax
	jne	SHORT $LN3@operator@2

; 857  : 					{	// insertion failed, quit
; 858  : 					_State |= ios_base::badbit;

	or	DWORD PTR __State$[ebp], 4

; 859  : 					break;

	jmp	$LN2@operator@2
$LN3@operator@2:

; 852  : 
; 853  : 		if (_State == ios_base::goodbit)
; 854  : 			for (; 0 < _Pad; --_Pad)	// pad on right

	dec	ebx
	jmp	SHORT $LL71@operator@2
__catch$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z$0:

; 862  : 		_CATCH_IO_(_Ostr)

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+4]
	push	1
	push	4
	add	ecx, eax
	call	DWORD PTR __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN23@operator@2
	ret	0
$LN23@operator@2:
	mov	esi, DWORD PTR __Ostr$[ebp]
	jmp	$LN22@operator@2
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z$2:
	lea	eax, DWORD PTR __Ok$[ebp]
	push	eax
	call	??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
	ret	0
__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z$3:
	lea	eax, DWORD PTR __Ok$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
__ehhandler$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z:
	mov	eax, OFFSET __ehfuncinfo$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z ENDP ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xlocale
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z$0
__ehfuncinfo$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT
__Psave$137106 = -32					; size = 4
__Lock$137105 = -28					; size = 4
$T150916 = -24						; size = 12
__$EHRec$ = -12						; size = 12
??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z PROC ; std::use_facet<std::ctype<wchar_t> >, COMDAT
; __Loc$ = ecx

; 486  : {	// get facet reference from locale

	push	-1
	push	__ehhandler$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	esi
	push	edi
	mov	edi, ecx

; 487  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

	push	0
	lea	ecx, DWORD PTR __Lock$137105[esp+44]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
	mov	DWORD PTR __$EHRec$[esp+48], 0

; 488  : 		const locale::facet *_Psave =
; 489  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet

	mov	eax, DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<wchar_t> >::_Psave

; 490  : 
; 491  : 		size_t _Id = _Facet::id;

	mov	ecx, DWORD PTR __imp_?id@?$ctype@_W@std@@2V0locale@2@A
	mov	DWORD PTR __Psave$137106[esp+40], eax
	call	DWORD PTR __imp_??Bid@locale@std@@QAEIXZ

; 492  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);

	push	eax
	mov	ecx, edi
	call	DWORD PTR __imp_?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z
	mov	esi, eax

; 493  : 
; 494  : 		if (_Pf != 0)

	test	esi, esi
	jne	SHORT $LN14@use_facet

; 495  : 			;	// got facet from locale
; 496  : 		else if (_Psave != 0)

	mov	esi, DWORD PTR __Psave$137106[esp+40]
	test	esi, esi

; 497  : 			_Pf = _Psave;	// lazy facet already allocated

	jne	SHORT $LN14@use_facet

; 498  : 		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

	lea	ecx, DWORD PTR __Psave$137106[esp+40]
	push	edi
	push	ecx
	call	DWORD PTR __imp_?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	add	esp, 8
	cmp	eax, -1
	jne	SHORT $LN2@use_facet

; 499  : 
; 500  :  #if _HAS_EXCEPTIONS
; 501  : 		_THROW_NCEE(bad_cast, _EMPTY_ARGUMENT);	// lazy disallowed

	push	OFFSET ??_C@_08EPJLHIJG@bad?5cast?$AA@
	lea	ecx, DWORD PTR $T150916[esp+44]
	call	DWORD PTR __imp_??0bad_cast@std@@QAE@PBD@Z
	push	OFFSET __TI2?AVbad_cast@std@@
	lea	edx, DWORD PTR $T150916[esp+44]
	push	edx
	call	__CxxThrowException@8
$LN18@use_facet:
$LN2@use_facet:

; 502  : 
; 503  : 	#else /* _HAS_EXCEPTIONS */
; 504  : 			abort();	// lazy disallowed
; 505  : 	#endif /* _HAS_EXCEPTIONS */
; 506  : 
; 507  : 		else
; 508  : 			{	// queue up lazy facet for destruction
; 509  : 			_Pf = _Psave;

	mov	ecx, DWORD PTR __Psave$137106[esp+40]
	mov	esi, ecx

; 510  : 			_Facetptr<_Facet>::_Psave = _Psave;

	mov	DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B, ecx ; std::_Facetptr<std::ctype<wchar_t> >::_Psave

; 511  : 
; 512  : 			locale::facet *_Pfmod = (_Facet *)_Psave;

	mov	edi, ecx

; 513  : 			_Pfmod->_Incref();

	call	DWORD PTR __imp_?_Incref@facet@locale@std@@QAEXXZ

; 514  : 			_Pfmod->_Register();

	push	edi
	call	?facet_Register@facet@locale@std@@CAXPAV123@@Z ; std::locale::facet::facet_Register
	add	esp, 4
$LN14@use_facet:

; 515  : 			}
; 516  : 
; 517  : 		return ((const _Facet&)(*_Pf));	// should be dynamic_cast

	lea	ecx, DWORD PTR __Lock$137105[esp+40]
	mov	DWORD PTR __$EHRec$[esp+48], -1
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ

; 518  : 	_END_LOCK()
; 519  : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 32					; 00000020H
	ret	0
$LN17@use_facet:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z$0:
	lea	ecx, DWORD PTR __Lock$137105[ebp]
	jmp	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
__ehhandler$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::ctype<wchar_t> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@HPBV32@ABV32@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@HPBV32@ABV32@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,int,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,int,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const &,std::_Iterator_base_aux>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@HPBV32@ABV32@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,int,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,int,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const &,std::_Iterator_base_aux>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@_WHPB_WAB_WV_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@_WHPB_WAB_WV_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base_aux>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@_WHPB_WAB_WV_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base_aux>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Ranit@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HPBV12@ABV12@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Ranit@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HPBV12@ABV12@@std@@QAE@XZ PROC ; std::_Ranit<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,int,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const &>::_Ranit<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,int,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const &>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Ranit@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HPBV12@ABV12@@std@@QAE@XZ ENDP ; std::_Ranit<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,int,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const &>::_Ranit<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,int,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const &>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Ranit@_WHPB_WAB_W@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Ranit@_WHPB_WAB_W@std@@QAE@XZ PROC		; std::_Ranit<wchar_t,int,wchar_t const *,wchar_t const &>::_Ranit<wchar_t,int,wchar_t const *,wchar_t const &>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Ranit@_WHPB_WAB_W@std@@QAE@XZ ENDP		; std::_Ranit<wchar_t,int,wchar_t const *,wchar_t const &>::_Ranit<wchar_t,int,wchar_t const *,wchar_t const &>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ??0?$_Deque_const_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@$00@std@@QAE@IPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??0?$_Deque_const_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@$00@std@@QAE@IPBV_Container_base_aux@1@@Z PROC ; std::_Deque_const_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,1>::_Deque_const_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,1>, COMDAT
; _this$ = edi
; __Pdeque$ = esi

; 125  : 		_Deque_const_iterator(size_type _Off, const _Mydequebase *_Pdeque)

	push	ebx
	mov	ebx, DWORD PTR __Off$[esp]
	mov	DWORD PTR [edi], 0

; 126  : 			{	// construct with offset _Off in *_Pdeque
; 127  : 			_SCL_SECURE_TRAITS_VALIDATE(
; 128  : 				_Pdeque != NULL &&
; 129  : 				((_Mydeque *)_Pdeque)->_Myoff <= _Off && _Off <= (((_Mydeque *)_Pdeque)->_Myoff + ((_Mydeque *)_Pdeque)->_Mysize));

	test	esi, esi
	je	SHORT $LN4@Deque_cons
	mov	eax, DWORD PTR [esi+24]
	cmp	eax, ebx
	ja	SHORT $LN4@Deque_cons
	mov	ecx, DWORD PTR [esi+28]
	add	ecx, eax
	cmp	ebx, ecx
	jbe	SHORT $LN3@Deque_cons
$LN4@Deque_cons:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@Deque_cons:

; 130  : 				
; 131  : 			this->_Set_container(_Pdeque);

	mov	edx, DWORD PTR [esi]

; 132  : 			_Myoff = _Off;

	mov	DWORD PTR [edi+4], ebx
	mov	DWORD PTR [edi], edx

; 133  : 			}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Deque_const_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@$00@std@@QAE@IPBV_Container_base_aux@1@@Z ENDP ; std::_Deque_const_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,1>::_Deque_const_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,1>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Deque_const_iterator@_WV?$allocator@_W@std@@$00@std@@QAE@IPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??0?$_Deque_const_iterator@_WV?$allocator@_W@std@@$00@std@@QAE@IPBV_Container_base_aux@1@@Z PROC ; std::_Deque_const_iterator<wchar_t,std::allocator<wchar_t>,1>::_Deque_const_iterator<wchar_t,std::allocator<wchar_t>,1>, COMDAT
; _this$ = edi
; __Pdeque$ = esi

; 125  : 		_Deque_const_iterator(size_type _Off, const _Mydequebase *_Pdeque)

	push	ebx
	mov	ebx, DWORD PTR __Off$[esp]
	mov	DWORD PTR [edi], 0

; 126  : 			{	// construct with offset _Off in *_Pdeque
; 127  : 			_SCL_SECURE_TRAITS_VALIDATE(
; 128  : 				_Pdeque != NULL &&
; 129  : 				((_Mydeque *)_Pdeque)->_Myoff <= _Off && _Off <= (((_Mydeque *)_Pdeque)->_Myoff + ((_Mydeque *)_Pdeque)->_Mysize));

	test	esi, esi
	je	SHORT $LN4@Deque_cons@2
	mov	eax, DWORD PTR [esi+24]
	cmp	eax, ebx
	ja	SHORT $LN4@Deque_cons@2
	mov	ecx, DWORD PTR [esi+28]
	add	ecx, eax
	cmp	ebx, ecx
	jbe	SHORT $LN3@Deque_cons@2
$LN4@Deque_cons@2:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@Deque_cons@2:

; 130  : 				
; 131  : 			this->_Set_container(_Pdeque);

	mov	edx, DWORD PTR [esi]

; 132  : 			_Myoff = _Off;

	mov	DWORD PTR [edi+4], ebx
	mov	DWORD PTR [edi], edx

; 133  : 			}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Deque_const_iterator@_WV?$allocator@_W@std@@$00@std@@QAE@IPBV_Container_base_aux@1@@Z ENDP ; std::_Deque_const_iterator<wchar_t,std::allocator<wchar_t>,1>::_Deque_const_iterator<wchar_t,std::allocator<wchar_t>,1>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Deque_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@$00@std@@QAE@IPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??0?$_Deque_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@$00@std@@QAE@IPBV_Container_base_aux@1@@Z PROC ; std::_Deque_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,1>::_Deque_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,1>, COMDAT
; _this$ = edi
; __Pdeque$ = esi

; 381  : 		{	// construct with offset _Off in *_Pdeque

	push	ebx
	mov	ebx, DWORD PTR __Off$[esp]
	mov	DWORD PTR [edi], 0
	test	esi, esi
	je	SHORT $LN6@Deque_iter
	mov	eax, DWORD PTR [esi+24]
	cmp	eax, ebx
	ja	SHORT $LN6@Deque_iter
	mov	ecx, DWORD PTR [esi+28]
	add	ecx, eax
	cmp	ebx, ecx
	jbe	SHORT $LN5@Deque_iter
$LN6@Deque_iter:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN5@Deque_iter:
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [edi+4], ebx
	mov	DWORD PTR [edi], edx

; 382  : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Deque_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@$00@std@@QAE@IPBV_Container_base_aux@1@@Z ENDP ; std::_Deque_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,1>::_Deque_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,1>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Deque_iterator@_WV?$allocator@_W@std@@$00@std@@QAE@IPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??0?$_Deque_iterator@_WV?$allocator@_W@std@@$00@std@@QAE@IPBV_Container_base_aux@1@@Z PROC ; std::_Deque_iterator<wchar_t,std::allocator<wchar_t>,1>::_Deque_iterator<wchar_t,std::allocator<wchar_t>,1>, COMDAT
; _this$ = edi
; __Pdeque$ = esi

; 381  : 		{	// construct with offset _Off in *_Pdeque

	push	ebx
	mov	ebx, DWORD PTR __Off$[esp]
	mov	DWORD PTR [edi], 0
	test	esi, esi
	je	SHORT $LN6@Deque_iter@2
	mov	eax, DWORD PTR [esi+24]
	cmp	eax, ebx
	ja	SHORT $LN6@Deque_iter@2
	mov	ecx, DWORD PTR [esi+28]
	add	ecx, eax
	cmp	ebx, ecx
	jbe	SHORT $LN5@Deque_iter@2
$LN6@Deque_iter@2:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN5@Deque_iter@2:
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [edi+4], ebx
	mov	DWORD PTR [edi], edx

; 382  : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Deque_iterator@_WV?$allocator@_W@std@@$00@std@@QAE@IPBV_Container_base_aux@1@@Z ENDP ; std::_Deque_iterator<wchar_t,std::allocator<wchar_t>,1>::_Deque_iterator<wchar_t,std::allocator<wchar_t>,1>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z
_TEXT	SEGMENT
$T151092 = -16						; size = 4
$T151094 = -12						; size = 12
?allocate@?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z PROC ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *>::allocate, COMDAT
; __Count$ = ecx

; 144  : 		{	// allocate array of _Count elements

	sub	esp, 16					; 00000010H

; 145  : 		return (_Allocate(_Count, (pointer)0));

	test	ecx, ecx
	ja	SHORT $LN5@allocate
	xor	ecx, ecx
$LN3@allocate:
	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 146  : 		}

	add	esp, 16					; 00000010H
	ret	0

; 145  : 		return (_Allocate(_Count, (pointer)0));

$LN5@allocate:
	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN3@allocate
	lea	eax, DWORD PTR $T151092[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T151094[esp+20]
	mov	DWORD PTR $T151092[esp+20], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T151094[esp+20]
	push	ecx
	mov	DWORD PTR $T151094[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN12@allocate:
$LN11@allocate:
	int	3
?allocate@?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z ENDP ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *>::allocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@PA_W@std@@QAEPAPA_WI@Z
_TEXT	SEGMENT
$T151114 = -16						; size = 4
$T151116 = -12						; size = 12
?allocate@?$allocator@PA_W@std@@QAEPAPA_WI@Z PROC	; std::allocator<wchar_t *>::allocate, COMDAT
; __Count$ = ecx

; 144  : 		{	// allocate array of _Count elements

	sub	esp, 16					; 00000010H

; 145  : 		return (_Allocate(_Count, (pointer)0));

	test	ecx, ecx
	ja	SHORT $LN5@allocate@2
	xor	ecx, ecx
$LN3@allocate@2:
	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 146  : 		}

	add	esp, 16					; 00000010H
	ret	0

; 145  : 		return (_Allocate(_Count, (pointer)0));

$LN5@allocate@2:
	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN3@allocate@2
	lea	eax, DWORD PTR $T151114[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T151116[esp+20]
	mov	DWORD PTR $T151114[esp+20], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T151116[esp+20]
	push	ecx
	mov	DWORD PTR $T151116[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN12@allocate@2:
$LN11@allocate@2:
	int	3
?allocate@?$allocator@PA_W@std@@QAEPAPA_WI@Z ENDP	; std::allocator<wchar_t *>::allocate
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\new
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@ABV32@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@ABV32@@Z$0
__ehfuncinfo$?construct@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@ABV32@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@ABV32@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@ABV32@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Val$ = 8						; size = 4
?construct@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@ABV32@@Z PROC ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::construct, COMDAT
; __Ptr$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?construct@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@ABV32@@Z
	push	eax
	mov	DWORD PTR fs:0, esp

; 155  : 		_Construct(_Ptr, _Val);

	mov	DWORD PTR __$EHRec$[esp+20], 0
	test	ecx, ecx
	je	SHORT $LN5@construct
	mov	eax, DWORD PTR __Val$[esp+8]
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
$LN5@construct:

; 156  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+12]
	mov	DWORD PTR fs:0, ecx
	add	esp, 12					; 0000000cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@ABV32@@Z$0:
	jmp	??3@YAXPAX0@Z				; operator delete
__ehhandler$?construct@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@ABV32@@Z:
	mov	eax, OFFSET __ehfuncinfo$?construct@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@ABV32@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@ABV32@@Z ENDP ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::construct
; Function compile flags: /Ogtpy
;	COMDAT ?allocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z
_TEXT	SEGMENT
?allocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z PROC ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::allocate, COMDAT

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	28					; 0000001cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 146  : 		}

	ret	0
?allocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z ENDP ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::allocate
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ?end@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE?AV?$_Deque_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@$00@2@XZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?end@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE?AV?$_Deque_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@$00@2@XZ PROC ; std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::end, COMDAT
; ___$ReturnUdt$ = edi

; 675  : 		{	// return iterator for end of mutable sequence

	push	ebx
	mov	ebx, DWORD PTR _this$[esp]

; 676  : 		return (iterator(_Myoff + _Mysize, this));

	mov	eax, DWORD PTR [ebx+24]
	push	esi
	mov	esi, DWORD PTR [ebx+28]
	add	esi, eax
	mov	DWORD PTR [edi], 0
	cmp	eax, esi
	jbe	SHORT $LN7@end
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN7@end:
	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [edi+4], esi
	pop	esi
	mov	DWORD PTR [edi], eax
	mov	eax, edi
	pop	ebx

; 677  : 		}

	ret	4
?end@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE?AV?$_Deque_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@$00@2@XZ ENDP ; std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$deque@_WV?$allocator@_W@std@@@std@@QAE?AV?$_Deque_iterator@_WV?$allocator@_W@std@@$00@2@XZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?end@?$deque@_WV?$allocator@_W@std@@@std@@QAE?AV?$_Deque_iterator@_WV?$allocator@_W@std@@$00@2@XZ PROC ; std::deque<wchar_t,std::allocator<wchar_t> >::end, COMDAT
; ___$ReturnUdt$ = edi

; 675  : 		{	// return iterator for end of mutable sequence

	push	ebx
	mov	ebx, DWORD PTR _this$[esp]

; 676  : 		return (iterator(_Myoff + _Mysize, this));

	mov	eax, DWORD PTR [ebx+24]
	push	esi
	mov	esi, DWORD PTR [ebx+28]
	add	esi, eax
	mov	DWORD PTR [edi], 0
	cmp	eax, esi
	jbe	SHORT $LN7@end@2
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN7@end@2:
	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [edi+4], esi
	pop	esi
	mov	DWORD PTR [edi], eax
	mov	eax, edi
	pop	ebx

; 677  : 		}

	ret	4
?end@?$deque@_WV?$allocator@_W@std@@@std@@QAE?AV?$_Deque_iterator@_WV?$allocator@_W@std@@$00@2@XZ ENDP ; std::deque<wchar_t,std::allocator<wchar_t> >::end
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_real@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~_Container_base_aux_alloc_real<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >, COMDAT
; _this$ = eax

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 440  : 		}

	ret	0
??1?$_Container_base_aux_alloc_real@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~_Container_base_aux_alloc_real<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ?pop_back@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEXXZ PROC ; std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::pop_back, COMDAT
; _this$ = esi

; 864  : 
; 865  :  #if _HAS_ITERATOR_DEBUGGING
; 866  : 		if (empty())
; 867  : 			_DEBUG_ERROR("deque empty before pop");
; 868  : 		else
; 869  : 			{	// something to erase, do it
; 870  : 			_Orphan_off(_Myoff + _Mysize - 1);
; 871  : 
; 872  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 873  : 		if (!empty())

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	je	SHORT $LN1@pop_back

; 874  : 			{	// something to erase, do it
; 875  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 876  : 
; 877  : 			size_type _Newoff = _Mysize + _Myoff - 1;
; 878  : 			size_type _Block = _Newoff / _DEQUESIZ;

	mov	ecx, DWORD PTR [esi+24]
	lea	eax, DWORD PTR [eax+ecx-1]

; 879  : 			if (_Mapsize <= _Block)

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, eax
	ja	SHORT $LN2@pop_back

; 880  : 				_Block -= _Mapsize;

	sub	eax, ecx
$LN2@pop_back:

; 881  : 			this->_Alval.destroy(_Map[_Block] + _Newoff % _DEQUESIZ);

	mov	edx, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [edx+eax*4]
	call	DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ

; 882  : 			if (--_Mysize == 0)

	add	DWORD PTR [esi+28], -1
	jne	SHORT $LN1@pop_back

; 883  : 				_Myoff = 0;

	mov	DWORD PTR [esi+24], 0
$LN1@pop_back:

; 884  : 			}
; 885  : 			}

	ret	0
?pop_back@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEXXZ ENDP ; std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::pop_back
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@_W@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_real@V?$allocator@_W@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<wchar_t> >::~_Container_base_aux_alloc_real<std::allocator<wchar_t> >, COMDAT
; _this$ = eax

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 440  : 		}

	ret	0
??1?$_Container_base_aux_alloc_real@V?$allocator@_W@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<wchar_t> >::~_Container_base_aux_alloc_real<std::allocator<wchar_t> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ?pop_back@?$deque@_WV?$allocator@_W@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$deque@_WV?$allocator@_W@std@@@std@@QAEXXZ PROC ; std::deque<wchar_t,std::allocator<wchar_t> >::pop_back, COMDAT
; _this$ = esi

; 864  : 
; 865  :  #if _HAS_ITERATOR_DEBUGGING
; 866  : 		if (empty())
; 867  : 			_DEBUG_ERROR("deque empty before pop");
; 868  : 		else
; 869  : 			{	// something to erase, do it
; 870  : 			_Orphan_off(_Myoff + _Mysize - 1);
; 871  : 
; 872  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 873  : 		if (!empty())

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	je	SHORT $LN1@pop_back@2

; 874  : 			{	// something to erase, do it
; 875  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 876  : 
; 877  : 			size_type _Newoff = _Mysize + _Myoff - 1;

	mov	ecx, DWORD PTR [esi+24]

; 878  : 			size_type _Block = _Newoff / _DEQUESIZ;
; 879  : 			if (_Mapsize <= _Block)

	mov	edx, DWORD PTR [esi+20]
	lea	ecx, DWORD PTR [eax+ecx-1]
	mov	eax, ecx
	shr	eax, 3
	cmp	edx, eax
	ja	SHORT $LN2@pop_back@2

; 880  : 				_Block -= _Mapsize;

	sub	eax, edx
$LN2@pop_back@2:

; 881  : 			this->_Alval.destroy(_Map[_Block] + _Newoff % _DEQUESIZ);

	mov	edx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [edx+eax*4]
	and	ecx, 7
	lea	ecx, DWORD PTR [eax+ecx*2]
	push	ecx
	lea	ecx, DWORD PTR [esi+12]
	call	DWORD PTR __imp_?destroy@?$allocator@_W@std@@QAEXPA_W@Z

; 882  : 			if (--_Mysize == 0)

	add	DWORD PTR [esi+28], -1
	jne	SHORT $LN1@pop_back@2

; 883  : 				_Myoff = 0;

	mov	DWORD PTR [esi+24], 0
$LN1@pop_back@2:

; 884  : 			}
; 885  : 			}

	ret	0
?pop_back@?$deque@_WV?$allocator@_W@std@@@std@@QAEXXZ ENDP ; std::deque<wchar_t,std::allocator<wchar_t> >::pop_back
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$_Deque_map@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Deque_map@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ PROC ; std::_Deque_map<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~_Deque_map<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >, COMDAT
; _this$ = eax
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$_Deque_map@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ ENDP ; std::_Deque_map<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~_Deque_map<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$_Deque_map@_WV?$allocator@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Deque_map@_WV?$allocator@_W@std@@@std@@QAE@XZ PROC ; std::_Deque_map<wchar_t,std::allocator<wchar_t> >::~_Deque_map<wchar_t,std::allocator<wchar_t> >, COMDAT
; _this$ = eax
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$_Deque_map@_WV?$allocator@_W@std@@@std@@QAE@XZ ENDP ; std::_Deque_map<wchar_t,std::allocator<wchar_t> >::~_Deque_map<wchar_t,std::allocator<wchar_t> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$_Deque_val@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Deque_val@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ PROC ; std::_Deque_val<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~_Deque_val<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >, COMDAT
; _this$ = eax
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$_Deque_val@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ ENDP ; std::_Deque_val<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~_Deque_val<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$_Deque_val@_WV?$allocator@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Deque_val@_WV?$allocator@_W@std@@@std@@QAE@XZ PROC ; std::_Deque_val<wchar_t,std::allocator<wchar_t> >::~_Deque_val<wchar_t,std::allocator<wchar_t> >, COMDAT
; _this$ = eax
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$_Deque_val@_WV?$allocator@_W@std@@@std@@QAE@XZ ENDP ; std::_Deque_val<wchar_t,std::allocator<wchar_t> >::~_Deque_val<wchar_t,std::allocator<wchar_t> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\stack
_TEXT	ENDS
;	COMDAT ?pop@?$stack@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@@std@@QAEXXZ
_TEXT	SEGMENT
?pop@?$stack@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@@std@@QAEXXZ PROC ; std::stack<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::pop, COMDAT
; _this$ = esi

; 63   : 		c.pop_back();

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	je	SHORT $LN3@pop
	mov	ecx, DWORD PTR [esi+24]
	lea	eax, DWORD PTR [eax+ecx-1]
	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, eax
	ja	SHORT $LN4@pop
	sub	eax, ecx
$LN4@pop:
	mov	edx, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [edx+eax*4]
	call	DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
	add	DWORD PTR [esi+28], -1
	jne	SHORT $LN3@pop
	mov	DWORD PTR [esi+24], 0
$LN3@pop:

; 64   : 		}

	ret	0
?pop@?$stack@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@@std@@QAEXXZ ENDP ; std::stack<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::pop
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?pop@?$stack@_WV?$deque@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?pop@?$stack@_WV?$deque@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ PROC ; std::stack<wchar_t,std::deque<wchar_t,std::allocator<wchar_t> > >::pop, COMDAT
; _this$ = esi

; 63   : 		c.pop_back();

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	je	SHORT $LN3@pop@2
	mov	ecx, DWORD PTR [esi+24]
	mov	edx, DWORD PTR [esi+20]
	lea	ecx, DWORD PTR [eax+ecx-1]
	mov	eax, ecx
	shr	eax, 3
	cmp	edx, eax
	ja	SHORT $LN4@pop@2
	sub	eax, edx
$LN4@pop@2:
	mov	edx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [edx+eax*4]
	and	ecx, 7
	lea	ecx, DWORD PTR [eax+ecx*2]
	push	ecx
	lea	ecx, DWORD PTR [esi+12]
	call	DWORD PTR __imp_?destroy@?$allocator@_W@std@@QAEXPA_W@Z
	add	DWORD PTR [esi+28], -1
	jne	SHORT $LN3@pop@2
	mov	DWORD PTR [esi+24], 0
$LN3@pop@2:

; 64   : 		}

	ret	0
?pop@?$stack@_WV?$deque@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ ENDP ; std::stack<wchar_t,std::deque<wchar_t,std::allocator<wchar_t> > >::pop
_TEXT	ENDS
PUBLIC	?ReadCompressedInt@SignatureReader@@AAE_NPAH@Z	; SignatureReader::ReadCompressedInt
; Function compile flags: /Ogtpy
; File c:\local\sharpdevelop_3.2.0.5777_source\src\addins\misc\profiler\hook\profilermetadata.cpp
;	COMDAT ?ReadCompressedInt@SignatureReader@@AAE_NPAH@Z
_TEXT	SEGMENT
_byte2$ = -2						; size = 1
_byte3$ = -1						; size = 1
?ReadCompressedInt@SignatureReader@@AAE_NPAH@Z PROC	; SignatureReader::ReadCompressedInt, COMDAT
; _this$ = eax
; _out$ = edi

; 496  : {

	push	ecx

; 497  :     byte byte1 = 0, byte2 = 0, byte3 = 0, byte4 = 0;
; 498  :         
; 499  :     if (!ReadByte(&byte1))

	mov	ecx, DWORD PTR [eax+12]
	push	esi
	mov	esi, DWORD PTR [eax+20]
	cmp	ecx, esi
	jae	SHORT $LN11@ReadCompre
	mov	dl, BYTE PTR [ecx]
	inc	ecx
	mov	DWORD PTR [eax+12], ecx

; 501  : 
; 502  :     if (byte1 == 0xff) // = nullptr -> error

	cmp	dl, 255					; 000000ffH

; 503  : 		return false;

	je	SHORT $LN11@ReadCompre

; 504  : 
; 505  :     if ((byte1 & 0x80) == 0) {

	test	dl, dl
	js	SHORT $LN6@ReadCompre

; 506  :         *out = (int)byte1;

	movzx	eax, dl
	mov	DWORD PTR [edi], eax

; 507  :         return true;

	mov	al, 1
	pop	esi

; 529  : }

	pop	ecx
	ret	0

; 497  :     byte byte1 = 0, byte2 = 0, byte3 = 0, byte4 = 0;
; 498  :         
; 499  :     if (!ReadByte(&byte1))

$LN11@ReadCompre:

; 500  :         return false;

	xor	al, al
	pop	esi

; 529  : }

	pop	ecx
	ret	0
$LN6@ReadCompre:

; 508  :     }
; 509  : 
; 510  :     if (!ReadByte(&byte2))

	cmp	ecx, esi
	jae	SHORT $LN11@ReadCompre
	push	ebx
	mov	bl, BYTE PTR [ecx]
	inc	ecx
	mov	BYTE PTR _byte2$[esp+12], bl
	mov	DWORD PTR [eax+12], ecx

; 511  :         return false;
; 512  : 
; 513  :     if ((byte1 & 0x40) == 0) {

	test	dl, 64					; 00000040H
	jne	SHORT $LN4@ReadCompre

; 514  :         *out = (((byte1 & 0x3f) << 8) | byte2);

	movzx	ecx, dl
	and	ecx, 63					; 0000003fH
	movzx	edx, bl
	shl	ecx, 8
	or	ecx, edx
	pop	ebx
	mov	DWORD PTR [edi], ecx

; 528  :     return true;

	mov	al, 1
	pop	esi

; 529  : }

	pop	ecx
	ret	0
$LN4@ReadCompre:

; 515  :         return true;
; 516  :     }
; 517  : 
; 518  :     if ((byte1 & 0x20) != 0)        

	test	dl, 32					; 00000020H

; 519  :         return false;

	jne	SHORT $LN20@ReadCompre

; 520  : 
; 521  :     if (!ReadByte(&byte3))

	cmp	ecx, esi
	jae	SHORT $LN20@ReadCompre
	mov	bl, BYTE PTR [ecx]
	inc	ecx
	mov	BYTE PTR _byte3$[esp+12], bl
	mov	DWORD PTR [eax+12], ecx

; 522  :         return false;
; 523  :     
; 524  :     if (!ReadByte(&byte4))

	cmp	ecx, esi
	jae	SHORT $LN20@ReadCompre
	mov	bl, BYTE PTR [ecx]
	inc	ecx
	mov	DWORD PTR [eax+12], ecx

; 526  : 
; 527  :     *out = ((byte1 & 0x1f) << 24) | (byte2 << 16) | (byte3 << 8) | byte4;

	movzx	ecx, BYTE PTR _byte2$[esp+12]
	movzx	eax, dl
	movzx	edx, BYTE PTR _byte3$[esp+12]
	and	eax, 31					; 0000001fH
	shl	eax, 8
	or	eax, ecx
	shl	eax, 8
	or	eax, edx
	movzx	ecx, bl
	shl	eax, 8
	or	eax, ecx
	pop	ebx
	mov	DWORD PTR [edi], eax

; 528  :     return true;

	mov	al, 1
	pop	esi

; 529  : }

	pop	ecx
	ret	0

; 522  :         return false;
; 523  :     
; 524  :     if (!ReadByte(&byte4))

$LN20@ReadCompre:
	pop	ebx

; 525  :         return false;

	xor	al, al
	pop	esi

; 529  : }

	pop	ecx
	ret	0
?ReadCompressedInt@SignatureReader@@AAE_NPAH@Z ENDP	; SignatureReader::ReadCompressedInt
; Function compile flags: /Ogtpy
; File c:\program files\microsoft sdks\windows\v7.0\include\cor.h
_TEXT	ENDS
;	COMDAT ?CorSigUncompressData@@YAKPBEPAK@Z
_TEXT	SEGMENT
_dwSizeOfData$ = -4					; size = 4
?CorSigUncompressData@@YAKPBEPAK@Z PROC			; CorSigUncompressData, COMDAT
; _pData$ = edx
; _pDataOut$ = eax

; 2354 : {   

	push	ecx
	push	edi

; 2355 : 
; 2356 :     ULONG dwSizeOfData = 0;
; 2357 : 
; 2358 :     // We don't know how big the signature is, so we'll just say that it's big enough
; 2359 :     if (FAILED(CorSigUncompressData(pData, 0xff, pDataOut, &dwSizeOfData)))

	push	eax
	lea	edi, DWORD PTR _dwSizeOfData$[esp+12]
	mov	DWORD PTR _dwSizeOfData$[esp+12], 0
	call	?CorSigUncompressData@@YAJPBEKPAK1@Z	; CorSigUncompressData
	add	esp, 4
	pop	edi
	test	eax, eax
	jge	SHORT $LN1@CorSigUnco@2

; 2360 :         return (ULONG)-1;

	or	eax, -1

; 2364 : }

	pop	ecx
	ret	0
$LN1@CorSigUnco@2:

; 2361 : 
; 2362 : 
; 2363 :     return dwSizeOfData;

	mov	eax, DWORD PTR _dwSizeOfData$[esp+4]

; 2364 : }

	pop	ecx
	ret	0
?CorSigUncompressData@@YAKPBEPAK@Z ENDP			; CorSigUncompressData
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\ios
xdata$x	SEGMENT
__unwindtable$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z$2
	DD	00H
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z$3
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z$4
__catchsym$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z$0
__tryblocktable$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z DD 01H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z$5
__ehfuncinfo$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\ostream
xdata$x	ENDS
;	COMDAT ??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z
_TEXT	SEGMENT
__Ok$ = -48						; size = 8
tv324 = -40						; size = 4
$T154691 = -36						; size = 4
__Val$ = -32						; size = 4
__Pad$ = -28						; size = 4
__State$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z PROC ; std::operator<<<wchar_t,std::char_traits<wchar_t> >, COMDAT

; 655  : 	{	// insert NTBS

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	mov	esi, DWORD PTR __Ostr$[ebp]
	push	edi
	mov	eax, OFFSET ??_C@_02JMMFPCED@?$CC?$CC?$AA@

; 656  : 	ios_base::iostate _State = ios_base::goodbit;

	xor	edi, edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __Val$[ebp], eax
	mov	DWORD PTR __State$[ebp], edi

; 657  : 	streamsize _Count = (streamsize)::strlen(_Val);	// may overflow

	lea	edx, DWORD PTR [eax+1]
$LL82@operator@6:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL82@operator@6
	sub	eax, edx
	mov	ebx, eax

; 658  : 	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
; 659  : 		? 0 : _Ostr.width() - _Count;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+esi+24]
	cmp	eax, edi
	jle	SHORT $LN20@operator@6
	cmp	eax, ebx
	jle	SHORT $LN20@operator@6
	sub	eax, ebx
	mov	edi, eax
$LN20@operator@6:

; 660  : 	const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);

	lea	edx, DWORD PTR __Ok$[ebp]
	push	edx
	mov	DWORD PTR __Pad$[ebp], edi
	call	??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 661  : 
; 662  : 	if (!_Ok)

	cmp	BYTE PTR __Ok$[ebp+4], 0
	jne	SHORT $LN17@operator@6

; 663  : 		_State |= ios_base::badbit;

	mov	DWORD PTR __State$[ebp], 4

; 664  : 	else

	jmp	$LN27@operator@6
$LN17@operator@6:

; 665  : 		{	// state okay, insert characters
; 666  : 		_TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 667  : 		const ctype<_Elem>& _Ctype_fac = _USE(_Ostr.getloc(), ctype<_Elem>);

	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR $T154691[ebp]
	push	eax
	add	ecx, esi
	call	DWORD PTR __imp_?getloc@ios_base@std@@QBE?AVlocale@2@XZ
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	call	??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<wchar_t> >
	lea	ecx, DWORD PTR $T154691[ebp]
	mov	DWORD PTR tv324[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	call	DWORD PTR __imp_??1locale@std@@QAE@XZ

; 668  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [eax+esi+16]
	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	SHORT $LL80@operator@6
	npad	4
$LL13@operator@6:

; 669  : 			for (; 0 < _Pad; --_Pad)	// pad on left

	test	edi, edi
	jle	SHORT $LL80@operator@6

; 670  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 671  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [edx+esi]
	movzx	edx, WORD PTR [eax+48]
	mov	eax, DWORD PTR [eax+40]
	push	edx
	mov	ecx, eax
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z
	movzx	eax, ax
	mov	ecx, 65535				; 0000ffffH
	cmp	cx, ax
	jne	SHORT $LN12@operator@6

; 672  : 					{	// insertion failed, quit
; 673  : 					_State |= ios_base::badbit;

	or	DWORD PTR __State$[ebp], 4
	npad	3
$LL80@operator@6:

; 674  : 					break;
; 675  : 					}
; 676  : 
; 677  : 		for (; _State == ios_base::goodbit && 0 < _Count; --_Count, ++_Val)

	cmp	DWORD PTR __State$[ebp], 0
	jne	SHORT $LN2@operator@6
	test	ebx, ebx
	jle	SHORT $LL81@operator@6

; 678  : 			if (_Traits::eq_int_type(_Traits::eof(),
; 679  : 				_Ostr.rdbuf()->sputc(_Ctype_fac.widen(*_Val))))

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Val$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	ecx, DWORD PTR tv324[ebp]
	mov	edi, DWORD PTR [eax+esi+40]
	push	edx
	call	DWORD PTR __imp_?widen@?$ctype@_W@std@@QBE_WD@Z
	movzx	eax, ax
	push	eax
	mov	ecx, edi
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z
	movzx	eax, ax
	mov	ecx, 65535				; 0000ffffH
	cmp	cx, ax
	jne	SHORT $LN8@operator@6

; 680  : 					_State |= ios_base::badbit;

	mov	DWORD PTR __State$[ebp], 4
$LN8@operator@6:

; 674  : 					break;
; 675  : 					}
; 676  : 
; 677  : 		for (; _State == ios_base::goodbit && 0 < _Count; --_Count, ++_Val)

	mov	edi, DWORD PTR __Pad$[ebp]
	dec	ebx
	inc	DWORD PTR __Val$[ebp]
	jmp	SHORT $LL80@operator@6
$LN12@operator@6:

; 669  : 			for (; 0 < _Pad; --_Pad)	// pad on left

	dec	edi
	mov	DWORD PTR __Pad$[ebp], edi
	jmp	$LL13@operator@6
$LL81@operator@6:

; 681  : 
; 682  : 		if (_State == ios_base::goodbit)
; 683  : 			for (; 0 < _Pad; --_Pad)	// pad on right

	test	edi, edi
	jle	SHORT $LN2@operator@6

; 684  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 685  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+4]
	movzx	edx, WORD PTR [eax+esi+48]
	add	eax, esi
	mov	eax, DWORD PTR [eax+40]
	push	edx
	mov	ecx, eax
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z
	movzx	eax, ax
	mov	ecx, 65535				; 0000ffffH
	cmp	cx, ax
	jne	SHORT $LN3@operator@6

; 686  : 					{	// insertion failed, quit
; 687  : 					_State |= ios_base::badbit;

	or	DWORD PTR __State$[ebp], 4
$LN2@operator@6:

; 688  : 					break;
; 689  : 					}
; 690  : 		_Ostr.width(0);

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+4]
	add	eax, esi
	xor	ecx, ecx
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR __$EHRec$[ebp+12], ecx
	jmp	SHORT $LN27@operator@6
$LN3@operator@6:

; 681  : 
; 682  : 		if (_State == ios_base::goodbit)
; 683  : 			for (; 0 < _Pad; --_Pad)	// pad on right

	dec	edi
	jmp	SHORT $LL81@operator@6
__catch$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z$0:

; 691  : 		_CATCH_IO_(_Ostr)

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+4]
	push	1
	push	4
	add	ecx, eax
	call	DWORD PTR __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN88@operator@6
	ret	0
$LN88@operator@6:
	mov	esi, DWORD PTR __Ostr$[ebp]
$LN27@operator@6:

; 692  : 		}
; 693  : 
; 694  : 	_Ostr.setstate(_State);

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR __State$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	0
	push	edx
	add	ecx, esi
	call	DWORD PTR __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z

; 695  : 	return (_Ostr);

	mov	DWORD PTR __$EHRec$[ebp+12], 4
	call	DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
	test	al, al
	jne	SHORT $LN62@operator@6
	mov	ecx, DWORD PTR __Ok$[ebp]
	call	DWORD PTR __imp_?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
$LN62@operator@6:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR __Ok$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [edx+eax+40]
	test	ecx, ecx
	je	SHORT $LN85@operator@6
	call	DWORD PTR __imp_?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ
$LN85@operator@6:

; 696  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z$2:
	lea	eax, DWORD PTR __Ok$[ebp]
	push	eax
	call	??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
	ret	0
__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z$3:
	lea	ecx, DWORD PTR $T154691[ebp]
	jmp	DWORD PTR __imp_??1locale@std@@QAE@XZ
__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z$4:
	lea	eax, DWORD PTR __Ok$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
__ehhandler$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z:
	mov	eax, OFFSET __ehfuncinfo$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z ENDP ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\ios
xdata$x	SEGMENT
__unwindtable$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@D@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@D@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@D@Z$3
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@D@Z$4
__catchsym$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@D@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@D@Z$0
__tryblocktable$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@D@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@D@Z$5
__ehfuncinfo$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@D@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@D@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\ostream
xdata$x	ENDS
;	COMDAT ??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@D@Z
_TEXT	SEGMENT
__Ok$ = -48						; size = 8
__Ctype_fac$137169 = -40				; size = 4
__Ch$ = -36						; size = 1
$T154822 = -32						; size = 4
__State$ = -28						; size = 4
__Pad$137173 = -24					; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@D@Z PROC ; std::operator<<<wchar_t,std::char_traits<wchar_t> >, COMDAT

; 702  : 	{	// insert a character

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@D@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	mov	esi, DWORD PTR __Ostr$[ebp]
	push	edi

; 703  : 	ios_base::iostate _State = ios_base::goodbit;
; 704  : 	const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);

	lea	eax, DWORD PTR __Ok$[ebp]
	mov	DWORD PTR __$EHRec$[ebp], esp
	xor	ebx, ebx
	push	eax
	mov	BYTE PTR __Ch$[ebp], 34			; 00000022H
	xor	edi, edi
	mov	DWORD PTR __State$[ebp], ebx
	call	??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
	mov	DWORD PTR __$EHRec$[ebp+12], edi

; 705  : 
; 706  : 	if (_Ok)

	cmp	BYTE PTR __Ok$[ebp+4], bl
	je	$LN21@operator@7

; 707  : 		{	// state okay, insert
; 708  : 		const ctype<_Elem>& _Ctype_fac = _USE(_Ostr.getloc(), ctype<_Elem>);

	mov	edx, DWORD PTR [esi]
	lea	ecx, DWORD PTR $T154822[ebp]
	push	ecx
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, esi
	call	DWORD PTR __imp_?getloc@ios_base@std@@QBE?AVlocale@2@XZ
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	call	??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<wchar_t> >
	lea	ecx, DWORD PTR $T154822[ebp]
	mov	DWORD PTR __Ctype_fac$137169[ebp], eax
	call	DWORD PTR __imp_??1locale@std@@QAE@XZ

; 709  : 		streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+esi+24]
	add	ecx, esi
	cmp	eax, 1
	jg	SHORT $LN15@operator@7
	mov	DWORD PTR __Pad$137173[ebp], edi
	jmp	SHORT $LN16@operator@7
$LN15@operator@7:
	dec	eax
	mov	DWORD PTR __Pad$137173[ebp], eax
	mov	edi, eax
$LN16@operator@7:

; 710  : 
; 711  : 		_TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 712  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

	mov	ecx, DWORD PTR [ecx+16]
	and	ecx, 448				; 000001c0H
	cmp	ecx, 64					; 00000040H
	je	SHORT $LN70@operator@7
	npad	7
$LL9@operator@7:

; 713  : 			for (; _State == ios_base::goodbit && 0 < _Pad;
; 714  : 				--_Pad)	// pad on left

	test	ebx, ebx
	jne	$LN2@operator@7
	test	edi, edi
	jle	SHORT $LN70@operator@7

; 715  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 716  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+4]
	movzx	edx, WORD PTR [eax+esi+48]
	add	eax, esi
	mov	eax, DWORD PTR [eax+40]
	push	edx
	mov	ecx, eax
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z
	movzx	eax, ax
	mov	ecx, 65535				; 0000ffffH
	cmp	cx, ax
	jne	SHORT $LN8@operator@7

; 717  : 					_State |= ios_base::badbit;

	mov	ebx, 4
	mov	DWORD PTR __State$[ebp], ebx
$LN8@operator@7:
	dec	edi
	mov	DWORD PTR __Pad$137173[ebp], edi
	jmp	SHORT $LL9@operator@7
$LN70@operator@7:

; 718  : 
; 719  : 		if (_State == ios_base::goodbit
; 720  : 			&& _Traits::eq_int_type(_Traits::eof(),
; 721  : 				_Ostr.rdbuf()->sputc(_Ctype_fac.widen(_Ch))))

	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR __Ch$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edi, DWORD PTR [eax+esi+40]
	push	ecx
	mov	ecx, DWORD PTR __Ctype_fac$137169[ebp]
	call	DWORD PTR __imp_?widen@?$ctype@_W@std@@QBE_WD@Z
	movzx	eax, ax
	push	eax
	mov	ecx, edi
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z
	movzx	eax, ax
	mov	edx, 65535				; 0000ffffH
	cmp	dx, ax
	jne	SHORT $LL71@operator@7

; 722  : 			_State |= ios_base::badbit;

	mov	ebx, 4
	mov	DWORD PTR __State$[ebp], ebx
$LL71@operator@7:

; 723  : 
; 724  : 		for (; _State == ios_base::goodbit && 0 < _Pad;
; 725  : 			--_Pad)	// pad on right

	test	ebx, ebx
	jne	SHORT $LN2@operator@7
	cmp	DWORD PTR __Pad$137173[ebp], ebx
	jle	SHORT $LN2@operator@7

; 726  : 			if (_Traits::eq_int_type(_Traits::eof(),
; 727  : 				_Ostr.rdbuf()->sputc(_Ostr.fill())))

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	movzx	edx, WORD PTR [ecx+esi+48]
	lea	eax, DWORD PTR [ecx+esi]
	mov	eax, DWORD PTR [eax+40]
	push	edx
	mov	ecx, eax
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z
	movzx	eax, ax
	mov	edx, 65535				; 0000ffffH
	cmp	dx, ax
	jne	SHORT $LN3@operator@7

; 728  : 				_State |= ios_base::badbit;

	mov	ebx, 4
	mov	DWORD PTR __State$[ebp], ebx
$LN3@operator@7:

; 723  : 
; 724  : 		for (; _State == ios_base::goodbit && 0 < _Pad;
; 725  : 			--_Pad)	// pad on right

	dec	DWORD PTR __Pad$137173[ebp]
	jmp	SHORT $LL71@operator@7
__catch$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@D@Z$0:

; 729  : 		_CATCH_IO_(_Ostr)

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+4]
	push	1
	push	4
	add	ecx, eax
	call	DWORD PTR __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN22@operator@7
	ret	0
$LN22@operator@7:
	mov	esi, DWORD PTR __Ostr$[ebp]
	mov	ebx, DWORD PTR __State$[ebp]
	jmp	SHORT $LN21@operator@7
$LN2@operator@7:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN21@operator@7:

; 730  : 		}
; 731  : 
; 732  : 	_Ostr.width(0);

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+4]
	add	eax, esi
	mov	DWORD PTR [eax+24], 0

; 733  : 	_Ostr.setstate(_State);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	push	0
	push	ebx
	add	ecx, esi
	call	DWORD PTR __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z

; 734  : 	return (_Ostr);

	mov	DWORD PTR __$EHRec$[ebp+12], 4
	call	DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
	test	al, al
	jne	SHORT $LN55@operator@7
	mov	ecx, DWORD PTR __Ok$[ebp]
	call	DWORD PTR __imp_?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
$LN55@operator@7:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR __Ok$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [edx+eax+40]
	test	ecx, ecx
	je	SHORT $LN73@operator@7
	call	DWORD PTR __imp_?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ
$LN73@operator@7:

; 735  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@D@Z$2:
	lea	eax, DWORD PTR __Ok$[ebp]
	push	eax
	call	??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
	ret	0
__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@D@Z$3:
	lea	ecx, DWORD PTR $T154822[ebp]
	jmp	DWORD PTR __imp_??1locale@std@@QAE@XZ
__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@D@Z$4:
	lea	eax, DWORD PTR __Ok$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
__ehhandler$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@D@Z:
	mov	eax, OFFSET __ehfuncinfo$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@D@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@D@Z ENDP ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\deque
;	COMDAT ??Y?$_Deque_const_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@$00@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
??Y?$_Deque_const_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@$00@std@@QAEAAV01@H@Z PROC ; std::_Deque_const_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,1>::operator+=, COMDAT
; _this$ = esi

; 199  : 		_SCL_SECURE_TRAITS_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	push	ebx
	mov	ebx, DWORD PTR __imp___invalid_parameter_noinfo
	push	edi
	test	eax, eax
	jne	SHORT $LN34@operator@8
	call	ebx

; 200  : 		_SCL_SECURE_TRAITS_VALIDATE_RANGE(
; 201  : 			_Myoff + _Off <= ((_Mydeque *)(this->_Getmycont()))->_Myoff + ((_Mydeque *)(this->_Getmycont()))->_Mysize &&
; 202  : 			_Myoff + _Off >= ((_Mydeque *)(this->_Getmycont()))->_Myoff);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN18@operator@8
$LN34@operator@8:
	mov	edi, DWORD PTR [eax]
	jmp	SHORT $LN19@operator@8
$LN18@operator@8:
	xor	edi, edi
$LN19@operator@8:
	test	eax, eax
	je	SHORT $LN24@operator@8
	mov	edx, DWORD PTR [eax]
	jmp	SHORT $LN25@operator@8
$LN24@operator@8:
	xor	edx, edx
$LN25@operator@8:
	mov	edx, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR [esi+4]
	add	edx, DWORD PTR [edi+24]
	dec	ecx
	cmp	ecx, edx
	ja	SHORT $LN4@operator@8
	test	eax, eax
	je	SHORT $LN30@operator@8
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN31@operator@8
$LN30@operator@8:
	xor	eax, eax
$LN31@operator@8:
	cmp	ecx, DWORD PTR [eax+24]
	jae	SHORT $LN35@operator@8
$LN4@operator@8:
	call	ebx
$LN35@operator@8:

; 203  : 		_Myoff += _Off;

	dec	DWORD PTR [esi+4]
	pop	edi

; 204  : 		return (*this);

	mov	eax, esi
	pop	ebx

; 205  : 		}

	ret	0
??Y?$_Deque_const_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@$00@std@@QAEAAV01@H@Z ENDP ; std::_Deque_const_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,1>::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Y?$_Deque_const_iterator@_WV?$allocator@_W@std@@$00@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
??Y?$_Deque_const_iterator@_WV?$allocator@_W@std@@$00@std@@QAEAAV01@H@Z PROC ; std::_Deque_const_iterator<wchar_t,std::allocator<wchar_t>,1>::operator+=, COMDAT
; _this$ = esi

; 199  : 		_SCL_SECURE_TRAITS_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	push	ebx
	mov	ebx, DWORD PTR __imp___invalid_parameter_noinfo
	push	edi
	test	eax, eax
	jne	SHORT $LN34@operator@9
	call	ebx

; 200  : 		_SCL_SECURE_TRAITS_VALIDATE_RANGE(
; 201  : 			_Myoff + _Off <= ((_Mydeque *)(this->_Getmycont()))->_Myoff + ((_Mydeque *)(this->_Getmycont()))->_Mysize &&
; 202  : 			_Myoff + _Off >= ((_Mydeque *)(this->_Getmycont()))->_Myoff);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN18@operator@9
$LN34@operator@9:
	mov	edi, DWORD PTR [eax]
	jmp	SHORT $LN19@operator@9
$LN18@operator@9:
	xor	edi, edi
$LN19@operator@9:
	test	eax, eax
	je	SHORT $LN24@operator@9
	mov	edx, DWORD PTR [eax]
	jmp	SHORT $LN25@operator@9
$LN24@operator@9:
	xor	edx, edx
$LN25@operator@9:
	mov	edx, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR [esi+4]
	add	edx, DWORD PTR [edi+24]
	dec	ecx
	cmp	ecx, edx
	ja	SHORT $LN4@operator@9
	test	eax, eax
	je	SHORT $LN30@operator@9
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN31@operator@9
$LN30@operator@9:
	xor	eax, eax
$LN31@operator@9:
	cmp	ecx, DWORD PTR [eax+24]
	jae	SHORT $LN35@operator@9
$LN4@operator@9:
	call	ebx
$LN35@operator@9:

; 203  : 		_Myoff += _Off;

	dec	DWORD PTR [esi+4]
	pop	edi

; 204  : 		return (*this);

	mov	eax, esi
	pop	ebx

; 205  : 		}

	ret	0
??Y?$_Deque_const_iterator@_WV?$allocator@_W@std@@$00@std@@QAEAAV01@H@Z ENDP ; std::_Deque_const_iterator<wchar_t,std::allocator<wchar_t>,1>::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Y?$_Deque_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@$00@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
??Y?$_Deque_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@$00@std@@QAEAAV01@H@Z PROC ; std::_Deque_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,1>::operator+=, COMDAT
; _this$ = esi

; 422  : 		*(_Mybase *)this += _Off;

	mov	eax, DWORD PTR [esi]
	push	ebx
	mov	ebx, DWORD PTR __imp___invalid_parameter_noinfo
	push	edi
	test	eax, eax
	jne	SHORT $LN36@operator@10
	call	ebx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN20@operator@10
$LN36@operator@10:
	mov	edi, DWORD PTR [eax]
	jmp	SHORT $LN21@operator@10
$LN20@operator@10:
	xor	edi, edi
$LN21@operator@10:
	test	eax, eax
	je	SHORT $LN26@operator@10
	mov	edx, DWORD PTR [eax]
	jmp	SHORT $LN27@operator@10
$LN26@operator@10:
	xor	edx, edx
$LN27@operator@10:
	mov	edx, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR [esi+4]
	add	edx, DWORD PTR [edi+24]
	dec	ecx
	cmp	ecx, edx
	ja	SHORT $LN6@operator@10
	test	eax, eax
	je	SHORT $LN32@operator@10
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN33@operator@10
$LN32@operator@10:
	xor	eax, eax
$LN33@operator@10:
	cmp	ecx, DWORD PTR [eax+24]
	jae	SHORT $LN37@operator@10
$LN6@operator@10:
	call	ebx
$LN37@operator@10:
	dec	DWORD PTR [esi+4]
	pop	edi

; 423  : 		return (*this);

	mov	eax, esi
	pop	ebx

; 424  : 		}

	ret	0
??Y?$_Deque_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@$00@std@@QAEAAV01@H@Z ENDP ; std::_Deque_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,1>::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Y?$_Deque_iterator@_WV?$allocator@_W@std@@$00@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
??Y?$_Deque_iterator@_WV?$allocator@_W@std@@$00@std@@QAEAAV01@H@Z PROC ; std::_Deque_iterator<wchar_t,std::allocator<wchar_t>,1>::operator+=, COMDAT
; _this$ = esi

; 422  : 		*(_Mybase *)this += _Off;

	mov	eax, DWORD PTR [esi]
	push	ebx
	mov	ebx, DWORD PTR __imp___invalid_parameter_noinfo
	push	edi
	test	eax, eax
	jne	SHORT $LN36@operator@11
	call	ebx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN20@operator@11
$LN36@operator@11:
	mov	edi, DWORD PTR [eax]
	jmp	SHORT $LN21@operator@11
$LN20@operator@11:
	xor	edi, edi
$LN21@operator@11:
	test	eax, eax
	je	SHORT $LN26@operator@11
	mov	edx, DWORD PTR [eax]
	jmp	SHORT $LN27@operator@11
$LN26@operator@11:
	xor	edx, edx
$LN27@operator@11:
	mov	edx, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR [esi+4]
	add	edx, DWORD PTR [edi+24]
	dec	ecx
	cmp	ecx, edx
	ja	SHORT $LN6@operator@11
	test	eax, eax
	je	SHORT $LN32@operator@11
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN33@operator@11
$LN32@operator@11:
	xor	eax, eax
$LN33@operator@11:
	cmp	ecx, DWORD PTR [eax+24]
	jae	SHORT $LN37@operator@11
$LN6@operator@11:
	call	ebx
$LN37@operator@11:
	dec	DWORD PTR [esi+4]
	pop	edi

; 423  : 		return (*this);

	mov	eax, esi
	pop	ebx

; 424  : 		}

	ret	0
??Y?$_Deque_iterator@_WV?$allocator@_W@std@@$00@std@@QAEAAV01@H@Z ENDP ; std::_Deque_iterator<wchar_t,std::allocator<wchar_t>,1>::operator+=
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@IAE@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@IAE@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Container_base_aux_alloc_real<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >, COMDAT
; _this$ = esi

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@Container_@4
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
$LN3@Container_@4:

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
??0?$_Container_base_aux_alloc_real@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@IAE@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Container_base_aux_alloc_real<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@_W@std@@@std@@IAE@V?$allocator@_W@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@_W@std@@@std@@IAE@V?$allocator@_W@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<wchar_t> >::_Container_base_aux_alloc_real<std::allocator<wchar_t> >, COMDAT
; _this$ = esi

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@Container_@5
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
$LN3@Container_@5:

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
??0?$_Container_base_aux_alloc_real@V?$allocator@_W@std@@@std@@IAE@V?$allocator@_W@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<wchar_t> >::_Container_base_aux_alloc_real<std::allocator<wchar_t> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ??D?$_Deque_const_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@$00@std@@QBEABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@XZ
_TEXT	SEGMENT
??D?$_Deque_const_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@$00@std@@QBEABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@XZ PROC ; std::_Deque_const_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,1>::operator*, COMDAT
; _this$ = eax

; 136  : 			{	// return designated object

	push	ebx

; 137  : 			size_type _Block = _Myoff / _DEQUESIZ;
; 138  : 			size_type _Off = _Myoff & (_DEQUESIZ - 1);	// assume power of 2
; 139  : 			_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ebx, DWORD PTR __imp___invalid_parameter_noinfo
	push	esi
	mov	esi, eax
	mov	eax, DWORD PTR [esi]
	push	edi
	mov	edi, DWORD PTR [esi+4]
	test	eax, eax
	jne	SHORT $LN44@operator@12
	call	ebx

; 140  : 			_SCL_SECURE_VALIDATE_RANGE(_Myoff < ((_Mydeque *)(this->_Getmycont()))->_Myoff + ((_Mydeque *)(this->_Getmycont()))->_Mysize);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN16@operator@12
$LN44@operator@12:
	mov	ecx, DWORD PTR [eax]
	jmp	SHORT $LN17@operator@12
$LN16@operator@12:
	xor	ecx, ecx
$LN17@operator@12:
	test	eax, eax
	je	SHORT $LN22@operator@12
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN23@operator@12
$LN22@operator@12:
	xor	eax, eax
$LN23@operator@12:
	mov	eax, DWORD PTR [eax+28]
	add	eax, DWORD PTR [ecx+24]
	cmp	DWORD PTR [esi+4], eax
	jb	SHORT $LN4@operator@12
	call	ebx
$LN4@operator@12:

; 141  : 			if (static_cast<const _Mydeque *>(this->_Getmycont())->_Mapsize <= _Block)

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	je	SHORT $LN28@operator@12
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN29@operator@12
$LN28@operator@12:
	xor	eax, eax
$LN29@operator@12:
	cmp	DWORD PTR [eax+20], edi
	ja	SHORT $LN1@operator@12

; 142  : 				_Block -= static_cast<const _Mydeque *>(this->_Getmycont())->_Mapsize;

	test	esi, esi
	je	SHORT $LN34@operator@12
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN35@operator@12
$LN34@operator@12:
	xor	eax, eax
$LN35@operator@12:
	sub	edi, DWORD PTR [eax+20]
$LN1@operator@12:

; 143  : 			return ((static_cast<const _Mydeque *>(this->_Getmycont())->_Map)[_Block][_Off]);

	test	esi, esi
	je	SHORT $LN40@operator@12
	mov	esi, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [ecx+edi*4]
	pop	edi
	pop	esi
	pop	ebx

; 144  : 			}

	ret	0

; 143  : 			return ((static_cast<const _Mydeque *>(this->_Getmycont())->_Map)[_Block][_Off]);

$LN40@operator@12:
	xor	eax, eax
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [edx+edi*4]
	pop	edi
	pop	esi
	pop	ebx

; 144  : 			}

	ret	0
??D?$_Deque_const_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@$00@std@@QBEABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@XZ ENDP ; std::_Deque_const_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,1>::operator*
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Z?$_Deque_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@$00@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
??Z?$_Deque_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@$00@std@@QAEAAV01@H@Z PROC ; std::_Deque_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,1>::operator-=, COMDAT
; _this$ = esi

; 434  : 		return (*this += -_Off);

	mov	eax, DWORD PTR [esi]
	push	ebx
	mov	ebx, DWORD PTR __imp___invalid_parameter_noinfo
	push	edi
	test	eax, eax
	jne	SHORT $LN38@operator@13
	call	ebx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN22@operator@13
$LN38@operator@13:
	mov	edi, DWORD PTR [eax]
	jmp	SHORT $LN23@operator@13
$LN22@operator@13:
	xor	edi, edi
$LN23@operator@13:
	test	eax, eax
	je	SHORT $LN28@operator@13
	mov	edx, DWORD PTR [eax]
	jmp	SHORT $LN29@operator@13
$LN28@operator@13:
	xor	edx, edx
$LN29@operator@13:
	mov	edx, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR [esi+4]
	add	edx, DWORD PTR [edi+24]
	dec	ecx
	cmp	ecx, edx
	ja	SHORT $LN8@operator@13
	test	eax, eax
	je	SHORT $LN34@operator@13
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN35@operator@13
$LN34@operator@13:
	xor	eax, eax
$LN35@operator@13:
	cmp	ecx, DWORD PTR [eax+24]
	jae	SHORT $LN39@operator@13
$LN8@operator@13:
	call	ebx
$LN39@operator@13:
	dec	DWORD PTR [esi+4]
	pop	edi
	mov	eax, esi
	pop	ebx

; 435  : 		}

	ret	0
??Z?$_Deque_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@$00@std@@QAEAAV01@H@Z ENDP ; std::_Deque_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,1>::operator-=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??D?$_Deque_const_iterator@_WV?$allocator@_W@std@@$00@std@@QBEAB_WXZ
_TEXT	SEGMENT
??D?$_Deque_const_iterator@_WV?$allocator@_W@std@@$00@std@@QBEAB_WXZ PROC ; std::_Deque_const_iterator<wchar_t,std::allocator<wchar_t>,1>::operator*, COMDAT
; _this$ = eax

; 136  : 			{	// return designated object

	push	ebx

; 137  : 			size_type _Block = _Myoff / _DEQUESIZ;
; 138  : 			size_type _Off = _Myoff & (_DEQUESIZ - 1);	// assume power of 2
; 139  : 			_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ebx, DWORD PTR __imp___invalid_parameter_noinfo
	push	ebp
	push	esi
	mov	esi, eax
	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	edi, eax
	and	eax, 7
	mov	ebp, eax
	mov	eax, DWORD PTR [esi]
	shr	edi, 3
	test	eax, eax
	jne	SHORT $LN44@operator@14
	call	ebx

; 140  : 			_SCL_SECURE_VALIDATE_RANGE(_Myoff < ((_Mydeque *)(this->_Getmycont()))->_Myoff + ((_Mydeque *)(this->_Getmycont()))->_Mysize);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN16@operator@14
$LN44@operator@14:
	mov	ecx, DWORD PTR [eax]
	jmp	SHORT $LN17@operator@14
$LN16@operator@14:
	xor	ecx, ecx
$LN17@operator@14:
	test	eax, eax
	je	SHORT $LN22@operator@14
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN23@operator@14
$LN22@operator@14:
	xor	eax, eax
$LN23@operator@14:
	mov	eax, DWORD PTR [eax+28]
	add	eax, DWORD PTR [ecx+24]
	cmp	DWORD PTR [esi+4], eax
	jb	SHORT $LN4@operator@14
	call	ebx
$LN4@operator@14:

; 141  : 			if (static_cast<const _Mydeque *>(this->_Getmycont())->_Mapsize <= _Block)

	mov	esi, DWORD PTR [esi]
	test	esi, esi
	je	SHORT $LN28@operator@14
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN29@operator@14
$LN28@operator@14:
	xor	eax, eax
$LN29@operator@14:
	cmp	DWORD PTR [eax+20], edi
	ja	SHORT $LN1@operator@14

; 142  : 				_Block -= static_cast<const _Mydeque *>(this->_Getmycont())->_Mapsize;

	test	esi, esi
	je	SHORT $LN34@operator@14
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN35@operator@14
$LN34@operator@14:
	xor	eax, eax
$LN35@operator@14:
	sub	edi, DWORD PTR [eax+20]
$LN1@operator@14:

; 143  : 			return ((static_cast<const _Mydeque *>(this->_Getmycont())->_Map)[_Block][_Off]);

	test	esi, esi
	je	SHORT $LN40@operator@14
	mov	esi, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [ecx+edi*4]
	pop	edi
	pop	esi
	lea	eax, DWORD PTR [edx+ebp*2]
	pop	ebp
	pop	ebx

; 144  : 			}

	ret	0

; 143  : 			return ((static_cast<const _Mydeque *>(this->_Getmycont())->_Map)[_Block][_Off]);

$LN40@operator@14:
	xor	esi, esi
	mov	ecx, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [ecx+edi*4]
	pop	edi
	pop	esi
	lea	eax, DWORD PTR [edx+ebp*2]
	pop	ebp
	pop	ebx

; 144  : 			}

	ret	0
??D?$_Deque_const_iterator@_WV?$allocator@_W@std@@$00@std@@QBEAB_WXZ ENDP ; std::_Deque_const_iterator<wchar_t,std::allocator<wchar_t>,1>::operator*
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Z?$_Deque_iterator@_WV?$allocator@_W@std@@$00@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
??Z?$_Deque_iterator@_WV?$allocator@_W@std@@$00@std@@QAEAAV01@H@Z PROC ; std::_Deque_iterator<wchar_t,std::allocator<wchar_t>,1>::operator-=, COMDAT
; _this$ = esi

; 434  : 		return (*this += -_Off);

	mov	eax, DWORD PTR [esi]
	push	ebx
	mov	ebx, DWORD PTR __imp___invalid_parameter_noinfo
	push	edi
	test	eax, eax
	jne	SHORT $LN38@operator@15
	call	ebx
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN22@operator@15
$LN38@operator@15:
	mov	edi, DWORD PTR [eax]
	jmp	SHORT $LN23@operator@15
$LN22@operator@15:
	xor	edi, edi
$LN23@operator@15:
	test	eax, eax
	je	SHORT $LN28@operator@15
	mov	edx, DWORD PTR [eax]
	jmp	SHORT $LN29@operator@15
$LN28@operator@15:
	xor	edx, edx
$LN29@operator@15:
	mov	edx, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR [esi+4]
	add	edx, DWORD PTR [edi+24]
	dec	ecx
	cmp	ecx, edx
	ja	SHORT $LN8@operator@15
	test	eax, eax
	je	SHORT $LN34@operator@15
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN35@operator@15
$LN34@operator@15:
	xor	eax, eax
$LN35@operator@15:
	cmp	ecx, DWORD PTR [eax+24]
	jae	SHORT $LN39@operator@15
$LN8@operator@15:
	call	ebx
$LN39@operator@15:
	dec	DWORD PTR [esi+4]
	pop	edi
	mov	eax, esi
	pop	ebx

; 435  : 		}

	ret	0
??Z?$_Deque_iterator@_WV?$allocator@_W@std@@$00@std@@QAEAAV01@H@Z ENDP ; std::_Deque_iterator<wchar_t,std::allocator<wchar_t>,1>::operator-=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Deque_map@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAE@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Deque_map@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAE@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z PROC ; std::_Deque_map<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Deque_map<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >, COMDAT
; _this$ = esi

; 478  : 		{	// construct allocator from _Al

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@Deque_map
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 479  : 		}

	mov	eax, esi
	ret	4

; 478  : 		{	// construct allocator from _Al

$LN8@Deque_map:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 479  : 		}

	mov	eax, esi
	ret	4
??0?$_Deque_map@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAE@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z ENDP ; std::_Deque_map<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Deque_map<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\deque
xdata$x	ENDS
;	COMDAT ?_Xlen@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@KAXXZ
_TEXT	SEGMENT
$T155792 = -80						; size = 28
$T155791 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@KAXXZ PROC ; std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Xlen, COMDAT

; 1210 : 		{	// report length error

	push	-1
	push	__ehhandler$?_Xlen@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 72					; 00000048H

; 1211 : 		_THROW(length_error, "deque<T> too long");

	push	OFFSET ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T155792[esp+88]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T155791[esp+84]
	mov	DWORD PTR __$EHRec$[esp+92], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T155792[esp+84]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	push	eax
	lea	ecx, DWORD PTR $T155791[esp+100]
	mov	DWORD PTR $T155791[esp+88], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T155791[esp+88]
	mov	BYTE PTR __$EHRec$[esp+96], 0
	push	ecx
	mov	DWORD PTR $T155791[esp+92], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen:
$LN12@Xlen:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T155792[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T155791[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@KAXXZ ENDP ; std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Xlen
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Deque_map@_WV?$allocator@_W@std@@@std@@IAE@V?$allocator@_W@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Deque_map@_WV?$allocator@_W@std@@@std@@IAE@V?$allocator@_W@1@@Z PROC ; std::_Deque_map<wchar_t,std::allocator<wchar_t> >::_Deque_map<wchar_t,std::allocator<wchar_t> >, COMDAT
; _this$ = esi

; 478  : 		{	// construct allocator from _Al

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@Deque_map@2
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 479  : 		}

	mov	eax, esi
	ret	4

; 478  : 		{	// construct allocator from _Al

$LN8@Deque_map@2:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 479  : 		}

	mov	eax, esi
	ret	4
??0?$_Deque_map@_WV?$allocator@_W@std@@@std@@IAE@V?$allocator@_W@1@@Z ENDP ; std::_Deque_map<wchar_t,std::allocator<wchar_t> >::_Deque_map<wchar_t,std::allocator<wchar_t> >
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$deque@_WV?$allocator@_W@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$deque@_WV?$allocator@_W@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$deque@_WV?$allocator@_W@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$deque@_WV?$allocator@_W@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$deque@_WV?$allocator@_W@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\deque
xdata$x	ENDS
;	COMDAT ?_Xlen@?$deque@_WV?$allocator@_W@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T155900 = -80						; size = 28
$T155899 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$deque@_WV?$allocator@_W@std@@@std@@KAXXZ PROC	; std::deque<wchar_t,std::allocator<wchar_t> >::_Xlen, COMDAT

; 1210 : 		{	// report length error

	push	-1
	push	__ehhandler$?_Xlen@?$deque@_WV?$allocator@_W@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1211 : 		_THROW(length_error, "deque<T> too long");

	push	OFFSET ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T155900[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T155899[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T155900[esp+80]
	mov	BYTE PTR __$EHRec$[esp+88], 1
	push	eax
	lea	ecx, DWORD PTR $T155899[esp+96]
	mov	DWORD PTR $T155899[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T155899[esp+84]
	mov	BYTE PTR __$EHRec$[esp+92], 0
	push	ecx
	mov	DWORD PTR $T155899[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@2:
$LN12@Xlen@2:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$deque@_WV?$allocator@_W@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T155900[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$deque@_WV?$allocator@_W@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T155899[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$deque@_WV?$allocator@_W@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$deque@_WV?$allocator@_W@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$deque@_WV?$allocator@_W@std@@@std@@KAXXZ ENDP	; std::deque<wchar_t,std::allocator<wchar_t> >::_Xlen
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Deque_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@$00@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
??G?$_Deque_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@$00@std@@QBE?AV01@H@Z PROC ; std::_Deque_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,1>::operator-, COMDAT
; _this$ = eax

; 438  : 		{	// return this - integer

	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[esp]
	push	ebp

; 439  : 		_Myt _Tmp = *this;
; 440  : 		return (_Tmp -= _Off);

	mov	ebp, DWORD PTR __imp___invalid_parameter_noinfo
	push	esi
	mov	esi, DWORD PTR [eax]
	push	edi
	mov	edi, DWORD PTR [eax+4]
	test	esi, esi
	jne	SHORT $LN40@operator@16
	call	ebp
	xor	eax, eax
	xor	ecx, ecx
$LN31@operator@16:
	mov	ecx, DWORD PTR [ecx+28]
	add	ecx, DWORD PTR [eax+24]
	dec	edi
	cmp	edi, ecx
	ja	SHORT $LN10@operator@16
	test	esi, esi
	je	SHORT $LN36@operator@16
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN37@operator@16
$LN40@operator@16:
	mov	eax, DWORD PTR [esi]
	mov	ecx, eax
	jmp	SHORT $LN31@operator@16
$LN36@operator@16:
	xor	eax, eax
$LN37@operator@16:
	cmp	edi, DWORD PTR [eax+24]
	jae	SHORT $LN9@operator@16
$LN10@operator@16:
	call	ebp
$LN9@operator@16:
	mov	DWORD PTR [ebx+4], edi

; 441  : 		}

	pop	edi
	mov	DWORD PTR [ebx], esi
	pop	esi
	pop	ebp
	mov	eax, ebx
	pop	ebx
	ret	4
??G?$_Deque_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@$00@std@@QBE?AV01@H@Z ENDP ; std::_Deque_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,1>::operator-
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??D?$_Deque_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@$00@std@@QBEAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@XZ
_TEXT	SEGMENT
??D?$_Deque_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@$00@std@@QBEAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@XZ PROC ; std::_Deque_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,1>::operator*, COMDAT
; _this$ = eax

; 386  : 		return ((reference)**(_Mybase *)this);

	jmp	??D?$_Deque_const_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@$00@std@@QBEABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@XZ ; std::_Deque_const_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,1>::operator*
??D?$_Deque_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@$00@std@@QBEAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@XZ ENDP ; std::_Deque_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,1>::operator*
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??G?$_Deque_iterator@_WV?$allocator@_W@std@@$00@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
??G?$_Deque_iterator@_WV?$allocator@_W@std@@$00@std@@QBE?AV01@H@Z PROC ; std::_Deque_iterator<wchar_t,std::allocator<wchar_t>,1>::operator-, COMDAT
; _this$ = eax

; 438  : 		{	// return this - integer

	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[esp]
	push	ebp

; 439  : 		_Myt _Tmp = *this;
; 440  : 		return (_Tmp -= _Off);

	mov	ebp, DWORD PTR __imp___invalid_parameter_noinfo
	push	esi
	mov	esi, DWORD PTR [eax]
	push	edi
	mov	edi, DWORD PTR [eax+4]
	test	esi, esi
	jne	SHORT $LN40@operator@17
	call	ebp
	xor	eax, eax
	xor	ecx, ecx
$LN31@operator@17:
	mov	ecx, DWORD PTR [ecx+28]
	add	ecx, DWORD PTR [eax+24]
	dec	edi
	cmp	edi, ecx
	ja	SHORT $LN10@operator@17
	test	esi, esi
	je	SHORT $LN36@operator@17
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN37@operator@17
$LN40@operator@17:
	mov	eax, DWORD PTR [esi]
	mov	ecx, eax
	jmp	SHORT $LN31@operator@17
$LN36@operator@17:
	xor	eax, eax
$LN37@operator@17:
	cmp	edi, DWORD PTR [eax+24]
	jae	SHORT $LN9@operator@17
$LN10@operator@17:
	call	ebp
$LN9@operator@17:
	mov	DWORD PTR [ebx+4], edi
	pop	edi
	mov	DWORD PTR [ebx], esi
	pop	esi
	pop	ebp
	mov	eax, ebx
	pop	ebx

; 441  : 		}

	ret	4
??G?$_Deque_iterator@_WV?$allocator@_W@std@@$00@std@@QBE?AV01@H@Z ENDP ; std::_Deque_iterator<wchar_t,std::allocator<wchar_t>,1>::operator-
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??D?$_Deque_iterator@_WV?$allocator@_W@std@@$00@std@@QBEAA_WXZ
_TEXT	SEGMENT
??D?$_Deque_iterator@_WV?$allocator@_W@std@@$00@std@@QBEAA_WXZ PROC ; std::_Deque_iterator<wchar_t,std::allocator<wchar_t>,1>::operator*, COMDAT
; _this$ = eax

; 386  : 		return ((reference)**(_Mybase *)this);

	jmp	??D?$_Deque_const_iterator@_WV?$allocator@_W@std@@$00@std@@QBEAB_WXZ ; std::_Deque_const_iterator<wchar_t,std::allocator<wchar_t>,1>::operator*
??D?$_Deque_iterator@_WV?$allocator@_W@std@@$00@std@@QBEAA_WXZ ENDP ; std::_Deque_iterator<wchar_t,std::allocator<wchar_t>,1>::operator*
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Deque_val@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAE@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Deque_val@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAE@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z PROC ; std::_Deque_val<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Deque_val<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >, COMDAT
; _this$ = esi

; 500  : 		{	// construct allocator and base from _Al

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN13@Deque_val
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 501  : 		}

	mov	eax, esi
	ret	4

; 500  : 		{	// construct allocator and base from _Al

$LN13@Deque_val:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 501  : 		}

	mov	eax, esi
	ret	4
??0?$_Deque_val@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAE@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@@Z ENDP ; std::_Deque_val<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Deque_val<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Growmap@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z
_TEXT	SEGMENT
__Myboff$ = -8						; size = 4
__Newmap$ = -4						; size = 4
__Count$ = 8						; size = 4
_this$ = 8						; size = 4
?_Growmap@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z PROC ; std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Growmap, COMDAT

; 1225 : 		{	// grow map by _Count pointers

	sub	esp, 8
	push	ebx
	mov	ebx, DWORD PTR _this$[esp+8]

; 1226 : 		if (max_size() / _DEQUESIZ - _Mapsize < _Count)

	mov	eax, DWORD PTR [ebx+20]
	push	ebp
	mov	ecx, 153391689				; 09249249H
	mov	edx, 1
	sub	ecx, eax
	push	esi
	push	edi

; 1236 : 		_Mapptr _Myptr = _Newmap + _Myboff;
; 1237 : 
; 1238 : 		_Myptr = _STDEXT unchecked_uninitialized_copy(_Map + _Myboff,
; 1239 : 			_Map + _Mapsize, _Myptr, this->_Almap);	// copy initial to end

	mov	DWORD PTR __Count$[esp+20], edx
	cmp	ecx, edx
	jae	SHORT $LN6@Growmap

; 1227 : 			_Xlen();	// result too long

	call	?_Xlen@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@KAXXZ ; std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Xlen
$LN159@Growmap:
$LN6@Growmap:

; 1228 : 
; 1229 : 		size_type _Inc = _Mapsize / 2;	// try to grow by 50%

	mov	ecx, eax
	shr	ecx, 1

; 1230 : 		if (_Inc < _DEQUEMAPSIZ)

	cmp	ecx, 8
	jae	SHORT $LN5@Growmap

; 1231 : 			_Inc = _DEQUEMAPSIZ;

	mov	ecx, 8

; 1232 : 		if (_Count < _Inc && _Mapsize <= max_size() / _DEQUESIZ - _Inc)

	jmp	SHORT $LN152@Growmap
$LN5@Growmap:
	cmp	ecx, 1
	jbe	SHORT $LN4@Growmap
$LN152@Growmap:
	mov	esi, 153391689				; 09249249H
	sub	esi, ecx
	cmp	eax, esi
	ja	SHORT $LN4@Growmap

; 1233 : 			_Count = _Inc;

	mov	edx, ecx
	mov	DWORD PTR __Count$[esp+20], ecx
$LN4@Growmap:

; 1234 : 		size_type _Myboff = _Myoff / _DEQUESIZ;

	mov	esi, DWORD PTR [ebx+24]

; 1235 : 		_Mapptr _Newmap = this->_Almap.allocate(_Mapsize + _Count);

	lea	ecx, DWORD PTR [eax+edx]
	mov	DWORD PTR __Myboff$[esp+24], esi
	call	?allocate@?$allocator@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEPAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *>::allocate

; 1236 : 		_Mapptr _Myptr = _Newmap + _Myboff;
; 1237 : 
; 1238 : 		_Myptr = _STDEXT unchecked_uninitialized_copy(_Map + _Myboff,
; 1239 : 			_Map + _Mapsize, _Myptr, this->_Almap);	// copy initial to end

	mov	ecx, DWORD PTR [ebx+16]
	mov	DWORD PTR __Newmap$[esp+24], eax
	add	esi, esi
	add	esi, esi
	lea	edi, DWORD PTR [esi+eax]
	mov	eax, DWORD PTR [ebx+20]
	add	eax, eax
	add	eax, eax
	lea	edx, DWORD PTR [esi+ecx]
	sub	eax, edx
	add	eax, ecx
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	lea	ebp, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN33@Growmap
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN33@Growmap:

; 1240 : 		if (_Myboff <= _Count)

	mov	edx, DWORD PTR __Myboff$[esp+24]
	mov	eax, DWORD PTR __Count$[esp+20]
	cmp	edx, eax
	ja	SHORT $LN3@Growmap

; 1241 : 			{	// increment greater than offset of initial block
; 1242 : 			_Myptr = _STDEXT unchecked_uninitialized_copy(_Map,
; 1243 : 				_Map + _Myboff, _Myptr, this->_Almap);	// copy rest of old

	mov	eax, DWORD PTR [ebx+16]
	sar	esi, 2
	lea	ecx, DWORD PTR [esi*4]
	lea	edi, DWORD PTR [ecx+ebp]
	test	esi, esi
	jbe	SHORT $LN48@Growmap
	push	ecx
	push	eax
	push	ecx
	push	ebp
	call	DWORD PTR __imp__memmove_s
	mov	edx, DWORD PTR __Myboff$[esp+40]
	add	esp, 16					; 00000010H
$LN48@Growmap:

; 1244 : 			_STDEXT unchecked_uninitialized_fill_n(_Myptr, _Count - _Myboff,
; 1245 : 				(_Tptr)0, this->_Almap);	// clear suffix of new

	mov	ecx, DWORD PTR __Count$[esp+20]
	sub	ecx, edx
	je	SHORT $LN69@Growmap
	mov	edx, DWORD PTR __Myboff$[esp+24]
	xor	eax, eax
	rep stosd
$LN69@Growmap:

; 1246 : 			_STDEXT unchecked_uninitialized_fill_n(_Newmap, _Myboff,
; 1247 : 				(_Tptr)0, this->_Almap);	// clear prefix of new

	mov	ebp, DWORD PTR __Newmap$[esp+24]
	test	edx, edx
	jbe	SHORT $LN141@Growmap
	mov	ecx, edx
	mov	edi, ebp

; 1248 : 			}
; 1249 : 		else

	jmp	SHORT $LN158@Growmap
$LN3@Growmap:

; 1250 : 			{	// increment not greater than offset of initial block
; 1251 : 			_STDEXT unchecked_uninitialized_copy(_Map,
; 1252 : 				_Map + _Count, _Myptr, this->_Almap);	// copy more old

	mov	ecx, DWORD PTR [ebx+16]
	lea	edi, DWORD PTR [eax*4]
	mov	eax, edi
	sar	eax, 2
	test	eax, eax
	jbe	SHORT $LN105@Growmap
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	ebp
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN105@Growmap:

; 1253 : 			_Myptr = _STDEXT unchecked_uninitialized_copy(_Map + _Count,
; 1254 : 				_Map + _Myboff, _Newmap, this->_Almap);	// copy rest of old

	mov	eax, DWORD PTR [ebx+16]
	mov	ebp, DWORD PTR __Newmap$[esp+24]
	lea	ecx, DWORD PTR [edi+eax]
	sub	esi, ecx
	add	esi, eax
	sar	esi, 2
	lea	eax, DWORD PTR [esi*4]
	lea	edi, DWORD PTR [eax+ebp]
	test	esi, esi
	jbe	SHORT $LN120@Growmap
	push	eax
	push	ecx
	push	eax
	push	ebp
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN120@Growmap:

; 1255 : 			_STDEXT unchecked_uninitialized_fill_n(_Myptr, _Count,
; 1256 : 				(_Tptr)0, this->_Almap);	// clear rest to initial block

	mov	ecx, DWORD PTR __Count$[esp+20]
	test	ecx, ecx
	jbe	SHORT $LN141@Growmap
$LN158@Growmap:
	xor	eax, eax
	rep stosd
$LN141@Growmap:

; 1257 : 			}
; 1258 : 
; 1259 : 		_Destroy_range(_Map + _Myboff, _Map + _Mapsize, this->_Almap);
; 1260 : 		if (_Map)

	mov	eax, DWORD PTR [ebx+16]
	test	eax, eax
	je	SHORT $LN144@Growmap

; 1261 : 			this->_Almap.deallocate(_Map, _Mapsize);	// free storage for old

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN144@Growmap:

; 1262 : 
; 1263 : 		_Map = _Newmap;	// point at new
; 1264 : 		_Mapsize += _Count;

	mov	edx, DWORD PTR __Count$[esp+20]
	add	DWORD PTR [ebx+20], edx

; 1265 : 		}

	pop	edi
	pop	esi
	mov	DWORD PTR [ebx+16], ebp
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	4
$LN157@Growmap:
?_Growmap@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z ENDP ; std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Growmap
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Deque_val@_WV?$allocator@_W@std@@@std@@IAE@V?$allocator@_W@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Deque_val@_WV?$allocator@_W@std@@@std@@IAE@V?$allocator@_W@1@@Z PROC ; std::_Deque_val<wchar_t,std::allocator<wchar_t> >::_Deque_val<wchar_t,std::allocator<wchar_t> >, COMDAT
; _this$ = esi

; 500  : 		{	// construct allocator and base from _Al

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN13@Deque_val@2
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 501  : 		}

	mov	eax, esi
	ret	4

; 500  : 		{	// construct allocator and base from _Al

$LN13@Deque_val@2:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 501  : 		}

	mov	eax, esi
	ret	4
??0?$_Deque_val@_WV?$allocator@_W@std@@@std@@IAE@V?$allocator@_W@1@@Z ENDP ; std::_Deque_val<wchar_t,std::allocator<wchar_t> >::_Deque_val<wchar_t,std::allocator<wchar_t> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Growmap@?$deque@_WV?$allocator@_W@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Newmap$ = -4						; size = 4
__Count$ = 8						; size = 4
_this$ = 8						; size = 4
?_Growmap@?$deque@_WV?$allocator@_W@std@@@std@@IAEXI@Z PROC ; std::deque<wchar_t,std::allocator<wchar_t> >::_Growmap, COMDAT

; 1225 : 		{	// grow map by _Count pointers

	push	ecx
	push	ebx
	mov	ebx, DWORD PTR _this$[esp+4]

; 1226 : 		if (max_size() / _DEQUESIZ - _Mapsize < _Count)

	mov	eax, DWORD PTR [ebx+20]
	mov	ecx, 268435455				; 0fffffffH
	sub	ecx, eax
	mov	DWORD PTR __Count$[esp+4], 1
	cmp	ecx, 1
	jae	SHORT $LN6@Growmap@2

; 1227 : 			_Xlen();	// result too long

	call	?_Xlen@?$deque@_WV?$allocator@_W@std@@@std@@KAXXZ ; std::deque<wchar_t,std::allocator<wchar_t> >::_Xlen
$LN159@Growmap@2:
$LN6@Growmap@2:

; 1228 : 
; 1229 : 		size_type _Inc = _Mapsize / 2;	// try to grow by 50%

	mov	ecx, eax
	shr	ecx, 1

; 1230 : 		if (_Inc < _DEQUEMAPSIZ)

	cmp	ecx, 8
	jae	SHORT $LN5@Growmap@2

; 1231 : 			_Inc = _DEQUEMAPSIZ;

	mov	ecx, 8

; 1232 : 		if (_Count < _Inc && _Mapsize <= max_size() / _DEQUESIZ - _Inc)

	jmp	SHORT $LN152@Growmap@2
$LN5@Growmap@2:
	cmp	ecx, 1
	jbe	SHORT $LN4@Growmap@2
$LN152@Growmap@2:
	mov	edx, 268435455				; 0fffffffH
	sub	edx, ecx
	cmp	eax, edx
	ja	SHORT $LN4@Growmap@2

; 1233 : 			_Count = _Inc;

	mov	DWORD PTR __Count$[esp+4], ecx
$LN4@Growmap@2:

; 1234 : 		size_type _Myboff = _Myoff / _DEQUESIZ;
; 1235 : 		_Mapptr _Newmap = this->_Almap.allocate(_Mapsize + _Count);

	mov	ecx, DWORD PTR __Count$[esp+4]
	push	ebp
	mov	ebp, DWORD PTR [ebx+24]
	push	esi
	push	edi
	add	ecx, eax
	shr	ebp, 3
	call	?allocate@?$allocator@PA_W@std@@QAEPAPA_WI@Z ; std::allocator<wchar_t *>::allocate

; 1236 : 		_Mapptr _Myptr = _Newmap + _Myboff;
; 1237 : 
; 1238 : 		_Myptr = _STDEXT unchecked_uninitialized_copy(_Map + _Myboff,
; 1239 : 			_Map + _Mapsize, _Myptr, this->_Almap);	// copy initial to end

	mov	ecx, DWORD PTR [ebx+16]
	mov	DWORD PTR __Newmap$[esp+20], eax
	lea	esi, DWORD PTR [ebp*4]
	lea	edi, DWORD PTR [esi+eax]
	mov	eax, DWORD PTR [ebx+20]
	add	eax, eax
	add	eax, eax
	lea	edx, DWORD PTR [esi+ecx]
	sub	eax, edx
	add	eax, ecx
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	add	edi, ecx
	test	eax, eax
	jbe	SHORT $LN153@Growmap@2
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Newmap$[esp+28]
	push	ecx
	lea	eax, DWORD PTR [esi+edx]
	push	eax
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN153@Growmap@2:

; 1240 : 		if (_Myboff <= _Count)

	mov	eax, DWORD PTR __Count$[esp+16]
	cmp	ebp, eax
	ja	SHORT $LN3@Growmap@2

; 1241 : 			{	// increment greater than offset of initial block
; 1242 : 			_Myptr = _STDEXT unchecked_uninitialized_copy(_Map,
; 1243 : 				_Map + _Myboff, _Myptr, this->_Almap);	// copy rest of old

	mov	eax, DWORD PTR [ebx+16]
	sar	esi, 2
	mov	ecx, esi
	lea	edx, DWORD PTR [ecx*4]
	lea	esi, DWORD PTR [edx+edi]
	test	ecx, ecx
	jbe	SHORT $LN48@Growmap@2
	push	edx
	push	eax
	push	edx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN48@Growmap@2:

; 1244 : 			_STDEXT unchecked_uninitialized_fill_n(_Myptr, _Count - _Myboff,
; 1245 : 				(_Tptr)0, this->_Almap);	// clear suffix of new

	mov	ecx, DWORD PTR __Count$[esp+16]
	sub	ecx, ebp
	je	SHORT $LN69@Growmap@2
	xor	eax, eax
	mov	edi, esi
	rep stosd
$LN69@Growmap@2:

; 1246 : 			_STDEXT unchecked_uninitialized_fill_n(_Newmap, _Myboff,
; 1247 : 				(_Tptr)0, this->_Almap);	// clear prefix of new

	test	ebp, ebp
	jbe	SHORT $LN155@Growmap@2
	mov	edi, DWORD PTR __Newmap$[esp+20]
	mov	ecx, ebp

; 1248 : 			}
; 1249 : 		else

	jmp	SHORT $LN158@Growmap@2
$LN3@Growmap@2:

; 1250 : 			{	// increment not greater than offset of initial block
; 1251 : 			_STDEXT unchecked_uninitialized_copy(_Map,
; 1252 : 				_Map + _Count, _Myptr, this->_Almap);	// copy more old

	mov	ecx, DWORD PTR [ebx+16]
	lea	ebp, DWORD PTR [eax*4]
	mov	eax, ebp
	sar	eax, 2
	test	eax, eax
	jbe	SHORT $LN154@Growmap@2
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN154@Growmap@2:

; 1253 : 			_Myptr = _STDEXT unchecked_uninitialized_copy(_Map + _Count,
; 1254 : 				_Map + _Myboff, _Newmap, this->_Almap);	// copy rest of old

	mov	eax, DWORD PTR [ebx+16]
	mov	edx, DWORD PTR __Newmap$[esp+20]
	lea	ecx, DWORD PTR [eax+ebp]
	sub	esi, ecx
	add	esi, eax
	sar	esi, 2
	lea	eax, DWORD PTR [esi*4]
	lea	edi, DWORD PTR [eax+edx]
	test	esi, esi
	jbe	SHORT $LN120@Growmap@2
	push	eax
	push	ecx
	push	eax
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN120@Growmap@2:

; 1255 : 			_STDEXT unchecked_uninitialized_fill_n(_Myptr, _Count,
; 1256 : 				(_Tptr)0, this->_Almap);	// clear rest to initial block

	mov	ecx, DWORD PTR __Count$[esp+16]
	test	ecx, ecx
	jbe	SHORT $LN155@Growmap@2
$LN158@Growmap@2:
	xor	eax, eax
	rep stosd
$LN155@Growmap@2:

; 1257 : 			}
; 1258 : 
; 1259 : 		_Destroy_range(_Map + _Myboff, _Map + _Mapsize, this->_Almap);
; 1260 : 		if (_Map)

	mov	eax, DWORD PTR [ebx+16]
	pop	edi
	pop	esi
	pop	ebp
	test	eax, eax
	je	SHORT $LN144@Growmap@2

; 1261 : 			this->_Almap.deallocate(_Map, _Mapsize);	// free storage for old

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN144@Growmap@2:

; 1262 : 
; 1263 : 		_Map = _Newmap;	// point at new

	mov	eax, DWORD PTR __Newmap$[esp+8]

; 1264 : 		_Mapsize += _Count;

	mov	ecx, DWORD PTR __Count$[esp+4]
	add	DWORD PTR [ebx+20], ecx
	mov	DWORD PTR [ebx+16], eax
	pop	ebx

; 1265 : 		}

	pop	ecx
	ret	4
$LN157@Growmap@2:
?_Growmap@?$deque@_WV?$allocator@_W@std@@@std@@IAEXI@Z ENDP ; std::deque<wchar_t,std::allocator<wchar_t> >::_Growmap
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Tidy@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXXZ PROC ; std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Tidy, COMDAT
; _this$ = esi

; 1268 : 		{	// free all storage

	push	ebx

; 1269 : 		while (!empty())

	xor	ebx, ebx
	push	edi
	cmp	DWORD PTR [esi+28], ebx
	je	SHORT $LN5@Tidy
	or	edi, -1
	npad	4
$LL6@Tidy:

; 1270 : 			pop_back();

	mov	eax, DWORD PTR [esi+28]
	cmp	eax, ebx
	je	SHORT $LN11@Tidy
	mov	ecx, DWORD PTR [esi+24]
	lea	eax, DWORD PTR [eax+ecx-1]
	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, eax
	ja	SHORT $LN12@Tidy
	sub	eax, ecx
$LN12@Tidy:
	mov	edx, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [edx+eax*4]
	call	DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
	add	DWORD PTR [esi+28], edi
	jne	SHORT $LN11@Tidy
	mov	DWORD PTR [esi+24], ebx
$LN11@Tidy:

; 1269 : 		while (!empty())

	cmp	DWORD PTR [esi+28], ebx
	jne	SHORT $LL6@Tidy
$LN5@Tidy:

; 1271 : 		for (size_type _Count = _Mapsize; 0 < _Count; )

	mov	edi, DWORD PTR [esi+20]
	cmp	edi, ebx
	jbe	SHORT $LN3@Tidy
$LL4@Tidy:
	mov	eax, DWORD PTR [esi+16]

; 1272 : 			{	// free storage for a block and destroy pointer
; 1273 : 			if (*(_Map + --_Count) != 0)

	dec	edi
	cmp	DWORD PTR [eax+edi*4], ebx
	lea	eax, DWORD PTR [eax+edi*4]
	je	SHORT $LN25@Tidy

; 1274 : 				this->_Alval.deallocate(*(_Map + _Count), _DEQUESIZ);

	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN25@Tidy:

; 1271 : 		for (size_type _Count = _Mapsize; 0 < _Count; )

	cmp	edi, ebx
	ja	SHORT $LL4@Tidy
$LN3@Tidy:

; 1275 : 			this->_Almap.destroy(_Map + _Count);
; 1276 : 			}
; 1277 : 
; 1278 : 		if (_Map)

	mov	eax, DWORD PTR [esi+16]
	cmp	eax, ebx
	je	SHORT $LN32@Tidy

; 1279 : 			this->_Almap.deallocate(_Map, _Mapsize);	// free storage for map

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN32@Tidy:
	pop	edi

; 1280 : 		_Mapsize = 0;
; 1281 : 		_Map = 0;

	mov	DWORD PTR [esi+16], ebx
	mov	DWORD PTR [esi+20], ebx
	pop	ebx

; 1282 : 		}

	ret	0
?_Tidy@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXXZ ENDP ; std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Tidy
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\new
xdata$x	SEGMENT
__unwindtable$?push_back@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?push_back@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z$0
__ehfuncinfo$?push_back@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?push_back@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\deque
xdata$x	ENDS
;	COMDAT ?push_back@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Val$ = 8						; size = 4
?push_back@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z PROC ; std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::push_back, COMDAT
; _this$ = esi

; 843  : 		{	// insert element at end

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?push_back@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z
	push	eax
	mov	DWORD PTR fs:0, esp

; 844  : 
; 845  :  #if _HAS_ITERATOR_DEBUGGING
; 846  : 		this->_Orphan_all();
; 847  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 848  : 
; 849  : 		if ((_Myoff + _Mysize) % _DEQUESIZ == 0
; 850  : 			&& _Mapsize <= (_Mysize + _DEQUESIZ) / _DEQUESIZ)

	mov	eax, DWORD PTR [esi+28]
	inc	eax
	push	edi
	cmp	DWORD PTR [esi+20], eax
	ja	SHORT $LN3@push_back

; 851  : 			_Growmap(1);

	push	esi
	call	?_Growmap@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXI@Z ; std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Growmap
$LN3@push_back:

; 852  : 		size_type _Newoff = _Myoff + _Mysize;

	mov	edi, DWORD PTR [esi+24]
	add	edi, DWORD PTR [esi+28]

; 853  : 		size_type _Block = _Newoff / _DEQUESIZ;
; 854  : 		if (_Mapsize <= _Block)

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, edi
	ja	SHORT $LN2@push_back

; 855  : 			_Block -= _Mapsize;

	sub	edi, eax
$LN2@push_back:

; 856  : 		if (_Map[_Block] == 0)

	mov	ecx, DWORD PTR [esi+16]
	cmp	DWORD PTR [ecx+edi*4], 0
	jne	SHORT $LN1@push_back

; 857  : 			_Map[_Block] = this->_Alval.allocate(_DEQUESIZ);

	push	28					; 0000001cH
	call	??2@YAPAXI@Z				; operator new
	mov	edx, DWORD PTR [esi+16]
	add	esp, 4
	mov	DWORD PTR [edx+edi*4], eax
$LN1@push_back:

; 858  : 		this->_Alval.construct(_Map[_Block] + _Newoff % _DEQUESIZ, _Val);

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax+edi*4]
	mov	DWORD PTR __$EHRec$[esp+24], 0
	test	ecx, ecx
	je	SHORT $LN26@push_back
	mov	edx, DWORD PTR __Val$[esp+12]
	push	edx
	call	DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
$LN26@push_back:

; 859  : 		++_Mysize;
; 860  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	inc	DWORD PTR [esi+28]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	add	esp, 12					; 0000000cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?push_back@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z$0:
	jmp	??3@YAXPAX0@Z				; operator delete
__ehhandler$?push_back@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z:
	mov	eax, OFFSET __ehfuncinfo$?push_back@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?push_back@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z ENDP ; std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?back@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ
_TEXT	SEGMENT
__Tmp$158231 = -12					; size = 8
$T158000 = -12						; size = 8
?back@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ PROC ; std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::back, COMDAT
; _this$ = eax

; 789  : 		{	// return last element of mutable sequence

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp

; 790  : 		return (*(end() - 1));

	mov	ebp, DWORD PTR __imp___invalid_parameter_noinfo
	push	esi
	push	edi
	mov	edi, eax
	mov	eax, DWORD PTR [edi+24]
	mov	esi, DWORD PTR [edi+28]
	add	esi, eax
	cmp	eax, esi
	jbe	SHORT $LN9@back
	call	ebp
$LN9@back:
	mov	edi, DWORD PTR [edi]
	mov	ebx, edi
	mov	DWORD PTR __Tmp$158231[esp+32], esi
	test	edi, edi
	jne	SHORT $LN64@back
	call	ebp
	xor	eax, eax
	xor	ecx, ecx
$LN53@back:
	mov	ecx, DWORD PTR [ecx+28]
	add	ecx, DWORD PTR [eax+24]
	dec	esi
	cmp	esi, ecx
	ja	SHORT $LN32@back
	test	edi, edi
	je	SHORT $LN58@back
	mov	edi, DWORD PTR [edi]
	jmp	SHORT $LN59@back
$LN64@back:
	mov	eax, DWORD PTR [edi]
	mov	ecx, eax
	jmp	SHORT $LN53@back
$LN58@back:
	xor	edi, edi
$LN59@back:
	cmp	esi, DWORD PTR [edi+24]
	jae	SHORT $LN31@back
$LN32@back:
	call	ebp
$LN31@back:
	lea	eax, DWORD PTR $T158000[esp+28]
	mov	DWORD PTR $T158000[esp+28], ebx
	mov	DWORD PTR $T158000[esp+32], esi
	call	??D?$_Deque_const_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@$00@std@@QBEABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@XZ ; std::_Deque_const_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,1>::operator*

; 791  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	0
?back@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ENDP ; std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::back
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ PROC ; std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >, COMDAT
; _this$ = esi

; 554  : 		{	// construct empty deque

	push	4
	call	??2@YAPAXI@Z				; operator new
	xor	ecx, ecx
	add	esp, 4
	cmp	eax, ecx
	je	SHORT $LN18@deque
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+16], ecx
	mov	DWORD PTR [esi+20], ecx
	mov	DWORD PTR [esi+24], ecx
	mov	DWORD PTR [esi+28], ecx

; 555  : 		}

	mov	eax, esi
	ret	0

; 554  : 		{	// construct empty deque

$LN18@deque:
	xor	eax, eax
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+16], ecx
	mov	DWORD PTR [esi+20], ecx
	mov	DWORD PTR [esi+24], ecx
	mov	DWORD PTR [esi+28], ecx

; 555  : 		}

	mov	eax, esi
	ret	0
??0?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ ENDP ; std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Tidy@?$deque@_WV?$allocator@_W@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$deque@_WV?$allocator@_W@std@@@std@@IAEXXZ PROC	; std::deque<wchar_t,std::allocator<wchar_t> >::_Tidy, COMDAT
; _this$ = esi

; 1268 : 		{	// free all storage

	push	ebx

; 1269 : 		while (!empty())

	xor	ebx, ebx
	push	edi
	cmp	DWORD PTR [esi+28], ebx
	je	SHORT $LN5@Tidy@2
	or	edi, -1
	npad	4
$LL6@Tidy@2:

; 1270 : 			pop_back();

	mov	eax, DWORD PTR [esi+28]
	cmp	eax, ebx
	je	SHORT $LN11@Tidy@2
	mov	ecx, DWORD PTR [esi+24]
	mov	edx, DWORD PTR [esi+20]
	lea	ecx, DWORD PTR [eax+ecx-1]
	mov	eax, ecx
	shr	eax, 3
	cmp	edx, eax
	ja	SHORT $LN12@Tidy@2
	sub	eax, edx
$LN12@Tidy@2:
	mov	edx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [edx+eax*4]
	and	ecx, 7
	lea	ecx, DWORD PTR [eax+ecx*2]
	push	ecx
	lea	ecx, DWORD PTR [esi+12]
	call	DWORD PTR __imp_?destroy@?$allocator@_W@std@@QAEXPA_W@Z
	add	DWORD PTR [esi+28], edi
	jne	SHORT $LN11@Tidy@2
	mov	DWORD PTR [esi+24], ebx
$LN11@Tidy@2:

; 1269 : 		while (!empty())

	cmp	DWORD PTR [esi+28], ebx
	jne	SHORT $LL6@Tidy@2
$LN5@Tidy@2:

; 1271 : 		for (size_type _Count = _Mapsize; 0 < _Count; )

	mov	edi, DWORD PTR [esi+20]
	cmp	edi, ebx
	jbe	SHORT $LN3@Tidy@2
$LL4@Tidy@2:
	mov	edx, DWORD PTR [esi+16]

; 1272 : 			{	// free storage for a block and destroy pointer
; 1273 : 			if (*(_Map + --_Count) != 0)

	dec	edi
	cmp	DWORD PTR [edx+edi*4], ebx
	lea	eax, DWORD PTR [edx+edi*4]
	je	SHORT $LN2@Tidy@2

; 1274 : 				this->_Alval.deallocate(*(_Map + _Count), _DEQUESIZ);

	mov	eax, DWORD PTR [eax]
	push	8
	push	eax
	lea	ecx, DWORD PTR [esi+12]
	call	DWORD PTR __imp_?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
$LN2@Tidy@2:

; 1271 : 		for (size_type _Count = _Mapsize; 0 < _Count; )

	cmp	edi, ebx
	ja	SHORT $LL4@Tidy@2
$LN3@Tidy@2:

; 1275 : 			this->_Almap.destroy(_Map + _Count);
; 1276 : 			}
; 1277 : 
; 1278 : 		if (_Map)

	mov	eax, DWORD PTR [esi+16]
	cmp	eax, ebx
	je	SHORT $LN23@Tidy@2

; 1279 : 			this->_Almap.deallocate(_Map, _Mapsize);	// free storage for map

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN23@Tidy@2:
	pop	edi

; 1280 : 		_Mapsize = 0;
; 1281 : 		_Map = 0;

	mov	DWORD PTR [esi+16], ebx
	mov	DWORD PTR [esi+20], ebx
	pop	ebx

; 1282 : 		}

	ret	0
?_Tidy@?$deque@_WV?$allocator@_W@std@@@std@@IAEXXZ ENDP	; std::deque<wchar_t,std::allocator<wchar_t> >::_Tidy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?push_back@?$deque@_WV?$allocator@_W@std@@@std@@QAEXAB_W@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$deque@_WV?$allocator@_W@std@@@std@@QAEXAB_W@Z PROC ; std::deque<wchar_t,std::allocator<wchar_t> >::push_back, COMDAT
; _this$ = esi

; 844  : 
; 845  :  #if _HAS_ITERATOR_DEBUGGING
; 846  : 		this->_Orphan_all();
; 847  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 848  : 
; 849  : 		if ((_Myoff + _Mysize) % _DEQUESIZ == 0
; 850  : 			&& _Mapsize <= (_Mysize + _DEQUESIZ) / _DEQUESIZ)

	mov	eax, DWORD PTR [esi+28]
	mov	ecx, DWORD PTR [esi+24]
	add	ecx, eax
	test	cl, 7
	jne	SHORT $LN3@push_back@2
	add	eax, 8
	shr	eax, 3
	cmp	DWORD PTR [esi+20], eax
	ja	SHORT $LN3@push_back@2

; 851  : 			_Growmap(1);

	push	esi
	call	?_Growmap@?$deque@_WV?$allocator@_W@std@@@std@@IAEXI@Z ; std::deque<wchar_t,std::allocator<wchar_t> >::_Growmap
$LN3@push_back@2:

; 852  : 		size_type _Newoff = _Myoff + _Mysize;
; 853  : 		size_type _Block = _Newoff / _DEQUESIZ;
; 854  : 		if (_Mapsize <= _Block)

	mov	eax, DWORD PTR [esi+20]
	push	ebx
	push	edi
	mov	edi, DWORD PTR [esi+24]
	add	edi, DWORD PTR [esi+28]
	mov	ebx, edi
	shr	ebx, 3
	cmp	eax, ebx
	ja	SHORT $LN2@push_back@2

; 855  : 			_Block -= _Mapsize;

	sub	ebx, eax
$LN2@push_back@2:

; 856  : 		if (_Map[_Block] == 0)

	mov	edx, DWORD PTR [esi+16]
	cmp	DWORD PTR [edx+ebx*4], 0
	jne	SHORT $LN1@push_back@2

; 857  : 			_Map[_Block] = this->_Alval.allocate(_DEQUESIZ);

	push	8
	lea	ecx, DWORD PTR [esi+12]
	call	DWORD PTR __imp_?allocate@?$allocator@_W@std@@QAEPA_WI@Z
	mov	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [ecx+ebx*4], eax
$LN1@push_back@2:

; 858  : 		this->_Alval.construct(_Map[_Block] + _Newoff % _DEQUESIZ, _Val);

	mov	eax, DWORD PTR [esi+16]
	mov	edx, DWORD PTR __Val$[esp+4]
	mov	ecx, DWORD PTR [eax+ebx*4]
	push	edx
	and	edi, 7
	lea	edx, DWORD PTR [ecx+edi*2]
	push	edx
	lea	ecx, DWORD PTR [esi+12]
	call	DWORD PTR __imp_?construct@?$allocator@_W@std@@QAEXPA_WAB_W@Z

; 859  : 		++_Mysize;

	inc	DWORD PTR [esi+28]
	pop	edi
	pop	ebx

; 860  : 		}

	ret	4
?push_back@?$deque@_WV?$allocator@_W@std@@@std@@QAEXAB_W@Z ENDP ; std::deque<wchar_t,std::allocator<wchar_t> >::push_back
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?back@?$deque@_WV?$allocator@_W@std@@@std@@QAEAA_WXZ
_TEXT	SEGMENT
__Tmp$158708 = -8					; size = 8
$T158478 = -8						; size = 8
?back@?$deque@_WV?$allocator@_W@std@@@std@@QAEAA_WXZ PROC ; std::deque<wchar_t,std::allocator<wchar_t> >::back, COMDAT
; _this$ = eax

; 789  : 		{	// return last element of mutable sequence

	sub	esp, 8
	push	ebx
	push	ebp

; 790  : 		return (*(end() - 1));

	mov	ebp, DWORD PTR __imp___invalid_parameter_noinfo
	push	esi
	push	edi
	mov	edi, eax
	mov	eax, DWORD PTR [edi+24]
	mov	esi, DWORD PTR [edi+28]
	add	esi, eax
	cmp	eax, esi
	jbe	SHORT $LN9@back@2
	call	ebp
$LN9@back@2:
	mov	edi, DWORD PTR [edi]
	mov	ebx, edi
	mov	DWORD PTR __Tmp$158708[esp+28], esi
	test	edi, edi
	jne	SHORT $LN64@back@2
	call	ebp
	xor	eax, eax
	xor	ecx, ecx
$LN53@back@2:
	mov	ecx, DWORD PTR [ecx+28]
	add	ecx, DWORD PTR [eax+24]
	dec	esi
	cmp	esi, ecx
	ja	SHORT $LN32@back@2
	test	edi, edi
	je	SHORT $LN58@back@2
	mov	edi, DWORD PTR [edi]
	jmp	SHORT $LN59@back@2
$LN64@back@2:
	mov	eax, DWORD PTR [edi]
	mov	ecx, eax
	jmp	SHORT $LN53@back@2
$LN58@back@2:
	xor	edi, edi
$LN59@back@2:
	cmp	esi, DWORD PTR [edi+24]
	jae	SHORT $LN31@back@2
$LN32@back@2:
	call	ebp
$LN31@back@2:
	lea	eax, DWORD PTR $T158478[esp+24]
	mov	DWORD PTR $T158478[esp+24], ebx
	mov	DWORD PTR $T158478[esp+28], esi
	call	??D?$_Deque_const_iterator@_WV?$allocator@_W@std@@$00@std@@QBEAB_WXZ ; std::_Deque_const_iterator<wchar_t,std::allocator<wchar_t>,1>::operator*
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 791  : 		}

	add	esp, 8
	ret	0
?back@?$deque@_WV?$allocator@_W@std@@@std@@QAEAA_WXZ ENDP ; std::deque<wchar_t,std::allocator<wchar_t> >::back
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$deque@_WV?$allocator@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$deque@_WV?$allocator@_W@std@@@std@@QAE@XZ PROC	; std::deque<wchar_t,std::allocator<wchar_t> >::deque<wchar_t,std::allocator<wchar_t> >, COMDAT
; _this$ = esi

; 554  : 		{	// construct empty deque

	push	4
	call	??2@YAPAXI@Z				; operator new
	xor	ecx, ecx
	add	esp, 4
	cmp	eax, ecx
	je	SHORT $LN18@deque@2
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+16], ecx
	mov	DWORD PTR [esi+20], ecx
	mov	DWORD PTR [esi+24], ecx
	mov	DWORD PTR [esi+28], ecx

; 555  : 		}

	mov	eax, esi
	ret	0

; 554  : 		{	// construct empty deque

$LN18@deque@2:
	xor	eax, eax
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+16], ecx
	mov	DWORD PTR [esi+20], ecx
	mov	DWORD PTR [esi+24], ecx
	mov	DWORD PTR [esi+28], ecx

; 555  : 		}

	mov	eax, esi
	ret	0
??0?$deque@_WV?$allocator@_W@std@@@std@@QAE@XZ ENDP	; std::deque<wchar_t,std::allocator<wchar_t> >::deque<wchar_t,std::allocator<wchar_t> >
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ$0
__ehfuncinfo$??1?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\deque
xdata$x	ENDS
;	COMDAT ??1?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ PROC ; std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >, COMDAT

; 640  : 		{	// destroy the deque

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, DWORD PTR _this$[esp+12]
	mov	DWORD PTR __$EHRec$[esp+24], 0

; 641  : 		_Tidy();

	call	?_Tidy@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXXZ ; std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Tidy

; 642  : 		}

	mov	eax, DWORD PTR [esi]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	add	esp, 4
	mov	DWORD PTR fs:0, ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Deque_val@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ
__ehhandler$??1?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ ENDP ; std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\stack
;	COMDAT ?push@?$stack@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@@std@@QAEXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z
_TEXT	SEGMENT
?push@?$stack@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@@std@@QAEXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z PROC ; std::stack<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::push, COMDAT
; _this$ = esi
; __Val$ = eax

; 57   : 		{	// insert element at end

	push	ecx

; 58   : 		c.push_back(_Val);

	push	eax
	call	?push_back@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z ; std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::push_back
	pop	ecx

; 59   : 		}

	ret	0
?push@?$stack@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@@std@@QAEXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z ENDP ; std::stack<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::push
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?top@?$stack@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@@std@@QAEAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ
_TEXT	SEGMENT
?top@?$stack@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@@std@@QAEAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ PROC ; std::stack<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::top, COMDAT
; _this$ = eax

; 47   : 		{	// return last element of mutable stack

	push	ecx

; 48   : 		return (c.back());

	call	?back@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ; std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::back
	pop	ecx

; 49   : 		}

	ret	0
?top@?$stack@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@@std@@QAEAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ ENDP ; std::stack<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::top
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$stack@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$stack@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@@std@@QAE@XZ PROC ; std::stack<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::stack<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >, COMDAT
; _this$ = esi

; 28   : 		{	// construct with empty container

	push	4
	call	??2@YAPAXI@Z				; operator new
	xor	ecx, ecx
	add	esp, 4
	cmp	eax, ecx
	je	SHORT $LN21@stack
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+16], ecx
	mov	DWORD PTR [esi+20], ecx
	mov	DWORD PTR [esi+24], ecx
	mov	DWORD PTR [esi+28], ecx

; 29   : 		}

	mov	eax, esi
	ret	0

; 28   : 		{	// construct with empty container

$LN21@stack:
	xor	eax, eax
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+16], ecx
	mov	DWORD PTR [esi+20], ecx
	mov	DWORD PTR [esi+24], ecx
	mov	DWORD PTR [esi+28], ecx

; 29   : 		}

	mov	eax, esi
	ret	0
??0?$stack@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@@std@@QAE@XZ ENDP ; std::stack<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::stack<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$deque@_WV?$allocator@_W@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$deque@_WV?$allocator@_W@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$deque@_WV?$allocator@_W@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$deque@_WV?$allocator@_W@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\deque
xdata$x	ENDS
;	COMDAT ??1?$deque@_WV?$allocator@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1?$deque@_WV?$allocator@_W@std@@@std@@QAE@XZ PROC	; std::deque<wchar_t,std::allocator<wchar_t> >::~deque<wchar_t,std::allocator<wchar_t> >, COMDAT

; 640  : 		{	// destroy the deque

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$deque@_WV?$allocator@_W@std@@@std@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, DWORD PTR _this$[esp+12]
	mov	DWORD PTR __$EHRec$[esp+24], 0

; 641  : 		_Tidy();

	call	?_Tidy@?$deque@_WV?$allocator@_W@std@@@std@@IAEXXZ ; std::deque<wchar_t,std::allocator<wchar_t> >::_Tidy

; 642  : 		}

	mov	eax, DWORD PTR [esi]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	add	esp, 4
	mov	DWORD PTR fs:0, ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$deque@_WV?$allocator@_W@std@@@std@@QAE@XZ$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Deque_val@_WV?$allocator@_W@std@@@std@@QAE@XZ
__ehhandler$??1?$deque@_WV?$allocator@_W@std@@@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$deque@_WV?$allocator@_W@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$deque@_WV?$allocator@_W@std@@@std@@QAE@XZ ENDP	; std::deque<wchar_t,std::allocator<wchar_t> >::~deque<wchar_t,std::allocator<wchar_t> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio 9.0\vc\include\stack
;	COMDAT ?push@?$stack@_WV?$deque@_WV?$allocator@_W@std@@@std@@@std@@QAEXAB_W@Z
_TEXT	SEGMENT
?push@?$stack@_WV?$deque@_WV?$allocator@_W@std@@@std@@@std@@QAEXAB_W@Z PROC ; std::stack<wchar_t,std::deque<wchar_t,std::allocator<wchar_t> > >::push, COMDAT
; _this$ = esi
; __Val$ = eax

; 58   : 		c.push_back(_Val);

	push	eax
	call	?push_back@?$deque@_WV?$allocator@_W@std@@@std@@QAEXAB_W@Z ; std::deque<wchar_t,std::allocator<wchar_t> >::push_back

; 59   : 		}

	ret	0
?push@?$stack@_WV?$deque@_WV?$allocator@_W@std@@@std@@@std@@QAEXAB_W@Z ENDP ; std::stack<wchar_t,std::deque<wchar_t,std::allocator<wchar_t> > >::push
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?top@?$stack@_WV?$deque@_WV?$allocator@_W@std@@@std@@@std@@QAEAA_WXZ
_TEXT	SEGMENT
?top@?$stack@_WV?$deque@_WV?$allocator@_W@std@@@std@@@std@@QAEAA_WXZ PROC ; std::stack<wchar_t,std::deque<wchar_t,std::allocator<wchar_t> > >::top, COMDAT
; _this$ = eax

; 48   : 		return (c.back());

	jmp	?back@?$deque@_WV?$allocator@_W@std@@@std@@QAEAA_WXZ ; std::deque<wchar_t,std::allocator<wchar_t> >::back
?top@?$stack@_WV?$deque@_WV?$allocator@_W@std@@@std@@@std@@QAEAA_WXZ ENDP ; std::stack<wchar_t,std::deque<wchar_t,std::allocator<wchar_t> > >::top
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$stack@_WV?$deque@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$stack@_WV?$deque@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ PROC ; std::stack<wchar_t,std::deque<wchar_t,std::allocator<wchar_t> > >::stack<wchar_t,std::deque<wchar_t,std::allocator<wchar_t> > >, COMDAT
; _this$ = esi

; 28   : 		{	// construct with empty container

	push	4
	call	??2@YAPAXI@Z				; operator new
	xor	ecx, ecx
	add	esp, 4
	cmp	eax, ecx
	je	SHORT $LN21@stack@2
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+16], ecx
	mov	DWORD PTR [esi+20], ecx
	mov	DWORD PTR [esi+24], ecx
	mov	DWORD PTR [esi+28], ecx

; 29   : 		}

	mov	eax, esi
	ret	0

; 28   : 		{	// construct with empty container

$LN21@stack@2:
	xor	eax, eax
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+16], ecx
	mov	DWORD PTR [esi+20], ecx
	mov	DWORD PTR [esi+24], ecx
	mov	DWORD PTR [esi+28], ecx

; 29   : 		}

	mov	eax, esi
	ret	0
??0?$stack@_WV?$deque@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ENDP ; std::stack<wchar_t,std::deque<wchar_t,std::allocator<wchar_t> > >::stack<wchar_t,std::deque<wchar_t,std::allocator<wchar_t> > >
_TEXT	ENDS
PUBLIC	?AppendEscapedString@SignatureReader@@AAEXPB_W@Z ; SignatureReader::AppendEscapedString
; Function compile flags: /Ogtpy
; File c:\local\sharpdevelop_3.2.0.5777_source\src\addins\misc\profiler\hook\profilermetadata.cpp
;	COMDAT ?AppendEscapedString@SignatureReader@@AAEXPB_W@Z
_TEXT	SEGMENT
?AppendEscapedString@SignatureReader@@AAEXPB_W@Z PROC	; SignatureReader::AppendEscapedString, COMDAT
; _this$ = ecx
; _input$ = eax

; 595  : {	

	push	ecx
	push	esi
	mov	esi, eax

; 596  : 	for (const WCHAR *ptr = input; *ptr != 0; ptr++) {

	cmp	WORD PTR [esi], 0
	push	edi
	je	SHORT $LN3@AppendEsca
	mov	edi, ecx
	add	edi, 4260				; 000010a4H
$LL5@AppendEsca:

; 597  : 		WCHAR c = *ptr;

	movzx	eax, WORD PTR [esi]

; 598  : 		if (c == '"')

	cmp	ax, 34					; 00000022H
	jne	SHORT $LN2@AppendEsca

; 599  : 			this->output << "\"\"";

	push	edi
	call	??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PBD@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
	add	esp, 4

; 600  : 		else

	jmp	SHORT $LN4@AppendEsca
$LN2@AppendEsca:

; 601  : 			this->output << c;

	push	eax
	push	edi
	call	??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@_W@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
	add	esp, 8
$LN4@AppendEsca:
	add	esi, 2
	cmp	WORD PTR [esi], 0
	jne	SHORT $LL5@AppendEsca
$LN3@AppendEsca:

; 602  : 	}
; 603  : }

	pop	edi
	pop	esi
	pop	ecx
	ret	0
?AppendEscapedString@SignatureReader@@AAEXPB_W@Z ENDP	; SignatureReader::AppendEscapedString
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$stack@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$stack@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@@std@@QAE@XZ$1
__ehfuncinfo$??1?$stack@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$stack@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??1?$stack@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1?$stack@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@@std@@QAE@XZ PROC ; std::stack<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::~stack<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >, COMDAT
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$stack@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@@std@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, DWORD PTR _this$[esp+12]
	mov	DWORD PTR __$EHRec$[esp+24], 0
	call	?_Tidy@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXXZ ; std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Tidy
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	add	esp, 4
	mov	DWORD PTR fs:0, ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$stack@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@@std@@QAE@XZ$1:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Deque_val@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ
__ehhandler$??1?$stack@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$stack@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$stack@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@@std@@QAE@XZ ENDP ; std::stack<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >::~stack<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$stack@_WV?$deque@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$stack@_WV?$deque@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$1
__ehfuncinfo$??1?$stack@_WV?$deque@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$stack@_WV?$deque@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??1?$stack@_WV?$deque@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1?$stack@_WV?$deque@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ PROC ; std::stack<wchar_t,std::deque<wchar_t,std::allocator<wchar_t> > >::~stack<wchar_t,std::deque<wchar_t,std::allocator<wchar_t> > >, COMDAT
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$stack@_WV?$deque@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, DWORD PTR _this$[esp+12]
	mov	DWORD PTR __$EHRec$[esp+24], 0
	call	?_Tidy@?$deque@_WV?$allocator@_W@std@@@std@@IAEXXZ ; std::deque<wchar_t,std::allocator<wchar_t> >::_Tidy
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	add	esp, 4
	mov	DWORD PTR fs:0, ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$stack@_WV?$deque@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$1:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Deque_val@_WV?$allocator@_W@std@@@std@@QAE@XZ
__ehhandler$??1?$stack@_WV?$deque@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$stack@_WV?$deque@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$stack@_WV?$deque@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ENDP ; std::stack<wchar_t,std::deque<wchar_t,std::allocator<wchar_t> > >::~stack<wchar_t,std::deque<wchar_t,std::allocator<wchar_t> > >
PUBLIC	??0SignatureReader@@QAE@PAUICorProfilerInfo@@@Z	; SignatureReader::SignatureReader
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??0SignatureReader@@QAE@PAUICorProfilerInfo@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0SignatureReader@@QAE@PAUICorProfilerInfo@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0SignatureReader@@QAE@PAUICorProfilerInfo@@@Z$1
__ehfuncinfo$??0SignatureReader@@QAE@PAUICorProfilerInfo@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0SignatureReader@@QAE@PAUICorProfilerInfo@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\local\sharpdevelop_3.2.0.5777_source\src\addins\misc\profiler\hook\profilermetadata.cpp
xdata$x	ENDS
;	COMDAT ??0SignatureReader@@QAE@PAUICorProfilerInfo@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_profilerInfo$ = 12					; size = 4
??0SignatureReader@@QAE@PAUICorProfilerInfo@@@Z PROC	; SignatureReader::SignatureReader, COMDAT

; 15   : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??0SignatureReader@@QAE@PAUICorProfilerInfo@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _this$[esp+20]
	push	1
	push	2
	lea	ecx, DWORD PTR [edi+28]
	call	DWORD PTR __imp_??0?$basic_ostringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z
	push	1
	xor	ebx, ebx
	push	2
	lea	ecx, DWORD PTR [edi+4260]
	mov	DWORD PTR __$EHRec$[esp+40], ebx
	call	DWORD PTR __imp_??0?$basic_ostringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@H@Z
	push	4
	mov	BYTE PTR __$EHRec$[esp+36], 1
	lea	esi, DWORD PTR [edi+4388]
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	cmp	eax, ebx
	je	SHORT $LN26@SignatureR
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN27@SignatureR
$LN26@SignatureR:
	xor	eax, eax
$LN27@SignatureR:

; 16   : 	this->profilerInfo = profilerInfo;
; 17   : }

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR _profilerInfo$[esp+20]
	mov	DWORD PTR [esi+16], ebx
	mov	DWORD PTR [esi+20], ebx
	mov	DWORD PTR [esi+24], ebx
	mov	DWORD PTR [esi+28], ebx
	mov	DWORD PTR [edi], eax
	mov	eax, edi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0SignatureReader@@QAE@PAUICorProfilerInfo@@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp-4]
	add	ecx, 28					; 0000001cH
	jmp	DWORD PTR __imp_??_D?$basic_ostringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ
__unwindfunclet$??0SignatureReader@@QAE@PAUICorProfilerInfo@@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp-4]
	add	ecx, 4260				; 000010a4H
	jmp	DWORD PTR __imp_??_D?$basic_ostringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ
__ehhandler$??0SignatureReader@@QAE@PAUICorProfilerInfo@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0SignatureReader@@QAE@PAUICorProfilerInfo@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0SignatureReader@@QAE@PAUICorProfilerInfo@@@Z ENDP	; SignatureReader::SignatureReader
; Function compile flags: /Ogtpy
; File c:\program files\microsoft sdks\windows\v7.0\include\cor.h
;	COMDAT ?CorSigUncompressToken@@YAKPBEPAI@Z
_TEXT	SEGMENT
_dwSizeOfData$159851 = -8				; size = 4
_tk$ = -4						; size = 4
_pToken$ = 8						; size = 4
?CorSigUncompressToken@@YAKPBEPAI@Z PROC		; CorSigUncompressToken, COMDAT
; _pData$ = edx

; 2394 : {

	sub	esp, 8
	push	edi

; 2395 :     ULONG       cb; 
; 2396 :     mdToken     tk; 
; 2397 :     mdToken     tkType; 
; 2398 : 
; 2399 :     cb = CorSigUncompressData(pData, (ULONG *)&tk); 

	lea	eax, DWORD PTR _tk$[esp+12]
	push	eax
	lea	edi, DWORD PTR _dwSizeOfData$159851[esp+16]
	mov	DWORD PTR _dwSizeOfData$159851[esp+16], 0
	call	?CorSigUncompressData@@YAJPBEKPAK1@Z	; CorSigUncompressData
	add	esp, 4
	pop	edi
	test	eax, eax
	jge	SHORT $LN3@CorSigUnco@3
	or	eax, -1
	jmp	SHORT $LN4@CorSigUnco@3
$LN3@CorSigUnco@3:
	mov	eax, DWORD PTR _dwSizeOfData$159851[esp+8]
$LN4@CorSigUnco@3:

; 2400 :     tkType = g_tkCorEncodeToken[tk & 0x3];  

	mov	ecx, DWORD PTR _tk$[esp+8]
	mov	edx, ecx
	and	edx, 3

; 2401 :     tk = TokenFromRid(tk >> 2, tkType); 

	shr	ecx, 2
	or	ecx, DWORD PTR ?g_tkCorEncodeToken@@3QBIB[edx*4]

; 2402 :     *pToken = tk;   

	mov	edx, DWORD PTR _pToken$[esp+4]
	mov	DWORD PTR [edx], ecx

; 2403 :     return cb;  
; 2404 : }

	add	esp, 8
	ret	0
?CorSigUncompressToken@@YAKPBEPAI@Z ENDP		; CorSigUncompressToken
PUBLIC	?AppendEscapedString@SignatureReader@@AAEXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; SignatureReader::AppendEscapedString
; Function compile flags: /Ogtpy
; File c:\local\sharpdevelop_3.2.0.5777_source\src\addins\misc\profiler\hook\profilermetadata.cpp
;	COMDAT ?AppendEscapedString@SignatureReader@@AAEXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
_TEXT	SEGMENT
?AppendEscapedString@SignatureReader@@AAEXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z PROC ; SignatureReader::AppendEscapedString, COMDAT
; _this$ = ecx
; _input_string$ = eax

; 606  : {

	push	ecx

; 607  : 	AppendEscapedString(input_string.c_str());

	cmp	DWORD PTR [eax+24], 8
	jb	SHORT $LN7@AppendEsca@2
	mov	eax, DWORD PTR [eax+4]
	call	?AppendEscapedString@SignatureReader@@AAEXPB_W@Z ; SignatureReader::AppendEscapedString
	pop	ecx

; 608  : }

	ret	0

; 607  : 	AppendEscapedString(input_string.c_str());

$LN7@AppendEsca@2:
	add	eax, 4
	call	?AppendEscapedString@SignatureReader@@AAEXPB_W@Z ; SignatureReader::AppendEscapedString
	pop	ecx

; 608  : }

	ret	0
?AppendEscapedString@SignatureReader@@AAEXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ENDP ; SignatureReader::AppendEscapedString
_TEXT	ENDS
PUBLIC	?ReadArrayType@SignatureReader@@AAE_NE@Z	; SignatureReader::ReadArrayType
PUBLIC	?ReadType@SignatureReader@@AAE_NE@Z		; SignatureReader::ReadType
; Function compile flags: /Ogtpy
;	COMDAT ?ReadType@SignatureReader@@AAE_NE@Z
_TEXT	SEGMENT
_number$132808 = -2056					; size = 4
_genArgCount$132795 = -2056				; size = 4
_tmp2$132784 = -2056					; size = 4
_tmp2$132771 = -2056					; size = 4
_token$132760 = -2056					; size = 4
_length$132762 = -2052					; size = 4
_zName$132761 = -2048					; size = 2048
_type$ = 8						; size = 1
?ReadType@SignatureReader@@AAE_NE@Z PROC		; SignatureReader::ReadType, COMDAT
; _this$ = ecx

; 226  :     /*
; 227  :     Type ::= ( BOOLEAN | CHAR | I1 | U1 | U2 | U2 | I4 | U4 | I8 | U8 | R4 | R8 | I | U |
; 228  :                     | VALUETYPE TypeDefOrRefEncoded
; 229  :                     | CLASS TypeDefOrRefEncoded
; 230  :                     | STRING 
; 231  :                     | OBJECT
; 232  :                     | PTR CustomMod* VOID
; 233  :                     | PTR CustomMod* Type
; 234  :                     | FNPTR MethodDefSig
; 235  :                     | FNPTR MethodRefSig
; 236  :                     | ARRAY Type ArrayShape
; 237  :                     | SZARRAY CustomMod* Type
; 238  :                     | GENERICINST (CLASS | VALUETYPE) TypeDefOrRefEncoded GenArgCount Type *
; 239  :                     | VAR Number
; 240  :                     | MVAR Number
; 241  :     */
; 242  : 
; 243  : 	switch (type) {

	movzx	eax, BYTE PTR _type$[esp-4]
	sub	esp, 2056				; 00000808H
	push	ebx
	push	ebp
	push	esi
	dec	eax
	push	edi
	mov	esi, ecx
	cmp	eax, 31					; 0000001fH
	ja	$LN1@ReadType
	jmp	DWORD PTR $LN195@ReadType[eax*4]
$LN48@ReadType:

; 244  : 		case ELEMENT_TYPE_VOID:
; 245  : 			this->output << L"void";

	push	OFFSET ??_C@_19HFFGOOIH@?$AAv?$AAo?$AAi?$AAd?$AA?$AA@

; 246  : 			break;

	jmp	$LN189@ReadType
$LN47@ReadType:

; 247  : 		case ELEMENT_TYPE_BOOLEAN:
; 248  : 			this->output << L"bool";

	push	OFFSET ??_C@_19EIPOAEOH@?$AAb?$AAo?$AAo?$AAl?$AA?$AA@

; 249  : 			break;

	jmp	$LN189@ReadType
$LN46@ReadType:

; 250  : 		case ELEMENT_TYPE_CHAR:
; 251  : 			this->output << L"char"; 

	push	OFFSET ??_C@_19CHDFCHBM@?$AAc?$AAh?$AAa?$AAr?$AA?$AA@

; 252  : 			break;

	jmp	$LN189@ReadType
$LN45@ReadType:

; 253  : 		case ELEMENT_TYPE_I:
; 254  : 			this->output << L"IntPtr";

	push	OFFSET ??_C@_1O@PLMJMAHL@?$AAI?$AAn?$AAt?$AAP?$AAt?$AAr?$AA?$AA@

; 255  : 			break;

	jmp	$LN189@ReadType
$LN44@ReadType:

; 256  : 		case ELEMENT_TYPE_U:
; 257  : 			this->output << L"UIntPtr";

	push	OFFSET ??_C@_1BA@HEMJOHJL@?$AAU?$AAI?$AAn?$AAt?$AAP?$AAt?$AAr?$AA?$AA@

; 258  : 			break;

	jmp	$LN189@ReadType
$LN43@ReadType:

; 259  : 		case ELEMENT_TYPE_I1:
; 260  : 			this->output << L"sbyte"; 

	push	OFFSET ??_C@_1M@CNLIHMIE@?$AAs?$AAb?$AAy?$AAt?$AAe?$AA?$AA@

; 261  : 			break;

	jmp	$LN189@ReadType
$LN42@ReadType:

; 262  : 		case ELEMENT_TYPE_U1:
; 263  : 			this->output << L"byte"; 

	push	OFFSET ??_C@_19OGDDIBJJ@?$AAb?$AAy?$AAt?$AAe?$AA?$AA@

; 264  : 			break;

	jmp	$LN189@ReadType
$LN41@ReadType:

; 265  : 		case ELEMENT_TYPE_I2:
; 266  : 			this->output << L"short"; 

	push	OFFSET ??_C@_1M@LOLCAHAG@?$AAs?$AAh?$AAo?$AAr?$AAt?$AA?$AA@

; 267  : 			break;

	jmp	$LN189@ReadType
$LN40@ReadType:

; 268  : 		case ELEMENT_TYPE_U2:
; 269  : 			this->output << L"ushort"; 

	push	OFFSET ??_C@_1O@HKBAGFIG@?$AAu?$AAs?$AAh?$AAo?$AAr?$AAt?$AA?$AA@

; 270  : 			break;

	jmp	$LN189@ReadType
$LN39@ReadType:

; 271  : 		case ELEMENT_TYPE_I4:
; 272  : 			this->output << L"int"; 

	push	OFFSET ??_C@_17IDNKMCOH@?$AAi?$AAn?$AAt?$AA?$AA@

; 273  : 			break;

	jmp	$LN189@ReadType
$LN38@ReadType:

; 274  : 		case ELEMENT_TYPE_U4:
; 275  : 			this->output << L"uint"; 

	push	OFFSET ??_C@_19BFBCDLCE@?$AAu?$AAi?$AAn?$AAt?$AA?$AA@

; 276  : 			break;

	jmp	$LN189@ReadType
$LN37@ReadType:

; 277  : 		case ELEMENT_TYPE_I8:
; 278  : 			this->output << L"long"; 

	push	OFFSET ??_C@_19EKGKGAPA@?$AAl?$AAo?$AAn?$AAg?$AA?$AA@

; 279  : 			break;

	jmp	$LN189@ReadType
$LN36@ReadType:

; 280  : 		case ELEMENT_TYPE_U8:
; 281  : 			this->output << L"ulong"; 

	push	OFFSET ??_C@_1M@GONMDIAN@?$AAu?$AAl?$AAo?$AAn?$AAg?$AA?$AA@

; 282  : 			break;

	jmp	$LN189@ReadType
$LN35@ReadType:

; 283  : 		case ELEMENT_TYPE_R4:
; 284  : 			this->output << L"float"; 

	push	OFFSET ??_C@_1M@KGKAENKF@?$AAf?$AAl?$AAo?$AAa?$AAt?$AA?$AA@

; 285  : 			break;

	jmp	$LN189@ReadType
$LN34@ReadType:

; 286  : 		case ELEMENT_TYPE_R8:
; 287  : 			this->output << L"double"; 

	push	OFFSET ??_C@_1O@BAJDFEHJ@?$AAd?$AAo?$AAu?$AAb?$AAl?$AAe?$AA?$AA@

; 288  : 			break;

	jmp	$LN189@ReadType
$LN33@ReadType:

; 289  : 		case ELEMENT_TYPE_STRING:
; 290  : 			this->output << L"string"; 

	push	OFFSET ??_C@_1O@DGBBOFII@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?$AA@

; 291  : 			break;

	jmp	$LN189@ReadType
$LN32@ReadType:

; 292  : 		case ELEMENT_TYPE_OBJECT:
; 293  : 			this->output << L"object";

	push	OFFSET ??_C@_1O@EJHDPCJ@?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$AA@

; 294  : 			break;

	jmp	$LN189@ReadType
$LN31@ReadType:

; 295  : 		case ELEMENT_TYPE_CLASS:
; 296  : 		case ELEMENT_TYPE_VALUETYPE:
; 297  : 			mdToken token;
; 298  : 			WCHAR zName[1024];
; 299  : 			ULONG length;
; 300  : 			CorSigUncompressToken(this->data, &token);

	mov	edx, DWORD PTR [esi+12]
	lea	eax, DWORD PTR _token$132760[esp+2072]
	push	eax
	call	?CorSigUncompressToken@@YAKPBEPAI@Z	; CorSigUncompressToken

; 301  : 			HRESULT	hr;
; 302  : 			hr = this->metaData->GetTypeRefProps(token, nullptr, zName, 1024, &length);

	mov	eax, DWORD PTR [esi+4]
	mov	edi, DWORD PTR _token$132760[esp+2076]
	mov	ecx, DWORD PTR [eax]
	add	esp, 4
	lea	edx, DWORD PTR _length$132762[esp+2072]
	push	edx
	push	1024					; 00000400H
	lea	edx, DWORD PTR _zName$132761[esp+2080]
	push	edx
	push	0
	push	edi
	push	eax
	mov	eax, DWORD PTR [ecx+56]
	call	eax

; 303  : 			hr = this->metaData->GetTypeDefProps(token, zName, 1024, &length, nullptr, nullptr);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	0
	push	0
	lea	edx, DWORD PTR _length$132762[esp+2080]
	push	edx
	push	1024					; 00000400H
	lea	edx, DWORD PTR _zName$132761[esp+2088]
	push	edx
	push	edi
	push	eax
	mov	eax, DWORD PTR [ecx+48]
	call	eax

; 304  : 			if (SUCCEEDED(hr) && length > 0)

	test	eax, eax
	jl	SHORT $LN30@ReadType
	cmp	DWORD PTR _length$132762[esp+2072], 0
	jbe	SHORT $LN30@ReadType

; 305  : 				AppendEscapedString(zName);

	lea	eax, DWORD PTR _zName$132761[esp+2072]
	mov	ecx, esi
	call	?AppendEscapedString@SignatureReader@@AAEXPB_W@Z ; SignatureReader::AppendEscapedString

; 306  : 			else {

	jmp	SHORT $LN27@ReadType
$LN30@ReadType:

; 307  : 				hr = this->metaData->GetTypeRefProps(token, nullptr, zName, 1024, &length);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR _length$132762[esp+2072]
	push	edx
	push	1024					; 00000400H
	lea	edx, DWORD PTR _zName$132761[esp+2080]
	push	edx
	push	0
	push	edi
	push	eax
	mov	eax, DWORD PTR [ecx+56]
	call	eax

; 308  : 				hr = this->metaData->GetTypeDefProps(token, zName, 1024, &length, nullptr, nullptr);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	0
	push	0
	lea	edx, DWORD PTR _length$132762[esp+2080]
	push	edx
	push	1024					; 00000400H
	lea	edx, DWORD PTR _zName$132761[esp+2088]
	push	edx
	push	edi
	push	eax
	mov	eax, DWORD PTR [ecx+48]
	call	eax

; 309  : 				if (SUCCEEDED(hr) && length > 0)

	test	eax, eax
	jl	SHORT $LN28@ReadType
	cmp	DWORD PTR _length$132762[esp+2072], 0
	jbe	SHORT $LN28@ReadType

; 310  : 					AppendEscapedString(zName);

	lea	eax, DWORD PTR _zName$132761[esp+2072]
	mov	ecx, esi
	call	?AppendEscapedString@SignatureReader@@AAEXPB_W@Z ; SignatureReader::AppendEscapedString

; 311  : 				else

	jmp	SHORT $LN27@ReadType
$LN28@ReadType:

; 312  : 					this->output << L"?";

	lea	ecx, DWORD PTR [esi+4260]
	push	OFFSET ??_C@_13HGPDMIBE@?$AA?$DP?$AA?$AA@
	push	ecx
	call	??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
	add	esp, 8
$LN27@ReadType:

; 313  : 			}
; 314  : 			int tmp2;
; 315  : 			if (!this->ReadCompressedInt(&tmp2))

	lea	edi, DWORD PTR _tmp2$132771[esp+2072]
	mov	eax, esi
	call	?ReadCompressedInt@SignatureReader@@AAE_NPAH@Z ; SignatureReader::ReadCompressedInt
	test	al, al
	jne	$LN49@ReadType

; 329  : 		case ELEMENT_TYPE_PTR:
; 330  : 			if (!this->ReadByte(&type))

$LN160@ReadType:

; 316  : 				return false;

	xor	al, al

; 386  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 2056				; 00000808H
	ret	4
$LN25@ReadType:

; 317  : 			break;
; 318  : 		case ELEMENT_TYPE_ARRAY:
; 319  : 		case ELEMENT_TYPE_SZARRAY:
; 320  : 			this->ReadArrayType(type);

	mov	edx, DWORD PTR _type$[esp+2068]
	push	edx
	call	?ReadArrayType@SignatureReader@@AAE_NE@Z ; SignatureReader::ReadArrayType

; 382  : 			break;
; 383  : 	}
; 384  : 
; 385  : 	return true;

	mov	al, 1

; 386  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 2056				; 00000808H
	ret	4
$LN24@ReadType:

; 321  : 			break;
; 322  : 		case ELEMENT_TYPE_CMOD_OPT:
; 323  : 		case ELEMENT_TYPE_CMOD_REQD:
; 324  : 			this->output << L"cmod";

	push	OFFSET ??_C@_19CAKNEAEL@?$AAc?$AAm?$AAo?$AAd?$AA?$AA@

; 325  : 			break;

	jmp	$LN189@ReadType
$LN23@ReadType:

; 326  : 		case ELEMENT_TYPE_FNPTR:
; 327  : 			this->output << L"fnptr";

	push	OFFSET ??_C@_1M@HBLOHCOL@?$AAf?$AAn?$AAp?$AAt?$AAr?$AA?$AA@

; 328  : 			break;

	jmp	$LN189@ReadType
$LN22@ReadType:

; 329  : 		case ELEMENT_TYPE_PTR:
; 330  : 			if (!this->ReadByte(&type))

	mov	eax, DWORD PTR [esi+12]
	cmp	eax, DWORD PTR [esi+20]
	jae	SHORT $LN160@ReadType
	mov	cl, BYTE PTR [eax]
	inc	eax
	mov	BYTE PTR _type$[esp+2068], cl
	mov	DWORD PTR [esi+12], eax

; 331  : 				return false;
; 332  : 			while (type == ELEMENT_TYPE_CMOD_OPT || type == ELEMENT_TYPE_CMOD_REQD) {

	cmp	cl, 32					; 00000020H
	je	SHORT $LN18@ReadType
	cmp	cl, 31					; 0000001fH
	jne	SHORT $LN19@ReadType
$LN18@ReadType:

; 333  : 				int tmp2;
; 334  : 
; 335  : 				if (!this->ReadCompressedInt(&tmp2))

	lea	edi, DWORD PTR _tmp2$132784[esp+2072]
	mov	eax, esi
	call	?ReadCompressedInt@SignatureReader@@AAE_NPAH@Z ; SignatureReader::ReadCompressedInt
	test	al, al
	je	SHORT $LN160@ReadType

; 336  : 					return false;
; 337  : 
; 338  : 				if (!this->ReadByte(&type))
; 339  : 					return false;
; 340  : 			}

	jmp	SHORT $LN22@ReadType
$LN19@ReadType:

; 341  : 
; 342  : 			ReadType(type);

	mov	eax, DWORD PTR _type$[esp+2068]
	push	eax
	mov	ecx, esi
	call	?ReadType@SignatureReader@@AAE_NE@Z	; SignatureReader::ReadType

; 343  : 			this->output << L"*";

	push	OFFSET ??_C@_13BBDEGPLJ@?$AA?$CK?$AA?$AA@

; 344  : 			break;

	jmp	$LN189@ReadType
$LN15@ReadType:

; 345  : 		case ELEMENT_TYPE_GENERICINST:
; 346  : 			if (!this->ReadByte(&type))

	mov	eax, DWORD PTR [esi+12]
	cmp	eax, DWORD PTR [esi+20]
	jae	$LN160@ReadType

; 347  : 				return false;
; 348  : 			CorSigUncompressToken(this->data, &token);

	lea	ecx, DWORD PTR _token$132760[esp+2072]
	lea	edx, DWORD PTR [eax+1]
	push	ecx
	mov	DWORD PTR [esi+12], edx
	call	?CorSigUncompressToken@@YAKPBEPAI@Z	; CorSigUncompressToken

; 349  : 			// don't ask me why this is necessary, but it doesn't work without either line of these.
; 350  : 			hr = this->metaData->GetTypeRefProps(token, nullptr, zName, 1024, &length);

	mov	eax, DWORD PTR [esi+4]
	mov	edi, DWORD PTR _token$132760[esp+2076]
	mov	edx, DWORD PTR [eax]
	mov	edx, DWORD PTR [edx+56]
	add	esp, 4
	lea	ecx, DWORD PTR _length$132762[esp+2072]
	push	ecx
	push	1024					; 00000400H
	lea	ecx, DWORD PTR _zName$132761[esp+2080]
	push	ecx
	push	0
	push	edi
	push	eax
	call	edx

; 351  : 			hr = this->metaData->GetTypeDefProps(token, zName, 1024, &length, nullptr, nullptr);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	push	0
	push	0
	lea	edx, DWORD PTR _length$132762[esp+2080]
	push	edx
	push	1024					; 00000400H
	lea	edx, DWORD PTR _zName$132761[esp+2088]
	push	edx
	push	edi
	push	eax
	mov	eax, DWORD PTR [ecx+48]
	call	eax

; 352  : 			if (SUCCEEDED(hr) && length > 0)

	test	eax, eax
	jl	SHORT $LN13@ReadType
	cmp	DWORD PTR _length$132762[esp+2072], 0
	jbe	SHORT $LN13@ReadType

; 353  : 				AppendEscapedString(zName);

	lea	eax, DWORD PTR _zName$132761[esp+2072]
	mov	ecx, esi
	call	?AppendEscapedString@SignatureReader@@AAEXPB_W@Z ; SignatureReader::AppendEscapedString

; 354  : 			else

	jmp	SHORT $LN12@ReadType
$LN13@ReadType:

; 355  : 				this->output << L"?";

	lea	ecx, DWORD PTR [esi+4260]
	push	OFFSET ??_C@_13HGPDMIBE@?$AA?$DP?$AA?$AA@
	push	ecx
	call	??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
	add	esp, 8
$LN12@ReadType:

; 356  : 			if (!this->ReadCompressedInt(&tmp2))

	lea	edi, DWORD PTR _tmp2$132771[esp+2072]
	mov	eax, esi
	call	?ReadCompressedInt@SignatureReader@@AAE_NPAH@Z ; SignatureReader::ReadCompressedInt
	test	al, al

; 357  : 				return false;

	je	$LN160@ReadType

; 358  : 			this->output << L"<";

	lea	ebp, DWORD PTR [esi+4260]
	push	OFFSET ??_C@_13GEEGGHPK@?$AA?$DM?$AA?$AA@
	push	ebp
	call	??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
	add	esp, 8

; 359  : 			int genArgCount;
; 360  : 			if (!this->ReadCompressedInt(&genArgCount))

	lea	edi, DWORD PTR _genArgCount$132795[esp+2072]
	mov	eax, esi
	call	?ReadCompressedInt@SignatureReader@@AAE_NPAH@Z ; SignatureReader::ReadCompressedInt
	test	al, al

; 361  : 				return false;

	je	$LN160@ReadType

; 362  : 			for (int i = 0; i < genArgCount; i++) {

	mov	ebx, DWORD PTR _genArgCount$132795[esp+2072]
	xor	edi, edi
	test	ebx, ebx
	jle	SHORT $LN7@ReadType
	npad	10
$LL9@ReadType:

; 363  : 				if (!this->ReadByte(&type))

	mov	eax, DWORD PTR [esi+12]
	cmp	eax, DWORD PTR [esi+20]
	jae	$LN160@ReadType
	mov	dl, BYTE PTR [eax]
	inc	eax
	mov	BYTE PTR _type$[esp+2068], dl
	mov	DWORD PTR [esi+12], eax

; 364  : 					return false;
; 365  : 				this->ReadType(type);

	mov	eax, DWORD PTR _type$[esp+2068]
	push	eax
	mov	ecx, esi
	call	?ReadType@SignatureReader@@AAE_NE@Z	; SignatureReader::ReadType

; 366  : 				if ((i + 1) < genArgCount)

	inc	edi
	cmp	edi, ebx
	jge	SHORT $LN7@ReadType

; 367  : 					this->output << L",";

	push	OFFSET ??_C@_13DEFPDAGF@?$AA?0?$AA?$AA@
	push	ebp
	call	??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
	add	esp, 8
	cmp	edi, ebx
	jl	SHORT $LL9@ReadType
$LN7@ReadType:

; 368  : 			}
; 369  : 			this->output << L">";

	push	OFFSET ??_C@_13MOEPKPHB@?$AA?$DO?$AA?$AA@
	push	ebp

; 370  : 			break;

	jmp	SHORT $LN193@ReadType
$LN4@ReadType:

; 371  : 		case ELEMENT_TYPE_MVAR: // print "!!number"
; 372  : 			this->output << L"!";

	lea	ecx, DWORD PTR [esi+4260]
	push	OFFSET ??_C@_13MGDFOILI@?$AA?$CB?$AA?$AA@
	push	ecx
	call	??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
	add	esp, 8
$LN3@ReadType:

; 373  : 		case ELEMENT_TYPE_VAR: // print "!number"
; 374  : 			this->output << L"!"; 

	lea	ebx, DWORD PTR [esi+4260]
	push	OFFSET ??_C@_13MGDFOILI@?$AA?$CB?$AA?$AA@
	push	ebx
	call	??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
	add	esp, 8

; 375  : 			int number;
; 376  : 			if (!this->ReadCompressedInt(&number))

	lea	edi, DWORD PTR _number$132808[esp+2072]
	mov	eax, esi
	call	?ReadCompressedInt@SignatureReader@@AAE_NPAH@Z ; SignatureReader::ReadCompressedInt
	test	al, al

; 377  : 				return false;

	je	$LN160@ReadType

; 378  : 			this->output << number;

	mov	edx, DWORD PTR _number$132808[esp+2072]
	push	edx
	mov	ecx, ebx
	call	DWORD PTR __imp_??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV01@H@Z

; 382  : 			break;
; 383  : 	}
; 384  : 
; 385  : 	return true;

	mov	al, 1

; 386  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 2056				; 00000808H
	ret	4
$LN1@ReadType:

; 379  : 			break;
; 380  : 		default:
; 381  : 			this->output << L"?";

	push	OFFSET ??_C@_13HGPDMIBE@?$AA?$DP?$AA?$AA@
$LN189@ReadType:
	add	esi, 4260				; 000010a4H
	push	esi
$LN193@ReadType:
	call	??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
	add	esp, 8
$LN49@ReadType:

; 386  : }

	pop	edi
	pop	esi
	pop	ebp
	mov	al, 1
	pop	ebx
	add	esp, 2056				; 00000808H
	ret	4
	npad	3
$LN195@ReadType:
	DD	$LN48@ReadType
	DD	$LN47@ReadType
	DD	$LN46@ReadType
	DD	$LN43@ReadType
	DD	$LN42@ReadType
	DD	$LN41@ReadType
	DD	$LN40@ReadType
	DD	$LN39@ReadType
	DD	$LN38@ReadType
	DD	$LN37@ReadType
	DD	$LN36@ReadType
	DD	$LN35@ReadType
	DD	$LN34@ReadType
	DD	$LN33@ReadType
	DD	$LN22@ReadType
	DD	$LN1@ReadType
	DD	$LN31@ReadType
	DD	$LN31@ReadType
	DD	$LN3@ReadType
	DD	$LN25@ReadType
	DD	$LN15@ReadType
	DD	$LN1@ReadType
	DD	$LN1@ReadType
	DD	$LN45@ReadType
	DD	$LN44@ReadType
	DD	$LN1@ReadType
	DD	$LN23@ReadType
	DD	$LN32@ReadType
	DD	$LN25@ReadType
	DD	$LN4@ReadType
	DD	$LN24@ReadType
	DD	$LN24@ReadType
?ReadType@SignatureReader@@AAE_NE@Z ENDP		; SignatureReader::ReadType
_TEXT	ENDS
PUBLIC	?ReadMethodDefSig@SignatureReader@@AAE_NE@Z	; SignatureReader::ReadMethodDefSig
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ReadMethodDefSig@SignatureReader@@AAE_NE@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ReadMethodDefSig@SignatureReader@@AAE_NE@Z$0
__ehfuncinfo$?ReadMethodDefSig@SignatureReader@@AAE_NE@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ReadMethodDefSig@SignatureReader@@AAE_NE@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?ReadMethodDefSig@SignatureReader@@AAE_NE@Z
_TEXT	SEGMENT
_type$ = -604						; size = 1
tv453 = -600						; size = 4
_tmp2$132686 = -600					; size = 4
_i$132676 = -596					; size = 4
_paramCount$ = -592					; size = 4
_pdwAttr$132696 = -588					; size = 4
_tmp$132659 = -588					; size = 4
_genericParamCount$ = -588				; size = 4
_paramDef$132691 = -584					; size = 4
_name$ = -580						; size = 28
_pcchValue$132695 = -552				; size = 4
_pSequence$132693 = -548				; size = 4
_pdwCPlusTypeFlag$132697 = -544				; size = 4
_ppValue$132698 = -540					; size = 4
_pchName$132694 = -536					; size = 4
_paramName$132692 = -532				; size = 512
__$EHRec$ = -12						; size = 12
_head$ = 8						; size = 1
?ReadMethodDefSig@SignatureReader@@AAE_NE@Z PROC	; SignatureReader::ReadMethodDefSig, COMDAT
; _this$ = esi

; 109  : {

	push	-1
	push	__ehhandler$?ReadMethodDefSig@SignatureReader@@AAE_NE@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 592				; 00000250H
	push	ebx

; 110  : 	// MethodDefSig ::= [[HASTHIS] [EXPLICITTHIS]] (DEFAULT|VARARG|GENERIC GenParamCount) ParamCount RetType Param*
; 111  : 
; 112  : 	int genericParamCount = 0;
; 113  : 	int paramCount = 0;

	xor	ebx, ebx

; 114  : 
; 115  : 	if (head & SIG_GENERIC) {

	test	BYTE PTR _head$[esp+604], 16		; 00000010H
	push	ebp
	push	edi
	mov	DWORD PTR _paramCount$[esp+616], ebx
	je	SHORT $LN35@ReadMethod

; 116  : 		if (!this->ReadCompressedInt(&genericParamCount))

	lea	edi, DWORD PTR _genericParamCount$[esp+616]
	mov	eax, esi
	call	?ReadCompressedInt@SignatureReader@@AAE_NPAH@Z ; SignatureReader::ReadCompressedInt
	test	al, al

; 117  : 			return false;

	je	$LN73@ReadMethod
$LN35@ReadMethod:

; 118  : 	}
; 119  : 
; 120  : 	if (!this->ReadCompressedInt(&paramCount))

	lea	edi, DWORD PTR _paramCount$[esp+616]
$LN102@ReadMethod:
	mov	eax, esi
	call	?ReadCompressedInt@SignatureReader@@AAE_NPAH@Z ; SignatureReader::ReadCompressedInt
	test	al, al

; 121  : 		return false;

	je	$LN73@ReadMethod

; 122  : 	
; 123  : 	// Read Return Type
; 124  : 	// RetType ::= CustomMod* ( VOID | TYPEDBYREF | [BYREF] Type )
; 125  : 
; 126  : 	byte type;
; 127  : 
; 128  : 	if (!this->ReadByte(&type))

	mov	eax, DWORD PTR [esi+12]
	cmp	eax, DWORD PTR [esi+20]
	jae	$LN73@ReadMethod
	mov	cl, BYTE PTR [eax]
	inc	eax
	mov	DWORD PTR [esi+12], eax
	mov	BYTE PTR _type$[esp+616], cl

; 129  : 		return false;
; 130  : 	
; 131  : 	for (;;) {
; 132  : 		if (type != ELEMENT_TYPE_CMOD_OPT && type != ELEMENT_TYPE_CMOD_REQD)

	cmp	cl, 32					; 00000020H
	je	SHORT $LN30@ReadMethod
	cmp	cl, 31					; 0000001fH
	jne	SHORT $LN71@ReadMethod
$LN30@ReadMethod:

; 133  : 			break;
; 134  : 
; 135  : 		int tmp;
; 136  : 
; 137  : 		if (!this->ReadCompressedInt(&tmp)) return false;

	lea	edi, DWORD PTR _tmp$132659[esp+616]

; 140  : 	}

	jmp	SHORT $LN102@ReadMethod
$LN71@ReadMethod:

; 141  : 
; 142  : 	switch (type) {

	movzx	ecx, cl
	sub	ecx, 1
	je	SHORT $LN25@ReadMethod
	sub	ecx, 15					; 0000000fH
	je	SHORT $LN23@ReadMethod
	sub	ecx, 6
	je	SHORT $LN26@ReadMethod

; 152  : 				return false;
; 153  : 		default:
; 154  : 			ReadType(type);

	mov	edx, DWORD PTR _type$[esp+616]
	push	edx
	mov	ecx, esi
	call	?ReadType@SignatureReader@@AAE_NE@Z	; SignatureReader::ReadType
	jmp	SHORT $LN26@ReadMethod
$LN23@ReadMethod:

; 145  : 			break;
; 146  : 		case ELEMENT_TYPE_TYPEDBYREF:
; 147  : 			// ignore
; 148  : 			break;
; 149  : 		case ELEMENT_TYPE_BYREF:
; 150  : 			// ignore
; 151  : 			if (!this->ReadByte(&type))

	cmp	eax, DWORD PTR [esi+20]
	jae	$LN73@ReadMethod
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _type$[esp+616], cl

; 152  : 				return false;
; 153  : 		default:
; 154  : 			ReadType(type);

	mov	edx, DWORD PTR _type$[esp+616]
	inc	eax
	push	edx
	mov	ecx, esi
	mov	DWORD PTR [esi+12], eax
	call	?ReadType@SignatureReader@@AAE_NE@Z	; SignatureReader::ReadType
	jmp	SHORT $LN26@ReadMethod
$LN25@ReadMethod:

; 143  : 		case ELEMENT_TYPE_VOID:
; 144  : 			this->output << L"void";

	lea	eax, DWORD PTR [esi+4260]
	push	OFFSET ??_C@_19HFFGOOIH@?$AAv?$AAo?$AAi?$AAd?$AA?$AA@
	push	eax
	call	??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
	add	esp, 8
$LN26@ReadMethod:

; 155  : 	}
; 156  : 	
; 157  : 	// Append Name
; 158  : 	
; 159  : 	this->output << L" ";

	lea	ebp, DWORD PTR [esi+4260]
	push	OFFSET ??_C@_13HOIJIPNN@?$AA?5?$AA?$AA@
	push	ebp
	call	??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >

; 160  : 	this->output << '"';

	push	ebp
	call	??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@D@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
	add	esp, 12					; 0000000cH

; 161  : 	std::wstring name = className.str();

	lea	ecx, DWORD PTR _name$[esp+616]
	push	ecx
	lea	ecx, DWORD PTR [esi+28]
	call	DWORD PTR __imp_?str@?$basic_ostringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ
	mov	DWORD PTR __$EHRec$[esp+624], ebx

; 162  : 	AppendEscapedString(name);

	cmp	DWORD PTR _name$[esp+640], 8
	mov	eax, DWORD PTR _name$[esp+620]
	jae	SHORT $LN56@ReadMethod
	lea	eax, DWORD PTR _name$[esp+620]
$LN56@ReadMethod:
	mov	ecx, esi
	call	?AppendEscapedString@SignatureReader@@AAEXPB_W@Z ; SignatureReader::AppendEscapedString

; 163  : 	this->output << L".";

	push	OFFSET ??_C@_13JOFGPIOO@?$AA?4?$AA?$AA@
	push	ebp
	call	??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
	add	esp, 8

; 164  : 	AppendEscapedString(szFunction);

	lea	eax, DWORD PTR [esi+156]
	mov	ecx, esi
	call	?AppendEscapedString@SignatureReader@@AAEXPB_W@Z ; SignatureReader::AppendEscapedString

; 165  : 	this->output << '"';

	push	ebp
	call	??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@D@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
	add	esp, 4

; 166  : 	this->output << L" ";

	push	OFFSET ??_C@_13HOIJIPNN@?$AA?5?$AA?$AA@
	push	ebp
	call	??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
	add	esp, 8

; 167  : 
; 168  : 	// Read Parameters
; 169  : 	// Param ::= CustomMod* ( TYPEDBYREF | [BYREF] Type )
; 170  : 
; 171  : 	for (int i = 0; i < paramCount; i++) {

	cmp	DWORD PTR _paramCount$[esp+616], ebx
	mov	DWORD PTR _i$132676[esp+616], ebx
	jle	$LN18@ReadMethod
$LL20@ReadMethod:

; 172  : 		if (!this->ReadByte(&type))

	mov	eax, DWORD PTR [esi+12]
	cmp	eax, DWORD PTR [esi+20]
	jae	SHORT $LN76@ReadMethod
	mov	bl, BYTE PTR [eax]
	inc	eax
	mov	DWORD PTR [esi+12], eax
	mov	BYTE PTR _type$[esp+616], bl

; 174  : 		
; 175  : 		while (type == ELEMENT_TYPE_CMOD_OPT || type == ELEMENT_TYPE_CMOD_REQD) {

	cmp	bl, 32					; 00000020H
	je	SHORT $LN14@ReadMethod
	cmp	bl, 31					; 0000001fH
	jne	SHORT $LN15@ReadMethod
$LN14@ReadMethod:

; 176  : 			int tmp2;
; 177  : 
; 178  : 			if (!this->ReadCompressedInt(&tmp2))

	lea	edi, DWORD PTR _tmp2$132686[esp+616]
	mov	eax, esi
	call	?ReadCompressedInt@SignatureReader@@AAE_NPAH@Z ; SignatureReader::ReadCompressedInt
	test	al, al
	jne	SHORT $LL20@ReadMethod
$LN76@ReadMethod:

; 173  : 			return false;

	lea	ecx, DWORD PTR _name$[esp+616]
	mov	DWORD PTR __$EHRec$[esp+624], -1
	call	DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$LN73@ReadMethod:

; 138  : 
; 139  : 		if (!this->ReadByte(&type)) return false;

	xor	al, al
$LN37@ReadMethod:

; 222  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+616]
	pop	edi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 604				; 0000025cH
	ret	4
$LN15@ReadMethod:

; 179  : 				return false;
; 180  : 
; 181  : 			if (!this->ReadByte(&type))
; 182  : 				return false;
; 183  : 		}
; 184  : 		
; 185  : 		mdParamDef paramDef;
; 186  : 
; 187  : 		WCHAR paramName[256];
; 188  : 		ULONG pSequence, pchName, pcchValue;
; 189  : 		DWORD pdwAttr, pdwCPlusTypeFlag;
; 190  : 		UVCP_CONSTANT ppValue;
; 191  : 
; 192  : 		if (!FAILED(this->metaData->GetParamForMethodIndex(this->methodDefiniton, i + 1, &paramDef))) {

	mov	edx, DWORD PTR _i$132676[esp+616]
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	inc	edx
	mov	DWORD PTR tv453[esp+616], edx
	lea	edx, DWORD PTR _paramDef$132691[esp+616]
	push	edx
	mov	edx, DWORD PTR tv453[esp+620]
	push	edx
	mov	edx, DWORD PTR [esi+8]
	lea	edi, DWORD PTR [esi+8]
	push	edx
	push	eax
	mov	eax, DWORD PTR [ecx+208]
	call	eax
	test	eax, eax
	jl	$LN10@ReadMethod

; 193  : 			if (!FAILED(this->metaData->GetParamProps(paramDef, &this->methodDefiniton, &pSequence, paramName, 256, &pchName, &pdwAttr, &pdwCPlusTypeFlag, &ppValue, &pcchValue))) {

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR _pcchValue$132695[esp+616]
	push	edx
	lea	edx, DWORD PTR _ppValue$132698[esp+620]
	push	edx
	lea	edx, DWORD PTR _pdwCPlusTypeFlag$132697[esp+624]
	push	edx
	lea	edx, DWORD PTR _pdwAttr$132696[esp+628]
	push	edx
	lea	edx, DWORD PTR _pchName$132694[esp+632]
	push	edx
	push	256					; 00000100H
	lea	edx, DWORD PTR _paramName$132692[esp+640]
	push	edx
	lea	edx, DWORD PTR _pSequence$132693[esp+644]
	push	edx
	mov	edx, DWORD PTR _paramDef$132691[esp+648]
	push	edi
	push	edx
	push	eax
	mov	eax, DWORD PTR [ecx+236]
	call	eax
	test	eax, eax
	jl	$LN10@ReadMethod

; 194  : 				this->output << '"';

	push	ebp
	call	??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@D@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
	add	esp, 4

; 195  : 				switch (type) {

	cmp	bl, 16					; 00000010H
	je	SHORT $LN6@ReadMethod
	cmp	bl, 22					; 00000016H
	jne	SHORT $LN2@ReadMethod

; 196  : 					case ELEMENT_TYPE_TYPEDBYREF:
; 197  : 						// ignore
; 198  : 						break;

	jmp	SHORT $LN8@ReadMethod
$LN6@ReadMethod:

; 199  : 					case ELEMENT_TYPE_BYREF:
; 200  : 						if (!this->ReadByte(&type))

	mov	eax, DWORD PTR [esi+12]
	cmp	eax, DWORD PTR [esi+20]
	jae	$LN76@ReadMethod
	mov	cl, BYTE PTR [eax]
	inc	eax

; 201  : 							return false;
; 202  : 						if ((pdwAttr & 0x2) !=  0) // if Bit 1 == 1 -> out

	test	BYTE PTR _pdwAttr$132696[esp+616], 2
	mov	BYTE PTR _type$[esp+616], cl
	mov	DWORD PTR [esi+12], eax
	je	SHORT $LN4@ReadMethod

; 203  : 							this->output << L"out";

	push	OFFSET ??_C@_17CMKEDJDI@?$AAo?$AAu?$AAt?$AA?$AA@

; 204  : 						else

	jmp	SHORT $LN100@ReadMethod
$LN4@ReadMethod:

; 205  : 							this->output << L"ref";

	push	OFFSET ??_C@_17DCNMIAEN@?$AAr?$AAe?$AAf?$AA?$AA@
$LN100@ReadMethod:
	push	ebp
	call	??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
	add	esp, 8

; 206  : 						this->output << L" ";

	push	OFFSET ??_C@_13HOIJIPNN@?$AA?5?$AA?$AA@
	push	ebp
	call	??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
	add	esp, 8
$LN2@ReadMethod:

; 207  : 					default:
; 208  : 						ReadType(type);

	mov	edx, DWORD PTR _type$[esp+616]
	push	edx
	mov	ecx, esi
	call	?ReadType@SignatureReader@@AAE_NE@Z	; SignatureReader::ReadType
$LN8@ReadMethod:

; 209  : 				}
; 210  : 				
; 211  : 				this->output << L" ";

	push	OFFSET ??_C@_13HOIJIPNN@?$AA?5?$AA?$AA@
	push	ebp
	call	??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
	add	esp, 8

; 212  : 				AppendEscapedString(paramName);

	lea	eax, DWORD PTR _paramName$132692[esp+616]
	mov	ecx, esi
	call	?AppendEscapedString@SignatureReader@@AAEXPB_W@Z ; SignatureReader::AppendEscapedString

; 213  : 				this->output << '"';

	push	ebp
	call	??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@D@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
	add	esp, 4
$LN10@ReadMethod:

; 214  : 			}
; 215  : 		}
; 216  : 
; 217  : 		if (i < paramCount - 1)

	mov	edi, DWORD PTR _paramCount$[esp+616]
	lea	eax, DWORD PTR [edi-1]
	cmp	DWORD PTR _i$132676[esp+616], eax
	jge	SHORT $LN19@ReadMethod

; 218  : 			this->output << L" ";

	push	OFFSET ??_C@_13HOIJIPNN@?$AA?5?$AA?$AA@
	push	ebp
	call	??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
	add	esp, 8
$LN19@ReadMethod:
	mov	eax, DWORD PTR tv453[esp+616]
	cmp	eax, edi
	mov	DWORD PTR _i$132676[esp+616], eax
	jl	$LL20@ReadMethod
$LN18@ReadMethod:

; 219  : 	}
; 220  : 
; 221  : 	return true;

	lea	ecx, DWORD PTR _name$[esp+616]
	mov	DWORD PTR __$EHRec$[esp+624], -1
	call	DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
	mov	al, 1
	jmp	$LN37@ReadMethod
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ReadMethodDefSig@SignatureReader@@AAE_NE@Z$0:
	lea	ecx, DWORD PTR _name$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
__ehhandler$?ReadMethodDefSig@SignatureReader@@AAE_NE@Z:
	mov	eax, OFFSET __ehfuncinfo$?ReadMethodDefSig@SignatureReader@@AAE_NE@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ReadMethodDefSig@SignatureReader@@AAE_NE@Z ENDP	; SignatureReader::ReadMethodDefSig
PUBLIC	?Parse@SignatureReader@@AAE_NXZ			; SignatureReader::Parse
; Function compile flags: /Ogtpy
;	COMDAT ?Parse@SignatureReader@@AAE_NXZ
_TEXT	SEGMENT
_elementType$ = -4					; size = 1
?Parse@SignatureReader@@AAE_NXZ PROC			; SignatureReader::Parse, COMDAT
; _this$ = eax

; 87   : {

	sub	esp, 8
	push	esi
	mov	esi, eax

; 88   : 	byte elementType;
; 89   : 	
; 90   : 	if (!this->ReadByte(&elementType))

	mov	eax, DWORD PTR [esi+12]
	cmp	eax, DWORD PTR [esi+20]
	jae	SHORT $LN7@Parse
	mov	cl, BYTE PTR [eax]
	inc	eax
	mov	DWORD PTR [esi+12], eax

; 92   : 
; 93   : 	switch (elementType & 0xF)

	movzx	eax, cl
	and	eax, 15					; 0000000fH
	mov	BYTE PTR _elementType$[esp+12], cl
	cmp	eax, 5
	ja	SHORT $LN2@Parse

; 94   : 	{
; 95   : 		case SIG_METHOD_DEFAULT:  // default calling convention
; 96   : 		case SIG_METHOD_C:        // C calling convention
; 97   : 		case SIG_METHOD_STDCALL:  // Stdcall calling convention
; 98   : 		case SIG_METHOD_THISCALL: // thiscall  calling convention
; 99   : 		case SIG_METHOD_FASTCALL: // fastcall calling convention
; 100  : 		case SIG_METHOD_VARARG:   // vararg calling convention
; 101  : 			return ReadMethodDefSig(elementType);

	mov	eax, DWORD PTR _elementType$[esp+12]
	push	eax
	call	?ReadMethodDefSig@SignatureReader@@AAE_NE@Z ; SignatureReader::ReadMethodDefSig

; 106  : }

	pop	esi
	add	esp, 8
	ret	0

; 88   : 	byte elementType;
; 89   : 	
; 90   : 	if (!this->ReadByte(&elementType))

$LN7@Parse:

; 91   : 		return false;

	xor	al, al

; 106  : }

	pop	esi
	add	esp, 8
	ret	0
$LN2@Parse:

; 102  : 			break;
; 103  : 	}
; 104  : 
; 105  : 	return true;

	mov	al, 1

; 106  : }

	pop	esi
	add	esp, 8
	ret	0
?Parse@SignatureReader@@AAE_NXZ ENDP			; SignatureReader::Parse
_TEXT	ENDS
PUBLIC	?Parse@SignatureReader@@QAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z ; SignatureReader::Parse
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?Parse@SignatureReader@@QAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Parse@SignatureReader@@QAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Parse@SignatureReader@@QAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Parse@SignatureReader@@QAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?Parse@SignatureReader@@QAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Parse@SignatureReader@@QAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z$11
__ehfuncinfo$?Parse@SignatureReader@@QAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?Parse@SignatureReader@@QAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\local\sharpdevelop_3.2.0.5777_source\src\addins\misc\profiler\hook\profilermetadata.cpp
xdata$x	ENDS
;	COMDAT ?Parse@SignatureReader@@QAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z
_TEXT	SEGMENT
_classTypeDef$132141 = -152				; size = 4
_hr$ = -148						; size = 4
tv770 = -144						; size = 4
_funcToken$ = -140					; size = 4
tv768 = -136						; size = 4
$T172802 = -136						; size = 4
_classFlags$132146 = -132				; size = 4
_signature$ = -128					; size = 4
_sigLength$ = -124					; size = 4
_classStack$132583 = -120				; size = 32
_cchClass$132143 = -88					; size = 4
_cchFunction$132142 = -84				; size = 4
$T172795 = -80						; size = 28
$T172794 = -80						; size = 28
__Tmp$173683 = -52					; size = 8
$T172796 = -44						; size = 28
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
_functionID$ = 16					; size = 4
?Parse@SignatureReader@@QAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z PROC ; SignatureReader::Parse, COMDAT

; 20   : {

	push	-1
	push	__ehhandler$?Parse@SignatureReader@@QAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 140				; 0000008cH
	push	ebx
	push	ebp
	push	esi
	push	edi

; 48   : 				if (!SUCCEEDED(hr))

	xor	ebp, ebp
	push	OFFSET ??_C@_11LOCGONAA@?$AA?$AA@
	lea	ecx, DWORD PTR $T172794[esp+172]
	mov	DWORD PTR $T172802[esp+172], ebp
	mov	DWORD PTR _signature$[esp+172], ebp
	mov	DWORD PTR _sigLength$[esp+172], ebp
	call	DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
	mov	esi, DWORD PTR _this$[esp+164]
	lea	ebx, DWORD PTR [esi+4260]
	lea	eax, DWORD PTR $T172794[esp+168]
	push	eax
	mov	ecx, ebx
	mov	DWORD PTR __$EHRec$[esp+180], ebp
	mov	DWORD PTR tv768[esp+172], ebx
	call	DWORD PTR __imp_?str@?$basic_ostringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z
	or	edi, -1
	lea	ecx, DWORD PTR $T172794[esp+168]
	mov	DWORD PTR __$EHRec$[esp+176], edi
	call	DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
	push	OFFSET ??_C@_11LOCGONAA@?$AA?$AA@
	lea	ecx, DWORD PTR $T172795[esp+172]
	call	DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
	lea	edx, DWORD PTR $T172795[esp+168]
	lea	ecx, DWORD PTR [esi+28]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+180], 1
	call	DWORD PTR __imp_?str@?$basic_ostringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z
	lea	ecx, DWORD PTR $T172795[esp+168]
	mov	DWORD PTR __$EHRec$[esp+176], edi
	call	DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR _funcToken$[esp+168]
	push	edx
	mov	edx, DWORD PTR _functionID$[esp+168]
	lea	edi, DWORD PTR [esi+4]
	push	edi
	push	OFFSET _IID_IMetaDataImport
	push	edx
	push	eax
	mov	eax, DWORD PTR [ecx+76]
	mov	DWORD PTR tv770[esp+188], edi
	call	eax
	test	eax, eax
	jl	$LN11@Parse@2
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax]
	push	ebp
	push	ebp
	lea	edx, DWORD PTR _sigLength$[esp+176]
	push	edx
	lea	edx, DWORD PTR _signature$[esp+180]
	push	edx
	push	ebp
	lea	edx, DWORD PTR _cchFunction$132142[esp+188]
	push	edx
	push	1024					; 00000400H
	lea	edx, DWORD PTR [esi+156]
	push	edx
	lea	edx, DWORD PTR _classTypeDef$132141[esp+200]
	push	edx
	mov	edx, DWORD PTR _funcToken$[esp+204]
	push	edx
	push	eax
	mov	eax, DWORD PTR [ecx+120]
	call	eax
	cmp	eax, ebp
	jl	$LN215@Parse@2
	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	cmp	eax, ebp
	je	SHORT $LN40@Parse@2
	lea	ecx, DWORD PTR _classStack$132583[esp+168]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN41@Parse@2

; 21   : 	mdToken funcToken;
; 22   : 
; 23   : 	HRESULT hr = S_OK;
; 24   : 	PCCOR_SIGNATURE signature = 0;
; 25   : 	ULONG sigLength = 0;
; 26   : 
; 27   : 	this->output.str(L"");
; 28   : 	this->className.str(L"");
; 29   : 
; 30   : 	// get the token for the function which we will use to get its name
; 31   : 	hr = profilerInfo->GetTokenAndMetaDataFromFunction(functionID, IID_IMetaDataImport, (LPUNKNOWN *) &metaData, &funcToken);
; 32   : 	if(SUCCEEDED(hr))
; 33   : 	{
; 34   : 		mdTypeDef classTypeDef;
; 35   : 		ULONG cchFunction;
; 36   : 		ULONG cchClass;
; 37   : 
; 38   : 		// retrieve the function properties based on the token
; 39   : 		hr = metaData->GetMethodProps(funcToken, &classTypeDef, szFunction, NAME_BUFFER_SIZE, &cchFunction, 0, &signature, &sigLength, 0, 0);
; 40   : 		if (SUCCEEDED(hr))
; 41   : 		{
; 42   : 			DWORD classFlags;
; 43   : 			std::stack<std::wstring> classStack;

$LN40@Parse@2:
	xor	eax, eax
$LN41@Parse@2:
	mov	DWORD PTR _classStack$132583[esp+168], eax
	mov	DWORD PTR _classStack$132583[esp+184], ebp
	mov	DWORD PTR _classStack$132583[esp+188], ebp
	mov	DWORD PTR _classStack$132583[esp+192], ebp
	mov	DWORD PTR _classStack$132583[esp+196], ebp

; 44   : 			for (;;)
; 45   : 			{
; 46   : 				// get the class name
; 47   : 				hr = metaData->GetTypeDefProps(classTypeDef, szClass, NAME_BUFFER_SIZE, &cchClass, &classFlags, 0);

	push	ebp
	lea	ecx, DWORD PTR _classFlags$132146[esp+172]
	push	ecx
	lea	ecx, DWORD PTR _cchClass$132143[esp+176]
	push	ecx
	mov	ebx, 2
	mov	DWORD PTR __$EHRec$[esp+188], ebx
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR _classTypeDef$132141[esp+180]
	mov	edx, DWORD PTR [eax]
	mov	edx, DWORD PTR [edx+48]
	push	1024					; 00000400H
	lea	edi, DWORD PTR [esi+2204]
	push	edi
	push	ecx
	push	eax
	call	edx

; 48   : 				if (!SUCCEEDED(hr))

	cmp	eax, ebp
	mov	DWORD PTR _hr$[esp+168], eax
	jl	$LN221@Parse@2
	npad	2
$LL9@Parse@2:

; 49   : 					break;
; 50   : 
; 51   : 				classStack.push(std::wstring(szClass));

	push	edi
	lea	ecx, DWORD PTR $T172796[esp+172]
	call	DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
	push	eax
	lea	esi, DWORD PTR _classStack$132583[esp+172]
	mov	BYTE PTR __$EHRec$[esp+180], 3
	call	?push_back@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@@Z ; std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::push_back
	lea	ecx, DWORD PTR $T172796[esp+168]
	mov	BYTE PTR __$EHRec$[esp+176], bl
	call	DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ

; 52   : 
; 53   : 				if (!IsTdNested(classFlags))

	mov	eax, DWORD PTR _classFlags$132146[esp+168]
	and	al, 7
	cmp	al, bl
	jb	SHORT $LN229@Parse@2

; 54   : 					break;
; 55   : 
; 56   : 				hr = metaData->GetNestedClassProps(classTypeDef, &classTypeDef);

	mov	ecx, DWORD PTR tv770[esp+168]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	mov	edx, DWORD PTR [edx+248]
	lea	ecx, DWORD PTR _classTypeDef$132141[esp+168]
	push	ecx
	mov	ecx, DWORD PTR _classTypeDef$132141[esp+172]
	push	ecx
	push	eax
	call	edx

; 57   : 
; 58   : 				if (!SUCCEEDED(hr))

	cmp	eax, ebp
	mov	DWORD PTR _hr$[esp+168], eax
	jl	SHORT $LN229@Parse@2
	mov	eax, DWORD PTR tv770[esp+168]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax]
	push	ebp
	lea	edx, DWORD PTR _classFlags$132146[esp+172]
	push	edx
	lea	edx, DWORD PTR _cchClass$132143[esp+176]
	push	edx
	mov	edx, DWORD PTR _classTypeDef$132141[esp+180]
	push	1024					; 00000400H
	push	edi
	push	edx
	push	eax
	mov	eax, DWORD PTR [ecx+48]
	call	eax
	cmp	eax, ebp
	mov	DWORD PTR _hr$[esp+168], eax
	jge	$LL9@Parse@2
$LN229@Parse@2:

; 48   : 				if (!SUCCEEDED(hr))

	mov	esi, DWORD PTR _this$[esp+164]
$LN221@Parse@2:

; 59   : 					break;
; 60   : 			}
; 61   : 
; 62   : 			while (!classStack.empty()) {

	mov	eax, DWORD PTR _classStack$132583[esp+196]
	cmp	eax, ebp
	je	$LN224@Parse@2
$LL4@Parse@2:

; 63   : 				this->className << classStack.top();

	mov	ecx, DWORD PTR _classStack$132583[esp+192]
	lea	esi, DWORD PTR [ecx+eax]
	cmp	ecx, esi
	jbe	SHORT $LN85@Parse@2
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN85@Parse@2:
	mov	eax, DWORD PTR _classStack$132583[esp+168]
	mov	edi, eax
	mov	ebx, edi
	mov	DWORD PTR __Tmp$173683[esp+172], esi
	cmp	eax, ebp
	jne	SHORT $LN227@Parse@2
	call	DWORD PTR __imp___invalid_parameter_noinfo
	xor	eax, eax
	xor	ecx, ecx
$LN129@Parse@2:
	mov	ecx, DWORD PTR [ecx+28]
	add	ecx, DWORD PTR [eax+24]
	dec	esi
	cmp	esi, ecx
	ja	SHORT $LN108@Parse@2
	cmp	edi, ebp
	je	SHORT $LN134@Parse@2
	mov	edi, DWORD PTR [edi]
	jmp	SHORT $LN135@Parse@2
$LN227@Parse@2:
	mov	eax, DWORD PTR [eax]
	mov	ecx, eax
	jmp	SHORT $LN129@Parse@2
$LN134@Parse@2:
	xor	edi, edi
$LN135@Parse@2:
	cmp	esi, DWORD PTR [edi+24]
	jae	SHORT $LN230@Parse@2
$LN108@Parse@2:
	mov	edi, DWORD PTR __imp___invalid_parameter_noinfo
	call	edi
	jmp	SHORT $LN107@Parse@2
$LN230@Parse@2:
	mov	edi, DWORD PTR __imp___invalid_parameter_noinfo
$LN107@Parse@2:
	cmp	ebx, ebp
	jne	SHORT $LN226@Parse@2
	call	edi
	xor	eax, eax
	xor	ecx, ecx
$LN162@Parse@2:
	mov	edx, DWORD PTR [ecx+28]
	add	edx, DWORD PTR [eax+24]
	cmp	esi, edx
	jb	SHORT $LN143@Parse@2
	call	edi
$LN143@Parse@2:
	cmp	ebx, ebp
	je	SHORT $LN167@Parse@2
	mov	eax, DWORD PTR [ebx]
	jmp	SHORT $LN168@Parse@2
$LN226@Parse@2:
	mov	eax, DWORD PTR [ebx]
	mov	ecx, eax
	jmp	SHORT $LN162@Parse@2
$LN167@Parse@2:
	xor	eax, eax
$LN168@Parse@2:
	cmp	DWORD PTR [eax+20], esi
	ja	SHORT $LN140@Parse@2
	cmp	ebx, ebp
	je	SHORT $LN173@Parse@2
	mov	eax, DWORD PTR [ebx]
	jmp	SHORT $LN174@Parse@2
$LN173@Parse@2:
	xor	eax, eax
$LN174@Parse@2:
	sub	esi, DWORD PTR [eax+20]
$LN140@Parse@2:
	cmp	ebx, ebp
	je	SHORT $LN179@Parse@2
	mov	eax, DWORD PTR [ebx]
	jmp	SHORT $LN180@Parse@2
$LN179@Parse@2:
	xor	eax, eax
$LN180@Parse@2:
	mov	eax, DWORD PTR [eax+16]
	mov	ecx, DWORD PTR [eax+esi*4]
	mov	esi, DWORD PTR _this$[esp+164]
	push	ecx
	add	esi, 28					; 0000001cH
	push	esi
	call	DWORD PTR __imp_??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z

; 64   : 				classStack.pop();

	mov	eax, DWORD PTR _classStack$132583[esp+204]
	add	esp, 8
	cmp	eax, ebp
	je	SHORT $LN231@Parse@2
	mov	edx, DWORD PTR _classStack$132583[esp+192]
	mov	ecx, DWORD PTR _classStack$132583[esp+188]
	lea	eax, DWORD PTR [edx+eax-1]
	cmp	ecx, eax
	ja	SHORT $LN186@Parse@2
	sub	eax, ecx
$LN186@Parse@2:
	mov	ecx, DWORD PTR _classStack$132583[esp+184]
	mov	ecx, DWORD PTR [ecx+eax*4]
	call	DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
	sub	DWORD PTR _classStack$132583[esp+196], 1
	je	SHORT $LN228@Parse@2

; 65   : 				if (!classStack.empty())
; 66   : 					this->className << L"+";

	push	OFFSET ??_C@_13KJIIAINM@?$AA?$CL?$AA?$AA@
	push	esi
	call	??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
	mov	eax, DWORD PTR _classStack$132583[esp+204]
	add	esp, 8
	cmp	eax, ebp
	jne	$LL4@Parse@2

; 59   : 					break;
; 60   : 			}
; 61   : 
; 62   : 			while (!classStack.empty()) {

	jmp	SHORT $LN231@Parse@2
$LN228@Parse@2:

; 64   : 				classStack.pop();

	mov	DWORD PTR _classStack$132583[esp+192], ebp
$LN231@Parse@2:
	mov	esi, DWORD PTR _this$[esp+164]
$LN224@Parse@2:

; 67   : 			}
; 68   : 
; 69   : 			if (SUCCEEDED(hr)) {

	cmp	DWORD PTR _hr$[esp+168], ebp
	jl	SHORT $LN1@Parse@2

; 70   : 				this->data = (unsigned char *)signature;

	mov	eax, DWORD PTR _signature$[esp+168]

; 71   : 				this->dataLength = sigLength;

	mov	ecx, DWORD PTR _sigLength$[esp+168]

; 72   : 				this->startPosition = this->data;
; 73   : 				this->endPosition = this->data + sigLength;
; 74   : 				this->methodDefiniton = funcToken;

	mov	edx, DWORD PTR _funcToken$[esp+168]
	mov	DWORD PTR [esi+24], ecx
	add	ecx, eax
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax

; 75   : 
; 76   : 				this->Parse();

	mov	eax, esi
	mov	DWORD PTR [esi+20], ecx
	mov	DWORD PTR [esi+8], edx
	call	?Parse@SignatureReader@@AAE_NXZ		; SignatureReader::Parse
$LN1@Parse@2:

; 77   : 			}
; 78   : 		}

	lea	esi, DWORD PTR _classStack$132583[esp+168]
	mov	DWORD PTR __$EHRec$[esp+176], 4
	call	?_Tidy@?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@IAEXXZ ; std::deque<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Tidy
	mov	DWORD PTR __$EHRec$[esp+176], -1
	mov	eax, DWORD PTR _classStack$132583[esp+168]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	mov	ebx, DWORD PTR tv768[esp+172]
	mov	edi, DWORD PTR tv770[esp+172]
	add	esp, 4
$LN215@Parse@2:

; 79   : 		// release our reference to the metadata
; 80   : 		metaData->Release();

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	push	eax
	call	edx
$LN11@Parse@2:

; 81   : 	}
; 82   : 
; 83   : 	return this->output.str();

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+164]
	push	esi
	mov	ecx, ebx
	call	DWORD PTR __imp_?str@?$basic_ostringstream@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ

; 84   : }

	mov	ecx, DWORD PTR __$EHRec$[esp+168]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 152				; 00000098H
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Parse@SignatureReader@@QAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z$0:
	lea	ecx, DWORD PTR $T172794[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
__unwindfunclet$?Parse@SignatureReader@@QAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z$1:
	lea	ecx, DWORD PTR $T172795[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
__unwindfunclet$?Parse@SignatureReader@@QAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z$2:
	lea	eax, DWORD PTR _classStack$132583[ebp]
	push	eax
	call	??1?$stack@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$deque@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@2@@std@@QAE@XZ
	ret	0
__unwindfunclet$?Parse@SignatureReader@@QAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z$3:
	lea	ecx, DWORD PTR $T172796[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
__unwindfunclet$?Parse@SignatureReader@@QAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z$11:
	lea	eax, DWORD PTR _classStack$132583[ebp]
	jmp	??1?$_Deque_val@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ
__ehhandler$?Parse@SignatureReader@@QAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z:
	mov	eax, OFFSET __ehfuncinfo$?Parse@SignatureReader@@QAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Parse@SignatureReader@@QAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@I@Z ENDP ; SignatureReader::Parse
PUBLIC	?ReadShapedArray@SignatureReader@@AAE_NE@Z	; SignatureReader::ReadShapedArray
PUBLIC	?ReadSzArray@SignatureReader@@AAE_NE@Z		; SignatureReader::ReadSzArray
; Function compile flags: /Ogtpy
;	COMDAT ?ReadSzArray@SignatureReader@@AAE_NE@Z
_TEXT	SEGMENT
_tmp2$132820 = -4					; size = 4
$T178550 = 8						; size = 2
$T178549 = 8						; size = 2
_type$ = 8						; size = 1
?ReadSzArray@SignatureReader@@AAE_NE@Z PROC		; SignatureReader::ReadSzArray, COMDAT
; _this$ = ecx

; 389  : {

	push	ecx
	push	esi
	mov	esi, ecx

; 390  : 	// type ::= SZARRAY CustomMod* Type
; 391  : 
; 392  : 	if (!this->ReadByte(&type))

	mov	ecx, DWORD PTR [esi+12]
	cmp	ecx, DWORD PTR [esi+20]
	jae	SHORT $LN14@ReadSzArra
	mov	al, BYTE PTR [ecx]
	inc	ecx
	mov	BYTE PTR _type$[esp+4], al
	mov	DWORD PTR [esi+12], ecx
	push	edi
$LL10@ReadSzArra:

; 394  : 	while (type == ELEMENT_TYPE_CMOD_OPT || type == ELEMENT_TYPE_CMOD_REQD) {

	cmp	al, 32					; 00000020H
	je	SHORT $LN8@ReadSzArra
	cmp	al, 31					; 0000001fH
	jne	SHORT $LN9@ReadSzArra
$LN8@ReadSzArra:

; 395  : 		int tmp2;
; 396  : 
; 397  : 		if (!this->ReadCompressedInt(&tmp2))

	lea	edi, DWORD PTR _tmp2$132820[esp+12]
	mov	eax, esi
	call	?ReadCompressedInt@SignatureReader@@AAE_NPAH@Z ; SignatureReader::ReadCompressedInt
	test	al, al
	je	SHORT $LN69@ReadSzArra

; 398  : 			return false;
; 399  : 
; 400  : 		if (!this->ReadByte(&type))

	mov	ecx, DWORD PTR [esi+12]
	cmp	ecx, DWORD PTR [esi+20]
	jae	SHORT $LN69@ReadSzArra
	mov	al, BYTE PTR [ecx]
	inc	ecx
	mov	BYTE PTR _type$[esp+8], al
	mov	DWORD PTR [esi+12], ecx

; 402  : 	}

	jmp	SHORT $LL10@ReadSzArra

; 390  : 	// type ::= SZARRAY CustomMod* Type
; 391  : 
; 392  : 	if (!this->ReadByte(&type))

$LN14@ReadSzArra:

; 393  : 		return false;

	xor	al, al
	pop	esi

; 420  : }

	pop	ecx
	ret	4
$LN9@ReadSzArra:

; 411  : 		default:
; 412  : 			this->ReadType(type);

	mov	ecx, esi
	cmp	al, 20					; 00000014H
	je	SHORT $LN3@ReadSzArra

; 403  : 
; 404  : 	switch (type) {

	cmp	al, 29					; 0000001dH
	je	SHORT $LN2@ReadSzArra

; 411  : 		default:
; 412  : 			this->ReadType(type);

	mov	eax, DWORD PTR _type$[esp+8]
	push	eax
	call	?ReadType@SignatureReader@@AAE_NE@Z	; SignatureReader::ReadType

; 413  : 			break;

	jmp	SHORT $LN4@ReadSzArra
$LN2@ReadSzArra:

; 407  : 			break;
; 408  : 		case ELEMENT_TYPE_SZARRAY:
; 409  : 			this->ReadSzArray(type);

	push	29					; 0000001dH
	call	?ReadSzArray@SignatureReader@@AAE_NE@Z	; SignatureReader::ReadSzArray

; 410  : 			break;

	jmp	SHORT $LN4@ReadSzArra
$LN3@ReadSzArra:

; 405  : 		case ELEMENT_TYPE_ARRAY:
; 406  : 			this->ReadShapedArray(type);

	push	20					; 00000014H
	call	?ReadShapedArray@SignatureReader@@AAE_NE@Z ; SignatureReader::ReadShapedArray
$LN4@ReadSzArra:

; 414  : 	}
; 415  : 
; 416  : 	this->buffer.push(L']');

	lea	ecx, DWORD PTR $T178549[esp+8]
	add	esi, 4388				; 00001124H
	push	ecx
	mov	DWORD PTR $T178549[esp+12], 93		; 0000005dH
	call	?push_back@?$deque@_WV?$allocator@_W@std@@@std@@QAEXAB_W@Z ; std::deque<wchar_t,std::allocator<wchar_t> >::push_back

; 417  : 	this->buffer.push(L'[');

	lea	edx, DWORD PTR $T178550[esp+8]
	push	edx
	mov	DWORD PTR $T178550[esp+12], 91		; 0000005bH
	call	?push_back@?$deque@_WV?$allocator@_W@std@@@std@@QAEXAB_W@Z ; std::deque<wchar_t,std::allocator<wchar_t> >::push_back
	pop	edi

; 418  : 
; 419  : 	return true;

	mov	al, 1
	pop	esi

; 420  : }

	pop	ecx
	ret	4
$LN69@ReadSzArra:
	pop	edi

; 401  : 			return false;

	xor	al, al
	pop	esi

; 420  : }

	pop	ecx
	ret	4
?ReadSzArray@SignatureReader@@AAE_NE@Z ENDP		; SignatureReader::ReadSzArray
; Function compile flags: /Ogtpy
;	COMDAT ?ReadShapedArray@SignatureReader@@AAE_NE@Z
_TEXT	SEGMENT
_rank$132845 = -4					; size = 4
_type$ = 8						; size = 1
$T180307 = 8						; size = 2
$T180306 = 8						; size = 2
$T180308 = 8						; size = 2
_tmpLoBound$132849 = 8					; size = 4
_numLoBounds$132847 = 8					; size = 4
_tmpSize$132848 = 8					; size = 4
_numSizes$132846 = 8					; size = 4
?ReadShapedArray@SignatureReader@@AAE_NE@Z PROC		; SignatureReader::ReadShapedArray, COMDAT
; _this$ = ecx

; 423  : {

	push	ecx

; 424  : 	// type ::= ARRAY Type ArrayShape
; 425  : 	if (type == ELEMENT_TYPE_ARRAY) {

	cmp	BYTE PTR _type$[esp], 20		; 00000014H
	push	esi
	mov	esi, ecx
	jne	SHORT $LN24@ReadShaped

; 426  : 		if (!this->ReadByte(&type))

	mov	eax, DWORD PTR [esi+12]
	cmp	eax, DWORD PTR [esi+20]
	jae	SHORT $LN24@ReadShaped
	mov	cl, BYTE PTR [eax]
	inc	eax
	mov	BYTE PTR _type$[esp+4], cl
	mov	DWORD PTR [esi+12], eax

; 428  : 		switch (type) {

	cmp	cl, 20					; 00000014H
	je	SHORT $LN17@ReadShaped
	cmp	cl, 29					; 0000001dH

; 435  : 			default:
; 436  : 				this->ReadType(type);

	mov	ecx, esi
	je	SHORT $LN16@ReadShaped
	mov	eax, DWORD PTR _type$[esp+4]
	push	eax
	call	?ReadType@SignatureReader@@AAE_NE@Z	; SignatureReader::ReadType

; 437  : 				break;

	jmp	SHORT $LN18@ReadShaped

; 426  : 		if (!this->ReadByte(&type))

$LN24@ReadShaped:

; 427  : 			return false;

	xor	al, al
	pop	esi

; 463  : 	}
; 464  : 
; 465  : 	return false;
; 466  : }

	pop	ecx
	ret	4
$LN16@ReadShaped:

; 431  : 				break;
; 432  : 			case ELEMENT_TYPE_SZARRAY:
; 433  : 				this->ReadSzArray(type);

	push	29					; 0000001dH
	call	?ReadSzArray@SignatureReader@@AAE_NE@Z	; SignatureReader::ReadSzArray

; 434  : 				break;

	jmp	SHORT $LN18@ReadShaped
$LN17@ReadShaped:

; 429  : 			case ELEMENT_TYPE_ARRAY:
; 430  : 				this->ReadShapedArray(type);

	push	20					; 00000014H
	mov	ecx, esi
	call	?ReadShapedArray@SignatureReader@@AAE_NE@Z ; SignatureReader::ReadShapedArray
$LN18@ReadShaped:
	push	edi

; 438  : 		}
; 439  : 
; 440  : 		// Read array shape
; 441  : 		// ArrayShape ::= Rank NumSizes Size* NumLoBounds LoBound*
; 442  : 		int rank, numSizes, numLoBounds, tmpSize, tmpLoBound;
; 443  : 		if (!ReadCompressedInt(&rank))

	lea	edi, DWORD PTR _rank$132845[esp+12]
	mov	eax, esi
	call	?ReadCompressedInt@SignatureReader@@AAE_NPAH@Z ; SignatureReader::ReadCompressedInt
	test	al, al

; 444  : 			return false;

	je	SHORT $LN55@ReadShaped

; 445  : 		if (!ReadCompressedInt(&numSizes))

	lea	edi, DWORD PTR _numSizes$132846[esp+8]
	mov	eax, esi
	call	?ReadCompressedInt@SignatureReader@@AAE_NPAH@Z ; SignatureReader::ReadCompressedInt
	test	al, al
	jne	SHORT $LN13@ReadShaped
$LN55@ReadShaped:
	pop	edi

; 446  : 			return false;

	xor	al, al
	pop	esi

; 463  : 	}
; 464  : 
; 465  : 	return false;
; 466  : }

	pop	ecx
	ret	4
$LN13@ReadShaped:
	push	ebx

; 447  : 		for (int i = 0; i < numSizes; i++) {

	mov	ebx, DWORD PTR _numSizes$132846[esp+12]
	push	ebp
	xor	ebp, ebp
	test	ebx, ebx
	jle	SHORT $LN10@ReadShaped
$LL12@ReadShaped:

; 448  : 			if (!ReadCompressedInt(&tmpSize))

	lea	edi, DWORD PTR _tmpSize$132848[esp+16]
	mov	eax, esi
	call	?ReadCompressedInt@SignatureReader@@AAE_NPAH@Z ; SignatureReader::ReadCompressedInt
	test	al, al
	je	$LN47@ReadShaped
	inc	ebp
	cmp	ebp, ebx
	jl	SHORT $LL12@ReadShaped
$LN10@ReadShaped:

; 449  : 				return false;
; 450  : 		}
; 451  : 		if (!ReadCompressedInt(&numLoBounds))

	lea	edi, DWORD PTR _numLoBounds$132847[esp+16]
	mov	eax, esi
	call	?ReadCompressedInt@SignatureReader@@AAE_NPAH@Z ; SignatureReader::ReadCompressedInt
	test	al, al

; 452  : 			return false;

	je	$LN47@ReadShaped

; 453  : 		for (int i = 0; i < numLoBounds; i++) {

	mov	ebx, DWORD PTR _numLoBounds$132847[esp+16]
	xor	ebp, ebp
	test	ebx, ebx
	jle	SHORT $LN5@ReadShaped
	npad	10
$LL7@ReadShaped:

; 454  : 			if (!ReadCompressedInt(&tmpLoBound))

	lea	edi, DWORD PTR _tmpLoBound$132849[esp+16]
	mov	eax, esi
	call	?ReadCompressedInt@SignatureReader@@AAE_NPAH@Z ; SignatureReader::ReadCompressedInt
	test	al, al
	je	$LN47@ReadShaped
	inc	ebp
	cmp	ebp, ebx
	jl	SHORT $LL7@ReadShaped
$LN5@ReadShaped:

; 456  : 		}
; 457  : 		this->buffer.push(L']');

	lea	ecx, DWORD PTR $T180306[esp+16]
	add	esi, 4388				; 00001124H
	push	ecx
	mov	DWORD PTR $T180306[esp+20], 93		; 0000005dH
	call	?push_back@?$deque@_WV?$allocator@_W@std@@@std@@QAEXAB_W@Z ; std::deque<wchar_t,std::allocator<wchar_t> >::push_back

; 458  : 		for (int i = 1; i < rank; i++)

	mov	eax, DWORD PTR _rank$132845[esp+20]
	cmp	eax, 1
	jle	SHORT $LN1@ReadShaped

; 456  : 		}
; 457  : 		this->buffer.push(L']');

	lea	ebx, DWORD PTR [eax-1]
	npad	4
$LL3@ReadShaped:

; 459  : 			this->buffer.push(L',');

	mov	eax, DWORD PTR [esi+28]
	mov	edx, DWORD PTR [esi+24]
	add	edx, eax
	mov	DWORD PTR $T180307[esp+16], 44		; 0000002cH
	test	dl, 7
	jne	SHORT $LN33@ReadShaped
	add	eax, 8
	shr	eax, 3
	cmp	DWORD PTR [esi+20], eax
	ja	SHORT $LN33@ReadShaped
	push	esi
	call	?_Growmap@?$deque@_WV?$allocator@_W@std@@@std@@IAEXI@Z ; std::deque<wchar_t,std::allocator<wchar_t> >::_Growmap
$LN33@ReadShaped:
	mov	ebp, DWORD PTR [esi+28]
	add	ebp, DWORD PTR [esi+24]
	mov	eax, DWORD PTR [esi+20]
	mov	edi, ebp
	shr	edi, 3
	cmp	eax, edi
	ja	SHORT $LN32@ReadShaped
	sub	edi, eax
$LN32@ReadShaped:
	mov	eax, DWORD PTR [esi+16]
	cmp	DWORD PTR [eax+edi*4], 0
	jne	SHORT $LN31@ReadShaped
	push	8
	lea	ecx, DWORD PTR [esi+12]
	call	DWORD PTR __imp_?allocate@?$allocator@_W@std@@QAEPA_WI@Z
	mov	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [ecx+edi*4], eax
$LN31@ReadShaped:
	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax+edi*4]
	lea	edx, DWORD PTR $T180307[esp+16]
	push	edx
	and	ebp, 7
	lea	edx, DWORD PTR [ecx+ebp*2]
	push	edx
	lea	ecx, DWORD PTR [esi+12]
	call	DWORD PTR __imp_?construct@?$allocator@_W@std@@QAEXPA_WAB_W@Z
	inc	DWORD PTR [esi+28]
	sub	ebx, 1
	jne	SHORT $LL3@ReadShaped
$LN1@ReadShaped:

; 460  : 		this->buffer.push(L'[');

	mov	eax, DWORD PTR [esi+28]
	mov	ecx, DWORD PTR [esi+24]
	add	ecx, eax
	mov	DWORD PTR $T180308[esp+16], 91		; 0000005bH
	test	cl, 7
	jne	SHORT $LN40@ReadShaped
	add	eax, 8
	shr	eax, 3
	cmp	DWORD PTR [esi+20], eax
	ja	SHORT $LN40@ReadShaped
	push	esi
	call	?_Growmap@?$deque@_WV?$allocator@_W@std@@@std@@IAEXI@Z ; std::deque<wchar_t,std::allocator<wchar_t> >::_Growmap
$LN40@ReadShaped:
	mov	ebp, DWORD PTR [esi+24]
	add	ebp, DWORD PTR [esi+28]
	mov	eax, DWORD PTR [esi+20]
	mov	edi, ebp
	shr	edi, 3
	cmp	eax, edi
	ja	SHORT $LN39@ReadShaped
	sub	edi, eax
$LN39@ReadShaped:
	mov	edx, DWORD PTR [esi+16]
	cmp	DWORD PTR [edx+edi*4], 0
	jne	SHORT $LN38@ReadShaped
	push	8
	lea	ecx, DWORD PTR [esi+12]
	call	DWORD PTR __imp_?allocate@?$allocator@_W@std@@QAEPA_WI@Z
	mov	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [ecx+edi*4], eax
$LN38@ReadShaped:
	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax+edi*4]
	lea	edx, DWORD PTR $T180308[esp+16]
	push	edx
	and	ebp, 7
	lea	edx, DWORD PTR [ecx+ebp*2]
	push	edx
	lea	ecx, DWORD PTR [esi+12]
	call	DWORD PTR __imp_?construct@?$allocator@_W@std@@QAEXPA_WAB_W@Z
	inc	DWORD PTR [esi+28]
	pop	ebp
	pop	ebx
	pop	edi

; 461  : 
; 462  : 		return true;

	mov	al, 1
	pop	esi

; 463  : 	}
; 464  : 
; 465  : 	return false;
; 466  : }

	pop	ecx
	ret	4
$LN47@ReadShaped:
	pop	ebp
	pop	ebx
	pop	edi

; 455  : 				return false;

	xor	al, al
	pop	esi

; 463  : 	}
; 464  : 
; 465  : 	return false;
; 466  : }

	pop	ecx
	ret	4
?ReadShapedArray@SignatureReader@@AAE_NE@Z ENDP		; SignatureReader::ReadShapedArray
; Function compile flags: /Ogtpy
;	COMDAT ?ReadArrayType@SignatureReader@@AAE_NE@Z
_TEXT	SEGMENT
$T181072 = -16						; size = 8
__Tmp$181094 = -8					; size = 8
_type$ = 8						; size = 1
?ReadArrayType@SignatureReader@@AAE_NE@Z PROC		; SignatureReader::ReadArrayType, COMDAT
; _this$ = ecx

; 470  : 	if (type == ELEMENT_TYPE_ARRAY)

	mov	al, BYTE PTR _type$[esp-4]
	sub	esp, 16					; 00000010H
	push	esi
	mov	esi, ecx
	cmp	al, 20					; 00000014H
	jne	SHORT $LN4@ReadArrayT

; 471  : 		this->ReadShapedArray(type);

	push	20					; 00000014H
	call	?ReadShapedArray@SignatureReader@@AAE_NE@Z ; SignatureReader::ReadShapedArray

; 472  : 	
; 473  : 	if (type == ELEMENT_TYPE_SZARRAY)

	jmp	SHORT $LN85@ReadArrayT
$LN4@ReadArrayT:
	cmp	al, 29					; 0000001dH
	jne	SHORT $LN85@ReadArrayT

; 474  : 		this->ReadSzArray(type);

	push	29					; 0000001dH
	call	?ReadSzArray@SignatureReader@@AAE_NE@Z	; SignatureReader::ReadSzArray
$LN85@ReadArrayT:

; 475  : 
; 476  : 	while (!buffer.empty()) {

	cmp	DWORD PTR [esi+4416], 0
	je	$LN87@ReadArrayT
	push	ebx
	push	ebp
	push	edi
$LL2@ReadArrayT:

; 477  : 		this->output << buffer.top();

	mov	eax, DWORD PTR [esi+4412]
	mov	edi, DWORD PTR [esi+4416]
	add	edi, eax
	cmp	eax, edi
	jbe	SHORT $LN21@ReadArrayT
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN21@ReadArrayT:
	mov	ebx, DWORD PTR [esi+4388]
	mov	ebp, ebx
	mov	DWORD PTR __Tmp$181094[esp+36], edi
	test	ebx, ebx
	jne	SHORT $LN86@ReadArrayT
	call	DWORD PTR __imp___invalid_parameter_noinfo
	xor	eax, eax
	xor	ecx, ecx
$LN65@ReadArrayT:
	mov	ecx, DWORD PTR [ecx+28]
	add	ecx, DWORD PTR [eax+24]
	dec	edi
	cmp	edi, ecx
	ja	SHORT $LN44@ReadArrayT
	test	ebx, ebx
	je	SHORT $LN70@ReadArrayT
	mov	ebx, DWORD PTR [ebx]
	jmp	SHORT $LN71@ReadArrayT
$LN86@ReadArrayT:
	mov	eax, DWORD PTR [ebx]
	mov	ecx, eax
	jmp	SHORT $LN65@ReadArrayT
$LN70@ReadArrayT:
	xor	ebx, ebx
$LN71@ReadArrayT:
	cmp	edi, DWORD PTR [ebx+24]
	jae	SHORT $LN43@ReadArrayT
$LN44@ReadArrayT:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN43@ReadArrayT:
	lea	eax, DWORD PTR $T181072[esp+32]
	mov	DWORD PTR $T181072[esp+32], ebp
	mov	DWORD PTR $T181072[esp+36], edi
	call	??D?$_Deque_const_iterator@_WV?$allocator@_W@std@@$00@std@@QBEAB_WXZ ; std::_Deque_const_iterator<wchar_t,std::allocator<wchar_t>,1>::operator*
	movzx	edx, WORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR [esi+4260]
	push	eax
	call	??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@_W@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >

; 478  : 		buffer.pop();

	mov	eax, DWORD PTR [esi+4416]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN78@ReadArrayT
	mov	ecx, DWORD PTR [esi+4412]
	mov	edx, DWORD PTR [esi+4408]
	lea	ecx, DWORD PTR [ecx+eax-1]
	mov	eax, ecx
	shr	eax, 3
	cmp	edx, eax
	ja	SHORT $LN79@ReadArrayT
	sub	eax, edx
$LN79@ReadArrayT:
	mov	edx, DWORD PTR [esi+4404]
	mov	eax, DWORD PTR [edx+eax*4]
	and	ecx, 7
	lea	ecx, DWORD PTR [eax+ecx*2]
	push	ecx
	lea	ecx, DWORD PTR [esi+4400]
	call	DWORD PTR __imp_?destroy@?$allocator@_W@std@@QAEXPA_W@Z
	add	DWORD PTR [esi+4416], -1
	jne	SHORT $LN78@ReadArrayT
	mov	DWORD PTR [esi+4412], 0
$LN78@ReadArrayT:

; 475  : 
; 476  : 	while (!buffer.empty()) {

	cmp	DWORD PTR [esi+4416], 0
	jne	$LL2@ReadArrayT
	pop	edi
	pop	ebp
	pop	ebx
$LN87@ReadArrayT:

; 479  : 	}
; 480  : 
; 481  : 	return true;

	mov	al, 1
	pop	esi

; 482  : }

	add	esp, 16					; 00000010H
	ret	4
?ReadArrayType@SignatureReader@@AAE_NE@Z ENDP		; SignatureReader::ReadArrayType
END
